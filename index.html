	<!DOCTYPE html>
	<html lang="zh-TW">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>饋線圖地圖系統</title>
		
		<!-- 🔧 修正：先載入 Leaflet CSS -->
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
			  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
			  crossorigin=""/>
		
		<!-- 🔧 修正：再載入 Leaflet JavaScript -->
		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
				integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
				crossorigin=""></script>
		
		<!-- 🔧 修正：最後載入依賴 Leaflet 的插件 -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-compass@1.0.0/dist/leaflet-compass.css">
		<script src="https://cdn.jsdelivr.net/npm/leaflet-compass@1.0.0/dist/leaflet-compass.js"></script>
		<script src="https://unpkg.com/leaflet-rotate@0.1.4/dist/leaflet-rotate-src.js"></script>
		
		<!-- 在 head 區域加入 Supabase 客戶端 -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
		<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Arial', sans-serif;
    background-color: #f5f5f5;
}

.header {
    background: linear-gradient(135deg, #2c3e50, #3498db);
    color: white;
    padding: 15px 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.header h1 {
    font-size: 24px;
    margin-bottom: 5px;
}

.header p {
    font-size: 14px;
    opacity: 0.9;
}

/* 🔧 修正：電腦版固定布局 + 手機版響應式 */
.container {
    display: flex;
    height: calc(100vh - 80px);
    position: relative;
}

.sidebar {
    width: 320px;
    background: white;
    border-right: 1px solid #ddd;
    overflow-y: auto;
    box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    z-index: 100;
    position: relative;
}

.map-container {
    flex: 1;
    position: relative;
    margin-left: 0;
}

#map {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

/* 🆕 手機版導航 - 預設隱藏 */
.mobile-nav {
    display: none;
    background: #2c3e50;
    justify-content: space-around;
    padding: 10px 0;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.nav-tab {
    flex: 1;
    padding: 12px;
    background: transparent;
    color: #bdc3c7;
    border: none;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.nav-tab.active {
    color: #3498db;
    background: rgba(52, 152, 219, 0.1);
    border-radius: 8px;
}

.file-upload-section {
    margin-bottom: 25px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 2px dashed #dee2e6;
    transition: all 0.3s ease;
}

.file-upload-section:hover {
    border-color: #3498db;
    background: #e3f2fd;
}

.file-upload-section h3 {
    margin-bottom: 15px;
    color: #2c3e50;
    font-size: 16px;
}

.file-input-wrapper {
    position: relative;
    display: inline-block;
    width: 100%;
}

#fileInput {
    display: none;
}

.file-input-button {
    display: block;
    width: 100%;
    padding: 12px 20px;
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    text-align: center;
}

.file-input-button:hover {
    background: linear-gradient(135deg, #2980b9, #1f5f8b);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
}

.file-info {
    margin-top: 10px;
    font-size: 12px;
    color: #666;
    text-align: center;
}

.layer-controls {
    margin-bottom: 25px;
}

.layer-controls h3 {
    margin-bottom: 15px;
    color: #2c3e50;
    font-size: 16px;
    border-bottom: 2px solid #3498db;
    padding-bottom: 5px;
}

.layer-item {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    padding: 8px 12px;
    background: #f8f9fa;
    border-radius: 6px;
    transition: background 0.3s ease;
}

.layer-item:hover {
    background: #e9ecef;
}

.layer-item input[type="checkbox"] {
    margin-right: 10px;
    transform: scale(1.2);
}

.layer-item label {
    flex: 1;
    cursor: pointer;
    font-size: 14px;
    color: #495057;
}

.layer-count {
    font-size: 12px;
    color: #6c757d;
    background: #e9ecef;
    padding: 2px 8px;
    border-radius: 12px;
    margin-left: 8px;
}

.status-section {
    margin-bottom: 20px;
}

.status-section h3 {
    margin-bottom: 10px;
    color: #2c3e50;
    font-size: 16px;
}

#loadStatus {
    padding: 10px;
    background: #e8f5e8;
    border: 1px solid #c3e6c3;
    border-radius: 6px;
    font-size: 13px;
    color: #155724;
}

.legend {
    margin-top: 20px;
    padding: 15px;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 6px;
}

.legend h4 {
    margin-bottom: 10px;
    color: #2c3e50;
    font-size: 14px;
}

.legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    font-size: 12px;
}

.legend-color {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    margin-right: 8px;
    border: 2px solid #fff;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.2);
}

.legend-line {
    width: 20px;
    height: 3px;
    margin-right: 8px;
    border-radius: 2px;
}

.legend-line-dashed {
    width: 20px;
    height: 3px;
    margin-right: 8px;
    border-radius: 2px;
    background-image: repeating-linear-gradient(
        to right,
        currentColor,
        currentColor 4px,
        transparent 4px,
        transparent 8px
    );
}

.loading {
    display: none;
    text-align: center;
    padding: 20px;
    color: #666;
}

.loading.show {
    display: block;
}

.feeder-info {
    margin-bottom: 20px;
    padding: 15px;
    background: #e3f2fd;
    border-radius: 6px;
    border-left: 4px solid #2196f3;
}

.feeder-info h4 {
    margin-bottom: 8px;
    color: #1976d2;
}

.feeder-info p {
    margin: 4px 0;
    font-size: 13px;
    color: #424242;
}

/* 線段高亮控制按鈕樣式 */
.highlight-controls {
    margin-top: 15px;
    padding: 10px;
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 6px;
    text-align: center;
}

.reset-highlight-btn {
    background: #28a745;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.3s ease;
}

.reset-highlight-btn:hover {
    background: #218838;
}

/* 設備圖標樣式 */
.simple-device-icon {
    background: transparent !important;
    border: none !important;
}

.simple-device-icon div {
    transition: none !important;
}

.leaflet-div-icon.arrow-icon {
    background: transparent !important;
    border: none !important;
}

.arrow-marker {
    width: 0;
    height: 0;
    border-left: 12px solid transparent;
    border-right: 12px solid transparent;
    border-bottom: 24px solid;
    transform-origin: center bottom;
}

/* 星星標記樣式 */
.opposite-star-icon {
    background: transparent !important;
    border: none !important;
}

.opposite-star-marker {
    display: flex;
    flex-direction: row;
    align-items: center;
    text-align: left;
    white-space: nowrap;
}

.star-icon {
    font-size: 16px;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
    margin-right: 4px;
    flex-shrink: 0;
}

.opposite-text {
    background: rgba(255, 0, 0, 0.9);
    color: white;
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: bold;
    border: 1px solid #ff0000;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    white-space: nowrap;
    flex-shrink: 0;
}

/* 全選控制區域樣式 */
.select-all-container {
    margin-bottom: 15px;
    padding: 12px;
    background: #f8f9fa;
    border-radius: 6px;
    border: 1px solid #dee2e6;
}

.select-all-section h4 {
    margin: 0 0 10px 0;
    color: #2c3e50;
    font-size: 14px;
    font-weight: bold;
}

.select-all-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 8px;
}

.select-all-btn {
    padding: 6px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: #fff;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
    text-align: center;
    font-weight: 500;
}

.select-all-btn:hover {
    background: #e9ecef;
    border-color: #adb5bd;
    transform: translateY(-1px);
}

.select-all-btn.equipment {
    border-left: 3px solid #ff6b35;
    color: #ff6b35;
}

.select-all-btn.lines {
    border-left: 3px solid #4ecdc4;
    color: #4ecdc4;
}

.select-all-btn.deselect {
    grid-column: 1 / -1;
    border-left: 3px solid #dc3545;
    color: #dc3545;
}

.select-all-btn.active {
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    border-color: #28a745;
    box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
}

.select-all-btn.active:hover {
    background: linear-gradient(135deg, #218838, #1e7e34);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(40, 167, 69, 0.4);
}

.select-all-btn.equipment.active,
.select-all-btn.lines.active {
    border-left: 3px solid #fff;
}

.divider {
    border: none;
    border-top: 1px solid #dee2e6;
    margin: 10px 0;
}

/* 自訂彈出視窗樣式 */
.custom-popup .leaflet-popup-content-wrapper {
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    border: none;
}

.custom-popup .leaflet-popup-content {
    margin: 10px;
    line-height: 1.4;
}

.custom-popup .leaflet-popup-tip {
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* 饋線選擇區域樣式 */
.feeder-selection-section {
    margin-bottom: 25px;
    padding: 20px;
    background: #e8f5e8;
    border-radius: 8px;
    border: 2px solid #28a745;
    transition: all 0.3s ease;
}

.feeder-selection-section h3 {
    margin-bottom: 15px;
    color: #155724;
    font-size: 16px;
    font-weight: bold;
}

.feeder-input-row {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 12px;
}

.feeder-input {
    width: 100%;
    padding: 10px;
    border: 2px solid #28a745;
    border-radius: 6px;
    font-size: 14px;
    outline: none;
    transition: border-color 0.3s ease;
}

.feeder-input:focus {
    border-color: #20c997;
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.1);
}

.feeder-dropdown {
    width: 100%;
    padding: 10px;
    border: 2px solid #28a745;
    border-radius: 6px;
    font-size: 14px;
    outline: none;
    background: white;
    cursor: pointer;
}

.feeder-button-row {
    margin-bottom: 12px;
}

.load-feeder-btn {
    width: 100%;
    padding: 12px 20px;
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 4px 8px rgba(40, 167, 69, 0.2);
}

.load-feeder-btn:hover {
    background: linear-gradient(135deg, #218838, #1e7e34);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(40, 167, 69, 0.3);
}

.load-feeder-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
}

.load-feeder-btn:disabled {
    background: #6c757d;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.load-feeder-btn.loading {
    background: #17a2b8;
    animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.feeder-info-text {
    font-size: 12px;
    color: #155724;
    text-align: center;
    line-height: 1.4;
}

.feeder-selection-section.success {
    border-color: #28a745;
    background: linear-gradient(135deg, #d4edda, #c3e6cb);
}

.feeder-selection-section.loading {
    border-color: #17a2b8;
    background: linear-gradient(135deg, #d1ecf1, #bee5eb);
}

.feeder-selection-section.error {
    border-color: #dc3545;
    background: linear-gradient(135deg, #f8d7da, #f5c6cb);
}

/* 定位按鈕樣式 */
.location-controls {
    position: absolute;
    bottom: 20px;
    right: 10px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.location-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: background 0.3s;
}

.location-btn:hover {
    background: #45a049;
}

.location-btn.active {
    background: #2196F3;
}

/* 圖號座標輸入區域 */
.coordinate-input-section {
    margin-bottom: 25px;
    padding: 20px;
    background: #fff3cd;
    border-radius: 8px;
    border: 2px solid #ffc107;
}

.coordinate-input-section h3 {
    margin-bottom: 15px;
    color: #856404;
    font-size: 16px;
}

.coordinate-input {
    width: 100%;
    padding: 10px;
    border: 2px solid #ffc107;
    border-radius: 6px;
    font-size: 14px;
    margin-bottom: 10px;
}

.coordinate-btn {
    width: 100%;
    padding: 10px;
    background: #ffc107;
    color: #212529;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
}

.coordinate-btn:hover {
    background: #e0a800;
}

/* 地圖旋轉控制樣式 */
/* 地圖旋轉控制樣式 - 簡化版 */
.rotation-controls {
    position: absolute;
    bottom: 120px;
    right: 10px;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 140px; /* 縮小寬度 */
    z-index: 1000;
}

/* 🔧 修正版：按鈕樣式 - 確保 active 狀態正確顯示 */
.rotation-btn {
    background: white;
    border: 2px solid #ddd;
    color: #333;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;
}

.rotation-btn:hover {
    background: #f8f9fa;
    border-color: #007bff;
    transform: translateY(-1px);
}

.rotation-btn.active {
    background: #007bff !important;
    color: white !important;
    border-color: #0056b3 !important;
    box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
}

/* 🔧 特別處理跟隨方向按鈕的啟用狀態 */
#followHeadingBtn.active {
    background: #007bff !important;
    border-color: #0056b3 !important;
    box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
}
/* 圖層切換增強樣式 */
.layer-switcher-compact {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 1001;
}

.layer-toggle-btn {
    background: rgba(255, 255, 255, 0.9);
    border: 2px solid #ddd;
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

.layer-toggle-btn:hover {
    background: white;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.layer-menu {
    position: absolute;
    top: 45px;
    right: 0;
    background: white;
    border: 2px solid #ddd;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    max-width: 280px;
    max-height: 400px;
    overflow-y: auto;
    animation: slideDown 0.3s ease;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.layer-group {
    margin-bottom: 15px;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
}

.layer-group:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.layer-group h5 {
    margin: 0 0 8px 0;
    font-size: 13px;
    font-weight: bold;
    color: #333;
}

.layer-option {
    display: flex;
    align-items: center;
    margin: 5px 0;
    font-size: 12px;
}

.layer-option input {
    margin-right: 8px;
}

.layer-option label {
    cursor: pointer;
    flex: 1;
}

.layer-opacity-control {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 11px;
}

.opacity-slider {
    flex: 1;
    height: 4px;
}

/* 全螢幕控制 */
.fullscreen-btn {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10000;
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    white-space: nowrap;
}

.fullscreen-btn:hover {
    background: #45a049;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

.fullscreen-mode .fullscreen-btn {
    background: #ff5722;
    animation: pulse 2s infinite;
}

.fullscreen-mode .fullscreen-btn:hover {
    background: #e64a19;
}

/* 🆕 新增：側邊欄切換按鈕 */
.sidebar-toggle-btn {
    position: absolute;
    top: 10px;
    left: 70px; /* 在全螢幕按鈕右邊 */
    z-index: 10000;
    background: #2196F3;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    white-space: nowrap;
    display: none; /* 預設隱藏 */
}

.sidebar-toggle-btn:hover {
    background: #1976D2;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

.fullscreen-mode .sidebar-toggle-btn {
    display: block; /* 全螢幕時顯示 */
}

/* 🔧 修改：全螢幕模式保留左側選單 */
.fullscreen-mode .header {
    display: none;
}

.fullscreen-mode .container {
    height: 100vh;
}

/* 🔧 新增：全螢幕時保留側邊欄，但可以切換顯示/隱藏 */
.fullscreen-mode .sidebar {
    position: fixed;
    left: 0;
    top: 0;
    width: 320px;
    height: 100vh;
    z-index: 1001;
    background: white;
    box-shadow: 2px 0 10px rgba(0,0,0,0.3);
    transition: left 0.3s ease;
}
/* 🆕 新增：隱藏側邊欄的狀態 */
.fullscreen-mode .sidebar.hidden {
    left: -320px;
}

.fullscreen-mode .map-container {
    width: 100%;
    height: 100vh;
    margin-left: 0;
    transition: margin-left 0.3s ease;
}

/* 🆕 新增：當側邊欄顯示時，地圖容器向右偏移 */
.fullscreen-mode .map-container.with-sidebar {
    margin-left: 320px;
    width: calc(100% - 320px);
}
/* 🔧 新增：手機版隱藏全螢幕按鈕 */
@media (max-width: 768px) {
    .fullscreen-btn {
        display: none !important;
    }
}

/* 測量工具樣式 */
.measure-controls {
    position: absolute;
    top: 60px;
    left: 10px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.measure-btn {
    background: #FF9800;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.measure-btn:hover {
    background: #F57C00;
}

.measure-btn.active {
    background: #E65100;
}

/* 🔧 修正：手機版專用樣式 */
@media (max-width: 768px) {
	/* 定位控制按鈕 - 縮小版 */
    .location-controls {
        position: fixed;
        bottom: 20px;        /* 🔧 改到底部 */
        right: 15px;         /* 🔧 保持右側 */
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
		
    .location-btn, .rotation-btn {
        background: #4CAF50;
        color: white;
        border: none;
        padding: 6px 10px;   /* 🔧 縮小按鈕 */
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;     /* 🔧 縮小字體 */
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        transition: background 0.3s;
        min-width: 70px;     /* 🔧 限制寬度 */
        max-width: 90px;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
		

    .mobile-nav {
        display: flex !important;
    }
    
    .nav-tab {
        flex: 1;
        padding: 12px;
        background: transparent;
        color: #bdc3c7;
        border: none;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .nav-tab.active {
        color: #3498db;
        background: rgba(52, 152, 219, 0.1);
        border-radius: 8px;
    }
    
    .header {
        display: none;
    }
    
    .container {
        height: 100vh;
        margin-top: 60px;
        flex-direction: column;
    }
    
    .sidebar {
        width: 100%;
        height: calc(100vh - 60px);
        position: fixed;
        top: 60px;
        left: 0;
        z-index: 999;
        display: none;
        border-right: none;
        border-bottom: 1px solid #ddd;
    }
    
    .map-container {
        width: 100%;
        height: calc(100vh - 60px);
        position: fixed;
        top: 60px;
        left: 0;
        margin-left: 0;
    }
    
    #map {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    
    /* 觸控優化 */
    .control-btn {
        padding: 12px 16px;
        font-size: 14px;
        min-height: 44px; /* 🔧 確保觸控友好的最小高度 */
        -webkit-touch-callout: none; /* 🔧 禁用長按選單 */
    }
    .measure-btn,
    .load-feeder-btn {
        min-height: 44px;
        min-width: 44px;
        font-size: 16px;
        padding: 12px 16px;
    }
    
    .measure-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        top: auto;
        left: auto;
        flex-direction: row;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 25px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .control-btn:active,
    .measure-btn:active {
        transform: scale(0.95);
        transition: transform 0.1s;
    }
    
    .feeder-input,
    .feeder-dropdown {
        width: 100%;
    }
    
    .load-feeder-btn {
        font-size: 14px;
        padding: 10px 16px;
    }
	
	
	
}

/* 🔧 修正：桌面版確保正常顯示 */
@media (min-width: 769px) {
    .mobile-nav {
        display: none !important;
    }
    
    .header {
        display: block;
    }
    
    .container {
        margin-top: 0;
        height: calc(100vh - 80px);
    }
    
    .sidebar {
        position: relative;
        display: block;
    }
    
    .map-container {
        position: relative;
    }
}

/* Google Maps 風格的定位圖標 */
.location-marker {
    position: relative;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* 外圈光暈效果 */
.location-marker::before {
    content: '';
    position: absolute;
    width: 40px;
    height: 40px;
    background: rgba(66, 133, 244, 0.2);
    border-radius: 50%;
    animation: pulse-glow 2s infinite;
    z-index: 1;
}

/* 中間白色圓圈 */
.location-marker::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
    border: 2px solid #4285f4;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    z-index: 2;
}

/* 中心藍色圓點 - 加大尺寸 */
.location-marker .center-dot {
    width: 12px;
    height: 12px;
    background: #4285f4;
    border-radius: 50%;
    z-index: 3;
    position: relative;
}

/* 光暈動畫 */
@keyframes pulse-glow {
    0% {
        transform: scale(0.8);
        opacity: 0.8;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.3;
    }
    100% {
        transform: scale(0.8);
        opacity: 0.8;
    }
}



/* 手機版指北針調整 */

/* 🔧 新增：手機版隱藏測量工具 */
@media (max-width: 768px) {
    .measure-controls {
        display: none !important;
    }
}

/* 🔧 修正版：按鈕樣式 - 避免反白問題 */
.control-btn {
    background: #fff;
    border: 2px solid #ddd;
    color: #333;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    user-select: none; /* 🔧 防止文字選取 */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent; /* 🔧 移除點擊高亮 */
}

.control-btn:hover {
    background: #f8f9fa;
    border-color: #007bff;
    transform: translateY(-1px);
}

.control-btn.active {
    background: #007bff !important;
    color: white !important;
    border-color: #0056b3 !important;
    box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
}

/* 🔧 特別處理停止按鈕 */
.control-btn.active[id="locateBtn"] {
    background: #dc3545 !important;
    border-color: #c82333 !important;
    box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
}

/* 🆕 停電資料樣式 */
.outage-data-section {
    animation: slideIn 0.5s ease-out;
}

/* 🔧 修改：停電資料樣式 - 加入狀態顏色支援 */
.outage-feeder-item:hover {
    background: #f8f9fa !important;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: all 0.2s ease;
}

.fault-line-animation {
    animation: dash 2s linear infinite;
}

@keyframes dash {
    to {
        stroke-dashoffset: -20;
    }
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
/* 🆕 不同狀態的 hover 效果 */
.outage-feeder-item[style*="border-left: 4px solid #28a745"]:hover {
    box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
}

.outage-feeder-item[style*="border-left: 4px solid #6c757d"]:hover {
    box-shadow: 0 2px 8px rgba(108, 117, 125, 0.3);
}

.outage-feeder-item[style*="border-left: 4px solid #dc3545"]:hover {
    box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
}
/* 🆕 手機版饋線詳情樣式 */
@media (max-width: 768px) {
    #feederDetailsContainer {
        animation: slideInFromRight 0.3s ease-out;
    }
    
    @keyframes slideInFromRight {
        from {
            transform: translateX(100%);
        }
        to {
            transform: translateX(0);
        }
    }
    
    /* 防止在詳情頁面時誤觸地圖 */
    #feederDetailsContainer ~ * {
        pointer-events: none;
    }
}

/* 手機版按鈕優化 */
@media (max-width: 768px) {
    .outage-feeder-item {
        padding: 15px !important;
        margin-bottom: 12px !important;
    }
    
    .outage-feeder-item strong {
        font-size: 16px !important;
    }
}

/* 🔧 修改：災情查報相關樣式 - 藍色系 */
.disaster-report-section {
    margin-bottom: 25px;
    padding: 20px;
    background: linear-gradient(135deg, #e3f2fd, #bbdefb);
    border-radius: 8px;
    border: 2px solid #2196f3;
    transition: all 0.3s ease;
}


.disaster-marker-icon {
    background: transparent !important;
    border: none !important;
}

.disaster-popup .leaflet-popup-content-wrapper {
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    border: none;
}

.photo-modal {
    display: none;
    position: fixed;
    z-index: 2000;
    padding-top: 50px;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.9);
}

.photo-modal-content {
    margin: auto;
    display: block;
    max-width: 90%;
    max-height: 80%;
    object-fit: contain;
}

.photo-modal-close {
    position: absolute;
    top: 15px;
    right: 25px;
    color: white;
    font-size: 35px;
    font-weight: bold;
    cursor: pointer;
    z-index: 2002;
}

.photo-navigation {
    position: absolute;
    width: 100%;
    top: 50%;
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
    box-sizing: border-box;
    z-index: 2001;
}

.photo-nav-btn {
    background-color: rgba(0,0,0,0.5);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.3s;
}

.photo-nav-btn:hover {
    background-color: rgba(0,0,0,0.8);
}

.photo-counter {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0,0,0,0.5);
    color: white;
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 14px;
    z-index: 2001;
}

.repair-status-badge {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: bold;
    margin-bottom: 5px;
}

.repair-status-completed {
    background-color: #28a745;
    color: white;
}

.repair-status-dispatched {
    background-color: #ffc107;
    color: #212529;
}

.repair-status-pending {
    background-color: #dc3545;
    color: white;
}

.severity-badge {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 8px;
    font-size: 9px;
    font-weight: bold;
    margin-left: 5px;
}

.severity-極嚴重 { background-color: #6f42c1; color: white; }
.severity-嚴重 { background-color: #dc3545; color: white; }
.severity-一般 { background-color: #fd7e14; color: white; }
.severity-輕微 { background-color: #ffc107; color: #212529; }
.severity-不影響 { background-color: #6c757d; color: white; }
.severity-未定義 { background-color: #e9ecef; color: #495057; }
		</style>
	</head>
	<body>
	    <!-- 🆕 在這裡加入手機版導航 - 放在最頂部 -->
    <div class="mobile-nav" style="display: none;">
        <button class="nav-tab active" data-tab="map">🗺️ 地圖</button>
        <button class="nav-tab" data-tab="controls">⚙️ 控制</button>
    </div>
		<div class="header">
			<h1>🗺️ 饋線圖地圖系統</h1>
			<p>載入配電系統 JSON 檔案並自訂圖層顯示（支援點與線段高亮）</p>
		</div>
		
		<div class="container">
			<div class="sidebar">
			<!-- 🆕 停電資料區域 -->
			<div class="outage-data-section" style="margin-bottom: 25px; padding: 20px; background: #fff3cd; border-radius: 8px; border: 2px solid #ffc107;">
				<h3 style="color: #856404; margin-bottom: 15px;">⚡ 饋線監控面板</h3>
				
				<div id="outageStatus" style="margin-bottom: 15px; padding: 10px; background: #e8f5e8; border-radius: 6px; font-size: 13px;">
					正在載入停電資料...
				</div>
				
				<!-- 饋線跳脫清單 -->
				<div id="outageFeederList" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;">
					<!-- 動態載入的饋線清單 -->
				</div>
				
				<!-- 操作按鈕 -->
				<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
					<button onclick="refreshOutageData()" 
							style="padding: 8px 12px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
						🔄 重新整理
					</button>

				</div>
			</div>
			
			<!-- 🔧 修改：災情查報區域 - 改為藍色系 -->
			<div class="disaster-report-section" style="margin-bottom: 25px; padding: 20px; background: linear-gradient(135deg, #e3f2fd, #bbdefb); border-radius: 8px; border: 2px solid #2196f3;">
				<h3 style="color: #0d47a1; margin-bottom: 15px; text-shadow: 0 1px 2px rgba(13, 71, 161, 0.1);">🚨 災情查報面板</h3>
				
				<div id="disasterStatus" style="margin-bottom: 15px; padding: 10px; background: #e8f4fd; border: 1px solid #64b5f6; border-radius: 6px; font-size: 13px; color: #1565c0;">
					正在載入災情資料...
				</div>
				
				<!-- 災情清單 -->
				<div id="disasterReportList" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;">
					<!-- 動態載入的災情清單 -->
				</div>
				
				<!-- 篩選控制 -->
				<div style="margin-bottom: 10px;">
					<select id="disasterFilter" style="width: 100%; padding: 8px; border: 2px solid #42a5f5; border-radius: 4px; background: white; color: #1565c0; font-weight: 500;" onchange="filterDisasterReports()">
						<option value="all">所有災情</option>
						<option value="未修復">未修復</option>
						<option value="已派修">已派修</option>
						<option value="已修復">已修復</option>
					</select>
				</div>
				
				<!-- 操作按鈕 -->
				<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
					<button onclick="refreshDisasterData()" 
							style="padding: 8px 12px; background: linear-gradient(135deg, #1976d2, #1565c0); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(25, 118, 210, 0.3);"
							onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(25, 118, 210, 0.4)';"
							onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(25, 118, 210, 0.3)';">
						🔄 重新整理
					</button>
					<button onclick="showDisasterMap()" 
							style="padding: 8px 12px; background: linear-gradient(135deg, #2196f3, #1976d2); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);"
							onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(33, 150, 243, 0.4)';"
							onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(33, 150, 243, 0.3)';">
						🗺️ 災情地圖
					</button>
				</div>
			</div>
			<!-- 🆕 饋線選擇區域 -->
			<div class="feeder-selection-section">
				<h3>🌐 從雲端載入饋線資料</h3>
				
				<!-- 🆕 分成兩行顯示 -->
				<div class="feeder-input-row">
					<input type="text" 
						   id="feederInput" 
						   class="feeder-input" 
						   placeholder="輸入饋線名稱(如: 6A22)"
						   maxlength="4">
					<select id="feederDropdown" class="feeder-dropdown">
						<option value="">選擇饋線</option>
					</select>
				</div>
				
				<!-- 🆕 按鈕獨立一行 -->
				<div class="feeder-button-row">
					<button class="load-feeder-btn" onclick="loadFeederFromCloud()">
						🌐 載入饋線資料
					</button>
				</div>
				
				<div class="feeder-info-text">
					<!-- 🆕 快取控制區域 -->
						<div class="cache-controls" style="margin-top: 10px; display: flex; gap: 8px;">
							<button onclick="preloadPopularFeeders()" 
									style="flex: 1; padding: 6px; font-size: 11px; background: #17a2b8; 
										   color: white; border: none; border-radius: 4px; cursor: pointer;">
								🔥 預載熱門
							</button>
							<button onclick="showCacheStats()" 
									style="flex: 1; padding: 6px; font-size: 11px; background: #6c757d; 
										   color: white; border: none; border-radius: 4px; cursor: pointer;">
								📊 快取狀態
							</button>
							<button onclick="feederCache.clear(); showToast('快取已清除', 'info')" 
									style="flex: 1; padding: 6px; font-size: 11px; background: #dc3545; 
										   color: white; border: none; border-radius: 4px; cursor: pointer;">
								🗑️ 清除快取
							</button>
						</div>
				</div>
			</div>
			
			<!-- 🆕 鄰近設備搜尋區域 -->
			<!-- 🔧 修正版：鄰近設備搜尋區域 - 新增更多半徑選項 -->
			<div class="nearby-search-section" style="margin-bottom: 25px; padding: 20px; background: #e8f4fd; border-radius: 8px; border: 2px solid #2196f3;">
				<h3 style="color: #0d47a1; margin-bottom: 15px; text-shadow: 0 1px 2px rgba(13, 71, 161, 0.1);">🎯 鄰近設備搜尋</h3>
				
				<div style="margin-bottom: 15px;">
					<label style="display: block; margin-bottom: 8px; font-weight: bold; color: #1565c0;">搜尋半徑</label>
					<select id="searchRadius" style="width: 100%; padding: 8px; border: 2px solid #42a5f5; border-radius: 4px; background: white; color: #1565c0;">
						<option value="0.1"  selected>100 公尺</option>
						<option value="0.2">200 公尺</option>
						<option value="0.5">500 公尺</option>
						<option value="0.75">750 公尺</option>
						<option value="1">1 公里</option>
						<option value="2">2 公里</option>
						<option value="5">5 公里</option>
						<option value="10">10 公里</option>
					</select>
				</div>
				
				<div style="display: grid; grid-template-columns: 1fr; gap: 8px;">
					<button onclick="searchNearbyFromLocation()" 
							style="padding: 12px 20px; background: linear-gradient(135deg, #2196f3, #1976d2); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);"
							onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 12px rgba(33, 150, 243, 0.4)';"
							onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 8px rgba(33, 150, 243, 0.3)';">
						📍 搜尋我的位置附近
					</button>
					<button onclick="enableMapClickForSearch()" 
							style="padding: 12px 20px; background: linear-gradient(135deg, #ff9800, #f57c00); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(255, 152, 0, 0.3);"
							onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 12px rgba(255, 152, 0, 0.4)';"
							onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 8px rgba(255, 152, 0, 0.3)';">
						🗺️ 點選地圖搜尋
					</button>
					<button onclick="showNearbyDevicesOnly()" 
							style="padding: 12px 20px; background: linear-gradient(135deg, #4caf50, #388e3c); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);"
							onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 12px rgba(76, 175, 80, 0.4)';"
							onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 8px rgba(76, 175, 80, 0.3)';">
						📍 直接顯示附近設備
					</button>
				</div>
    
    <!-- 🆕 新增控制選項 -->
			<div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.7); border-radius: 6px;">
				<label style="display: flex; align-items: center; font-size: 12px; color: #1565c0; cursor: pointer;">
					<input type="checkbox" id="showSearchCircle" checked style="margin-right: 8px;">
					顯示搜尋範圍圓圈
				</label>
				<label style="display: flex; align-items: center; font-size: 12px; color: #1565c0; cursor: pointer; margin-top: 5px;">
					<input type="checkbox" id="autoLoadFeeder" style="margin-right: 8px;">
					自動載入最近的饋線
				</label>
				<label style="display: flex; align-items: center; font-size: 12px; color: #1565c0; cursor: pointer; margin-top: 5px;">
					<input type="checkbox" id="showDevicesOnly" style="margin-right: 8px;">
					只顯示設備標記（不顯示側邊欄）
				</label>
			</div>
			
			<!-- 🆕 在搜尋區域底部加入清除按鈕 -->
			<div style="margin-top: 10px;">
				<button onclick="clearSearchResults()" 
						style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
					🧹 清除搜尋結果
				</button>
			</div>
</div>

			<!-- 新增：圖號座標輸入區域 -->
			<div class="coordinate-input-section">
				<h3>🗺️ 圖號座標查詢</h3>
				<input type="text" 
					   id="coordinateInput" 
					   class="coordinate-input" 
					   placeholder="輸入圖號座標 (如: Q1520CB20)"
					   maxlength="15">
				<button class="coordinate-btn" onclick="searchByCoordinate()">
					🔍 座標定位
				</button>
				<div style="font-size: 12px; color: #856404; margin-top: 8px; text-align: center;">
					支援台電圖號座標格式
				</div>
			</div>
				<!-- 檔案上傳區域 -->
				<div class="file-upload-section">
					<h3>📁 載入配電系統檔案</h3>
					<div class="file-input-wrapper">
						<input type="file" id="fileInput" accept=".json" />
						<button class="file-input-button" onclick="document.getElementById('fileInput').click()">
							📂 選擇 JSON 檔案
						</button>
					</div>
					<div class="file-info">
						支援台電配電系統 GeoNode 格式（點與線段）
					</div>
				</div>
				
				<!-- 饋線資訊 -->
				<div id="feederInfo" class="feeder-info" style="display: none;">
					<h4>📊 饋線資訊</h4>
					<p id="feederDetails">等待載入...</p>
				</div>
				
				<!-- 載入狀態 -->
				<div class="status-section">
					<h3>📊 載入狀態</h3>
					<div id="loadStatus">請選擇 JSON 檔案開始載入...</div>
				</div>
				

				
				<!-- 圖層控制 -->
				<div class="layer-controls">
					<h3>🎛️ 圖層控制</h3>
					<div id="layerControlsContainer">
						<p style="color: #666; font-size: 14px; text-align: center; padding: 20px;">
							載入檔案後將顯示圖層控制選項
						</p>
					</div>
				</div>
				<!-- 新增：快捷鍵說明 - 加在這裡 -->

				<!-- 載入中指示器 -->
				<div class="loading" id="loadingIndicator">
					<div>⏳ 正在處理檔案...</div>
				</div>
				
				<!-- 圖例 -->
				<div class="legend">
					<h4 style="margin: 10px 0 5px 0;">🔌 線路圖例</h4>
					<div class="legend-item">
						<div class="legend-line" style="background: #dc3545; color: #dc3545;"></div>
						<span>22.8kV 主幹線 (架空)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #dc3545;"></div>
						<span>22.8kV 主幹線 (地下)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line" style="background: #007bff; color: #007bff;"></div>
						<span>22.8kV 分歧線 (架空)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #007bff;"></div>
						<span>22.8kV 分歧線 (地下)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line" style="background: #fd7e14; color: #fd7e14;"></div>
						<span>11.4kV 主幹線 (架空)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #fd7e14;"></div>
						<span>11.4kV 主幹線 (地下)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line" style="background: #28a745; color: #28a745;"></div>
						<span>11.4kV 分歧線 (架空)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #28a745;"></div>
						<span>11.4kV 分歧線 (地下)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line" style="background: #6c757d; color: #6c757d;"></div>
						<span>其他線路 (架空)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #6c757d;"></div>
						<span>其他線路 (地下)</span>
					</div>
					<hr style="margin: 8px 0;">
				</div>
				
				<!-- 線段高亮控制 -->
				<div class="highlight-controls" style="display: none;" id="highlightControls">
					<h4 style="margin: 0 0 8px 0; font-size: 14px; color: #856404;">🎯 線段高亮</h4>
					<p style="margin: 0 0 8px 0; font-size: 12px; color: #856404;">點選地圖上的線段進行高亮顯示</p>
					<button class="reset-highlight-btn" onclick="resetLineHighlight()">
						🔄 重置高亮
					</button>
				</div>
			</div>
			
			<div class="map-container">
				<div id="map"></div>
				<!-- 🆕 在這裡加入：可收合圖層切換器 -->
				<div class="layer-switcher-compact" id="layerSwitcherCompact">
					<button class="layer-toggle-btn" onclick="toggleLayerMenu()">
						🗺️ 圖層
					</button>
					
					<div class="layer-menu" id="layerMenu" style="display: none;">
						<div class="layer-group">
							<h5>🗺️ 基礎圖層</h5>
							<div class="layer-option">
								<input type="radio" id="googleStreets" name="baseLayer" value="googleStreets" checked>
								<label for="googleStreets">Google 街景圖</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="googleSatellite" name="baseLayer" value="googleSatellite">
								<label for="googleSatellite">Google 衛星影像</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="googleHybrid" name="baseLayer" value="googleHybrid">
								<label for="googleHybrid">Google 混合圖</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="openStreetMap" name="baseLayer" value="openStreetMap">
								<label for="openStreetMap">OpenStreetMap</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="esriWorldImagery" name="baseLayer" value="esriWorldImagery">
								<label for="esriWorldImagery">Esri 衛星圖</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="nlscMap" name="baseLayer" value="nlscMap">
								<label for="nlscMap">國土測繪電子地圖</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="nlscContour" name="baseLayer" value="nlscContour">
								<label for="nlscContour">國土測繪地圖(含等高線)</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="nlscPhoto" name="baseLayer" value="nlscPhoto">
								<label for="nlscPhoto">國土測繪正射影像</label>
							</div>
						</div>
						
						<div class="layer-group">
							<h5>🏛️ 政府圖層</h5>
							<div class="layer-option">
								<input type="checkbox" id="roadNetworkLayer" onchange="toggleOverlayLayer('roadNetwork')">
								<label for="roadNetworkLayer">路網圖層</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="railwayLayer" onchange="toggleOverlayLayer('railway')">
								<label for="railwayLayer">鐵路圖層</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="publicLandLayer" onchange="toggleOverlayLayer('landmark')">
								<label for="publicLandLayer">公有土地圖</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="adminBoundaryLayer" onchange="toggleOverlayLayer('cadastre')">
								<label for="adminBoundaryLayer">行政區界圖</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="landParcelLayer" onchange="toggleOverlayLayer('section')">
								<label for="landParcelLayer">段籍圖</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="villageLayer" onchange="toggleOverlayLayer('village')">
								<label for="villageLayer">村里界圖</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="roadMilestoneLayer" onchange="toggleOverlayLayer('wayMeter')">
								<label for="roadMilestoneLayer">公路里程標誌</label>
							</div>
						</div>
						
						<div class="layer-group">
							<h5>🏔️ 高雄市專用圖層</h5>
							<div class="layer-option">
								<input type="checkbox" id="kaohsiungSlopeLayer" onchange="toggleOverlayLayer('kaohsiungSlope')">
								<label for="kaohsiungSlopeLayer">高雄山坡地範圍</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="urbanPlanLayer" onchange="toggleOverlayLayer('urbanPlan')">
								<label for="urbanPlanLayer">高雄市都市計畫圖</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="urbanPlanBoundaryLayer" onchange="toggleOverlayLayer('urbanPlanBoundary')">
								<label for="urbanPlanBoundaryLayer">高雄市都市計畫範圍圖</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="nationalLandPlanLayer" onchange="toggleOverlayLayer('trafficNetwork')">
								<label for="nationalLandPlanLayer">國土計畫圖</label>
							</div>
						</div>
						
						<div class="layer-group">
							<h5>🎛️ 圖層控制</h5>
							<div class="layer-opacity-control">
								<span>透明度:</span>
								<input type="range" class="opacity-slider" id="layerOpacity" 
									   min="0" max="100" value="100" onchange="adjustLayerOpacity(this.value)">
								<span id="opacityValue">100%</span>
							</div>
						</div>
					</div>
				</div>
				
				<!-- 原有的控制按鈕繼續保留在下面 -->
				<button class="fullscreen-btn" onclick="toggleFullscreen()">
					🔲 全螢幕
				</button>
				


				
				
				<!-- 修改：定位控制按鈕 -->
				<div class="location-controls">
					<button id="locateBtn" class="location-btn" onclick="toggleContinuousLocation()">
						📍 定位
					</button>
					 <button class="rotation-btn" id="followLocationBtn" onclick="toggleFollowLocation()">
						📱 跟隨位置
					</button>

				</div>

				<!-- 簡化：旋轉控制 - 只保留跟隨方向 -->

								
				<!-- 新增：測量工具 -->
				<div class="measure-controls">
					<button class="measure-btn" id="measureDistanceBtn" onclick="toggleMeasureDistance()">
						📏 測距
					</button>
					<button class="measure-btn" onclick="clearMeasurements()">
						🗑️ 清除
					</button>
				</div>
				

				
				
			</div>
		</div>
		

		
		<script>
			// 全域變數
			let map;
			let allDevicesData = [];
			let allLinesData = [];
			let layerGroups = {};
			let layerCounts = {};
			let currentFeederInfo = null;
			let selectedLine = null; // 儲存當前選中的線段
			// 🔧 新增：箭頭管理
			let allArrowMarkers = []; // 儲存所有箭頭標記
			let arrowLayerGroup = null; // 箭頭圖層群組
			// 地圖初始化
			// 地圖初始化 - 修改版
			// 🌟 新增：星星管理
			let oppositeStarMarkers = []; // 儲存所有星星標記
			let oppositeLayerGroup = null; // 星星圖層群組
			
			// 🆕 全域變數儲存饋線資料
			let feederDataMap = {};
			let feederList = [];
			// 🆕 饋線清單 - 根據您提供的檔案名稱
			// 🆕 超高速載入相關全域變數
			let feederCache = null;
			let fastJsonLoader = null;
			let localStorageManager = null;
			// 新增：定位功能相關變數
			let isContinuousLocationEnabled = false;
			let userLocationMarker;
			let watchId;
			
			// 🆕 停電資料相關變數
			let outageData = null;
			let outageMarkers = [];
			let faultLineMarkers = [];
			
			// 災情查報相關變數
			let disasterData = [];
			let disasterMarkers = [];
			let currentPhotoIndex = 0;
			let currentReportId = null;
			let currentReportPhotos = [];
			// 🆕 修改地圖初始化函數
			// 🔧 修正版：地圖初始化 - 確保所有組件完全載入後再啟用手機導航
async function initMap() {
  console.log('🗺️ 初始化地圖...');
     // 🔧 重要：初始化 Supabase
    const supabaseReady = initSupabase();
    if (!supabaseReady) {
        console.warn('⚠️ Supabase 未正確初始化，鄰近搜尋功能將無法使用');
        showToast('⚠️ 資料庫連接失敗，鄰近搜尋功能無法使用', 'warning');
    } else {
        console.log('✅ Supabase 已成功初始化，鄰近搜尋功能可用');
        showToast('✅ 資料庫連接成功，鄰近搜尋功能已啟用', 'success');
    }
  // 初始化超高速載入組件
  feederCache = new FeederCache();
  fastJsonLoader = new FastJsonLoader();
  localStorageManager = new LocalStorageManager();
  
  // 建立地圖實例，預設中心點設在高雄
  map = L.map('map', {
      center: [22.67, 120.34],
      zoom: 12,
      maxZoom: 22,
      rotate: true,
      rotateControl: {
          closeOnZeroBearing: false
      },
      bearing: 0,
      zoomControl: false
  });
  
  // 綁定地圖事件（保持原有邏輯）
  bindMapEvents();
  
  // 定義座標系統
  setupCoordinateSystems();
  
  // 建立地圖圖層
  setupMapLayers();
  
  // 初始化箭頭和星星圖層群組
  arrowLayerGroup = L.layerGroup().addTo(map);
  oppositeLayerGroup = L.layerGroup().addTo(map);
  
  // 初始化測量工具
  initializeMeasureTools();
  
  // 初始化圖層切換事件
  initializeLayerSwitcher();
  
  // 載入饋線資料
  await loadFeederDataFromSheet();
  
  // 建立進度條
  createProgressBar();
  
  // 🔧 重要修正：確保所有控制項完全初始化後再啟用手機導航
  // 延遲一點時間確保所有事件處理器都已綁定
  setTimeout(() => {
      initMobileNavigation();
      console.log('📱 手機版導航延遲初始化完成');
  }, 500);
  
  // 🔧 修正：停電資料改為背景載入，不阻塞主要功能
  loadOutageDataInBackground();
  
  updateLoadStatus('地圖初始化完成，請選擇 JSON 檔案或從雲端載入...');
  // 載入災情資料
	setTimeout(() => {
		loadDisasterData();
	}, 2000);
  
  console.log('✅ 地圖初始化完成');
}

		// 🔧 新增：檢測並隱藏手機版全螢幕按鈕
		function handleFullscreenButtonVisibility() {
			const fullscreenBtn = document.querySelector('.fullscreen-btn');
			
			if (fullscreenBtn) {
				// 檢測是否為手機裝置
				const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
				const isSmallScreen = window.innerWidth <= 768;
				
				if (isMobile || isSmallScreen) {
					fullscreenBtn.style.display = 'none';
					console.log('📱 手機模式：已隱藏全螢幕按鈕');
				} else {
					fullscreenBtn.style.display = 'block';
					console.log('🖥️ 桌面模式：顯示全螢幕按鈕');
				}
			}
		}
	// 🆕 背景載入停電資料
	async function loadOutageDataInBackground() {
	  try {
		  console.log('🔄 開始背景載入停電資料...');
		  
		  // 更新狀態顯示
		  const outageStatus = document.getElementById('outageStatus');
		  if (outageStatus) {
			  outageStatus.textContent = '🔄 背景載入停電資料中...';
			  outageStatus.style.background = '#fff3cd';
		  }
		  
		  // 非同步載入停電資料
		  await loadOutageData();
		  
		  console.log('✅ 停電資料背景載入完成');
		  
	  } catch (error) {
		  console.error('❌ 停電資料背景載入失敗:', error);
		  
		  const outageStatus = document.getElementById('outageStatus');
		  if (outageStatus) {
			  outageStatus.textContent = '⚠️ 停電資料載入失敗，但不影響其他功能使用';
			  outageStatus.style.background = '#f8d7da';
		  }
	  }
	}


// 🔧 輔助函數：設定座標系統
function setupCoordinateSystems() {
  proj4.defs([
      ['EPSG:3826', '+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'],
      ['EPSG:3828', '+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=aust_SA +towgs84=-752,-358,-179,-.0000011698,.0000018398,.0000009822,.00002329 +units=m +no_defs'],
      ['EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs']
  ]);
}

// 🔧 輔助函數：設定地圖圖層
function setupMapLayers() {
  // 建立多種地圖圖層
  window.mapLayers = {
// Google 系列
					googleStreets: L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
						maxZoom: 22,
						subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
						attribution: '© Google Maps'
					}),
					
					googleSatellite: L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
						maxZoom: 22,
						subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
						attribution: '© Google Satellite'
					}),
					
					googleHybrid: L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
						maxZoom: 22,
						subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
						attribution: '© Google Hybrid'
					}),
					
					// OpenStreetMap
					openStreetMap: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
						attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
						maxZoom: 22
					}),
					
					// Esri 衛星圖
					esriWorldImagery: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
						attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
						maxZoom: 22
					}),

					// 🆕 國土測繪中心圖層
					nlscMap: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/EMAP/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: '© 內政部國土測繪中心'
					}),

					nlscContour: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/EMAP2/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: '© 內政部國土測繪中心'
					}),

					nlscPhoto: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/PHOTO2/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: '© 內政部國土測繪中心'
					})
  };
  
  // 建立疊加圖層
  window.overlayLayers = {
      // ✅ 路網圖層 (已正常運作)
					roadNetwork: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/ROAD/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 19,
						attribution: '© 內政部國土測繪中心'
					}),
					
					// ✅ 鐵路圖層 (已正常運作)
					railway: L.tileLayer('https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png', {
						maxZoom: 30,
						subdomains: ['a', 'b', 'c'],
						attribution: 'Map data: &copy; OpenStreetMap contributors | Style: &copy; OpenRailwayMap'
					}),
					
					// 🔧 修正：公有土地圖 - 使用正確的 WMTS URL
					landmark: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/LAND_OPENDATA/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: '© 內政部國土測繪中心'
					}),
					
					// 🔧 修正：行政區界圖 - 使用正確的 WMTS URL
					cadastre: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/TOWN/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: '© 內政部國土測繪中心'
					}),
					
					// 🔧 修正：段籍圖 - 使用正確的 WMTS URL
					section: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/LANDSECT/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: '© 內政部國土測繪中心'
					}),
					
					// ✅ 村里界圖 (已正常運作)
					village: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/Village/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: '© 內政部國土測繪中心'
					}),
					
					// 🔧 修正：公路里程標誌 - 使用正確的 WMTS URL
					wayMeter:L.tileLayer('https://wmts.nlsc.gov.tw/wmts/WAYMETER/default/GoogleMapsCompatible/{z}/{y}/{x}', {
					  maxZoom: 30,
					  attribution: 'Map data: &copy; OpenStreetMap contributors | Style: &copy; OpenRailwayMap'
				    }),
					
					// ✅ 其他圖層保持不變
					kaohsiungSlope: L.tileLayer.wms('https://swc.kcg.gov.tw/geoserver/KaoHill/ows', {
						layers: 'HillRange',
						format: 'image/png',
						transparent: true,
						version: '1.3.0',
						attribution: '© 高雄市水土保持局'
					}),
					
					urbanPlan: L.tileLayer.wms('https://urbanproxy.kcg.gov.tw/arcgis/services/UrbanAPI/KcgUrbanDataForUrbanAPI/MapServer/WmsServer', {
						layers: '高雄市都市計畫圖',
						format: 'image/png',
						transparent: true,
						version: '1.3.0',
						attribution: '© 高雄市政府',
						crs: L.CRS.EPSG4326,
						bounds: L.latLngBounds([22.474447, 120.174156], [23.086414, 120.653181])
					}),
					
					urbanPlanBoundary: L.tileLayer.wms('https://urbanproxy.kcg.gov.tw/arcgis/services/UrbanAPI/KcgUrbanDataForPlanAPI/MapServer/WmsServer', {
						layers: '高雄市都市計畫範圍圖',
						format: 'image/png',
						transparent: true,
						version: '1.3.0',
						attribution: '© 高雄市政府'
					}),
					
					trafficNetwork: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/LUIMAP/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 19,
						attribution: '© 內政部國土測繪中心'
					})
  };
  
  // 預設載入 Google 街景圖
  window.currentBaseLayer = window.mapLayers.googleStreets.addTo(map);
}

// 在地圖初始化完成後執行
handleFullscreenButtonVisibility();

// 監聽視窗大小變化
window.addEventListener('resize', handleFullscreenButtonVisibility);

			
			// 新增：台灣地區電力座標原點
const taiGridArr = [
    {taiCode: 'A', taiGrid: [170000, 2750000]},
    {taiCode: 'B', taiGrid: [250000, 2750000]},
    {taiCode: 'C', taiGrid: [330000, 2750000]},
    {taiCode: 'D', taiGrid: [170000, 2700000]},
    {taiCode: 'E', taiGrid: [250000, 2700000]},
    {taiCode: 'F', taiGrid: [330000, 2700000]},
    {taiCode: 'G', taiGrid: [170000, 2650000]},
    {taiCode: 'H', taiGrid: [250000, 2650000]},
    {taiCode: 'J', taiGrid: [90000, 2600000]},
    {taiCode: 'K', taiGrid: [170000, 2600000]},
    {taiCode: 'L', taiGrid: [250000, 2600000]},
    {taiCode: 'M', taiGrid: [90000, 2550000]},
    {taiCode: 'N', taiGrid: [170000, 2550000]},
    {taiCode: 'O', taiGrid: [250000, 2550000]},
    {taiCode: 'P', taiGrid: [90000, 2500000]},
    {taiCode: 'Q', taiGrid: [170000, 2500000]},
    {taiCode: 'R', taiGrid: [250000, 2500000]},
    {taiCode: 'T', taiGrid: [170000, 2450000]},
    {taiCode: 'U', taiGrid: [250000, 2450000]},
    {taiCode: 'V', taiGrid: [170000, 2400000]},
    {taiCode: 'W', taiGrid: [250000, 2400000]},
    {taiCode: 'X', taiGrid: [275000, 2614000]},
    {taiCode: 'Y', taiGrid: [275000, 2564000]}
];

// 新增：定位功能
// 🔧 修正版：跟隨裝置位置功能
function toggleContinuousLocation() {
    if (!isContinuousLocationEnabled) {
        enableContinuousLocation();
    } else {
        disableContinuousLocation();
    }
}

// 🔧 輔助函數：綁定地圖事件
function bindMapEvents() {
  // 地圖縮放時自動調整控制面板
  map.on('zoomend', function() {
      const zoom = map.getZoom();
      const controls = document.querySelectorAll('.rotation-controls, .layer-switcher');
      
      controls.forEach(control => {
          if (zoom < 10) {
              control.style.opacity = '0.7';
          } else {
              control.style.opacity = '1';
          }
      });
  });
  
  // 地圖移動時更新 URL
  let urlUpdateTimeout;
  map.on('moveend', function() {
      clearTimeout(urlUpdateTimeout);
      urlUpdateTimeout = setTimeout(() => {
          const center = map.getCenter();
          const zoom = map.getZoom();
          const bearing = 0;
          
          const newUrl = `${window.location.pathname}#${zoom}/${center.lat.toFixed(6)}/${center.lng.toFixed(6)}/${bearing}`;
          window.history.replaceState(null, null, newUrl);
      }, 1000);
  });
  
  // 右鍵選單功能
  map.on('contextmenu', function(e) {
      const lat = e.latlng.lat;
      const lng = e.latlng.lng;
      
      const contextMenu = L.popup({
          closeButton: false,
          autoClose: true,
          closeOnEscapeKey: true
      })
      .setLatLng(e.latlng)
      .setContent(`
          <div style="text-align: center; min-width: 150px;">
              <h4 style="margin: 0 0 10px 0;">📍 位置操作</h4>
              <button onclick="copyCoordinates(${lat}, ${lng}); map.closePopup();" 
                      style="width: 100%; margin: 2px 0; padding: 5px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">
                  📋 複製座標
              </button>
              <button onclick="openStreetView(${lat}, ${lng}); map.closePopup();" 
                      style="width: 100%; margin: 2px 0; padding: 5px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">
                  🗺️ 街景圖
              </button>
              <button onclick="openNavigation(${lat}, ${lng}, '選定位置'); map.closePopup();" 
                      style="width: 100%; margin: 2px 0; padding: 5px; background: #ffc107; color: black; border: none; border-radius: 3px; cursor: pointer;">
                  🧭 導航至此
              </button>
          </div>
      `)
      .openOn(map);
  });
  
  // 地圖點選事件
  map.on('click', function(e) {
      resetLineHighlight();
      const layerMenu = document.getElementById('layerMenu');
      if (layerMenu) {
          layerMenu.style.display = 'none';
      }
  });
}
// 🔧 輔助函數：設定座標系統
function setupCoordinateSystems() {
  proj4.defs([
      ['EPSG:3826', '+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'],
      ['EPSG:3828', '+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=aust_SA +towgs84=-752,-358,-179,-.0000011698,.0000018398,.0000009822,.00002329 +units=m +no_defs'],
      ['EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs']
  ]);
}

// 🔧 修正：加入距離閾值防止抖動
let lastPosition = null;
const POSITION_THRESHOLD = 5; // 5公尺閾值
// 🔧 修正版：跟隨裝置位置功能
let userHasDraggedMap = false; // 🆕 追蹤用戶是否拖曳過地圖
let initialLocationSet = false; // 🆕 追蹤是否已設定初始位置
// 🔧 修正版：平滑跟隨定位地點
function enableContinuousLocation() {
    if (navigator.geolocation) {
        isContinuousLocationEnabled = true;
        userHasDraggedMap = false;
        initialLocationSet = false;
        
        // 🔧 修正：正確更新按鈕狀態
        const btn = document.getElementById('locateBtn');
        if (btn) {
            btn.classList.add('active');
            btn.textContent = '⏹️ 停止定位';
            btn.style.backgroundColor = '#dc3545'; // 紅色表示啟用狀態
            btn.style.color = 'white';
        }

        // 監聽地圖拖曳事件
        map.on('dragstart', function() {
            userHasDraggedMap = true;
            console.log('🖱️ 用戶開始拖曳地圖');
        });

        watchId = navigator.geolocation.watchPosition(function (position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const currentPosition = L.latLng(lat, lng);

            if (lastPosition && lastPosition.distanceTo(currentPosition) < Math.max(10, accuracy/2)) {
                return;
            }

            lastPosition = currentPosition;

            // 更新或創建位置標記
            if (!userLocationMarker) {
                const locationIcon = L.divIcon({
                    html: '<div class="location-marker"><div class="center-dot"></div></div>',
                    className: 'custom-location-icon',
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                userLocationMarker = L.marker([lat, lng], {
                    icon: locationIcon
                }).addTo(map);
            } else {
                userLocationMarker.setLatLng([lat, lng]);
            }

            // 地圖移動邏輯
            if (!initialLocationSet) {
                map.flyTo([lat, lng], Math.max(map.getZoom(), 16), {
                    duration: 2.0,
                    easeLinearity: 0.1
                });
                initialLocationSet = true;
                console.log('📍 初次定位完成');
            } else if (!userHasDraggedMap) {
                const currentCenter = map.getCenter();
                const distanceFromCenter = currentCenter.distanceTo(currentPosition);
                
                if (distanceFromCenter > 200) {
                    map.flyTo([lat, lng], map.getZoom(), {
                        duration: 1.5,
                        easeLinearity: 0.1
                    });
                }
            }

        }, function (error) {
            console.error('定位錯誤:', error);
            showToast('❌ 無法獲取您的位置', 'error');
            disableContinuousLocation();
        }, {
            enableHighAccuracy: true,
            maximumAge: 10000,
            timeout: 20000
        });
        
        console.log('📍 開始跟隨裝置位置');
    } else {
        showToast('❌ 您的裝置不支援定位功能', 'error');
    }
}



// 🔧 修正版：停用連續定位
// 🔧 修正版：停用連續定位
function disableContinuousLocation() {
    if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
    }
    
    isContinuousLocationEnabled = false;
    userHasDraggedMap = false;
    initialLocationSet = false;
    
    // 移除地圖拖曳監聽
    map.off('dragstart');
    
    // 🔧 修正：正確重置按鈕狀態
    const btn = document.getElementById('locateBtn');
    if (btn) {
        btn.classList.remove('active');
        btn.textContent = '📍 跟隨裝置';
        btn.style.backgroundColor = ''; // 重置背景色
        btn.style.color = ''; // 重置文字色
    }
    
    console.log('⏹️ 已停止跟隨裝置位置');
}

// 新增：圖號座標轉換功能
function searchByCoordinate() {
    const input = document.getElementById('coordinateInput');
    const coordinate = input.value.trim().toUpperCase();
    
    if (!coordinate) {
        showToast('請輸入圖號座標！', 'error');
        return;
    }
    
    try {
        const result = convertPowerCoordinate(coordinate);
        const [lng, lat] = result.split(',').map(Number);
        
        // 在地圖上標記位置
        const marker = L.marker([lat, lng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        const popupContent = `
            <div style="text-align: center;">
                <h4>📍 圖號座標定位</h4>
                <p><strong>座標:</strong> ${coordinate}</p>
                <p><strong>經緯度:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                <button onclick="openStreetView(${lat}, ${lng})" 
                        style="margin: 5px; padding: 5px 10px; background: #4285f4; color: white; border: none; border-radius: 3px; cursor: pointer;">
                    🗺️ 街景圖
                </button>
                <button onclick="copyCoordinates(${lat}, ${lng})" 
                        style="margin: 5px; padding: 5px 10px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">
                    📋 複製座標
                </button>
            </div>
        `;
        
        marker.bindPopup(popupContent).openPopup();
        
        // 移動地圖到該位置
        map.flyTo([lat, lng], 18, {
            duration: 1.0
        });
        
        showToast(`✅ 座標定位成功: ${coordinate}`, 'success');
        
    } catch (error) {
        console.error('座標轉換錯誤:', error);
        showToast(`❌ 座標轉換失敗: ${error.message}`, 'error');
    }
}

// 新增：電力座標轉換函數
function convertPowerCoordinate(powerCoord, lonOffset = -0.00002, latOffset = -0.00001) {
    powerCoord = powerCoord.toUpperCase();
    
    // 驗證格式
    if (!/^[A-HJ-Z]\d{4}[A-H][A-E]\d{2,4}$/.test(powerCoord)) {
        throw new Error('無效的電力座標格式');
    }

    try {
        // 解析電力座標
        const zone = powerCoord.charAt(0);
        const block = powerCoord.substring(1, 5);
        const subBlock = powerCoord.substring(5, 7);
        const detail = powerCoord.substring(7, 11);

        // 計算相對位移
        const offsetX = calculateOffset(block, subBlock, detail, true);
        const offsetY = calculateOffset(block, subBlock, detail, false);

        // 查找對應的原點座標
        const taiXY = taiGridArr.find(e => e.taiCode === zone);
        if (!taiXY) {
            throw new Error('無效的分區代碼');
        }

        // 計算TWD67座標
        const twd67X = parseFloat((taiXY.taiGrid[0] + offsetX).toFixed(6));
        const twd67Y = parseFloat((taiXY.taiGrid[1] + offsetY).toFixed(6));

        // 轉換為WGS84
        let wgs84 = proj4('EPSG:3828', 'WGS84', [twd67X, twd67Y]);
        wgs84[0] = parseFloat((wgs84[0] + lonOffset).toFixed(10));
        wgs84[1] = parseFloat((wgs84[1] + latOffset).toFixed(10));
        
        return `${wgs84[0]},${wgs84[1]}`;

    } catch (error) {
        throw new Error('轉換過程發生錯誤: ' + error.message);
    }
}

function calculateOffset(block, subBlock, detail, isX) {
    let offset = 0;
    if (isX) {
        offset += parseInt(block.substring(0, 2)) * 800;
        offset += (subBlock.charCodeAt(0) - 65) * 100;
        if (detail.length === 2) {
            offset += parseInt(detail.substring(0, 1)) * 10;
        } else if (detail.length === 4) {
            offset += parseInt(detail.substring(2, 3)) * 1;
        }
    } else {
        offset += parseInt(block.substring(2, 4)) * 500;
        offset += (subBlock.charCodeAt(1) - 65) * 100;
        if (detail.length === 2) {
            offset += parseInt(detail.substring(1, 2)) * 10;
        } else if (detail.length === 4) {
            offset += parseInt(detail.substring(3, 4)) * 1;
        }
    }
    return offset;
}
			
			// 重置線段高亮 - 修改版
			function resetLineHighlight() {
				if (selectedLine) {
					selectedLine.setStyle(selectedLine.originalStyle);
					
					// 🔧 效能優化：批量重置箭頭顏色
					if (selectedLine.arrowMarkers && selectedLine.arrowMarkers.length > 0) {
						selectedLine.arrowMarkers.forEach(marker => {
							updateArrowColor(marker, selectedLine.originalStyle.color);
						});
					}
					
					selectedLine = null;
					console.log('🔄 已重置線段高亮');
				}
			}
			
			// 更新載入狀態
			function updateLoadStatus(message) {
				const statusElement = document.getElementById('loadStatus');
				statusElement.textContent = message;
				console.log('📊', message);
			}
			
		// 🔧 修正：使用命名函數以便重新綁定
		document.getElementById('fileInput').addEventListener('change', handleFileInput);
			
		// 處理 JSON 資料 - 修正版（針對台電格式）
	function processJsonData(data, fileName) {
		console.log('📁 開始處理檔案:', fileName);
		console.log('📊 原始資料結構:', data);
		
		// 清除舊資料
		clearAllLayers();
		allDevicesData = [];
		allLinesData = [];
		layerGroups = {};
		layerCounts = {};
		currentFeederInfo = null;
		selectedLine = null; // 重置選中線段
		
		let processedPointCount = 0;
		let processedLineCount = 0;
		let totalNodes = 0;
		let totalLinks = 0;
		
		// 🔧 修正版：處理裝置方向事件 - 修正角度反轉問題
		let lastHeading = null;
		const HEADING_THRESHOLD = 0.3; // 增加方向變化閾值
		let orientationSupported = false;
		let permissionGranted = false;
		
		// 處理台電配電系統的 GeoNode 和 GeoLink 格式
		if (data.GeoNode && Array.isArray(data.GeoNode)) {
			console.log('✅ 識別為台電配電系統格式');
			
			const geoNodes = data.GeoNode;
			const geoLinks = data.GeoLink || [];
			
			totalNodes = geoNodes.length;
			totalLinks = geoLinks.length;
			
			updateLoadStatus(`找到 ${totalNodes} 個設備節點, ${totalLinks} 條連接線段，開始處理...`);
			
			// 提取饋線資訊
			if (geoNodes.length > 0) {
				extractFeederInfo(geoNodes[0], fileName);
			}
			
			// 🔧 重要修正：先處理所有點設備 (GeoNode) - 確保 allDevicesData 完整
			console.log('🔄 第一階段：處理所有點設備...');
			geoNodes.forEach((node, index) => {
				try {
					const processedNode = processGeoNode(node, index);
					if (processedNode) {
						allDevicesData.push(processedNode);
						processedPointCount++;
					}
				} catch (error) {
					console.warn(`⚠️ GeoNode ${index} 處理失敗:`, error, node);
				}
			});
			
			console.log(`✅ 第一階段完成：處理了 ${processedPointCount} 個點設備`);
			console.log(`📊 allDevicesData 現在包含 ${allDevicesData.length} 個設備`);
			
			// 🔧 重要修正：再處理線段 (GeoLink) - 此時可以查找節點資料
			console.log('🔄 第二階段：處理所有線段...');
			geoLinks.forEach((link, index) => {
				try {
					const processedLine = processGeoLink(link, index);
					if (processedLine) {
						allLinesData.push(processedLine);
						processedLineCount++;
					}
				} catch (error) {
					console.warn(`⚠️ GeoLink ${index} 處理失敗:`, error, link);
				}
			});
			
			console.log(`✅ 第二階段完成：處理了 ${processedLineCount} 條線段`);
			
		} else {
			// 處理其他格式（保持原有邏輯）
			let features = [];
			
			if (Array.isArray(data)) {
				features = data;
				console.log('✅ 識別為 Features 陣列格式');
			} else if (data.type === 'FeatureCollection' && data.features) {
				features = data.features;
				console.log('✅ 識別為 GeoJSON FeatureCollection');
			} else if (data.features && Array.isArray(data.features)) {
				features = data.features;
				console.log('✅ 識別為包含 features 的格式');
			} else {
				console.error('❌ 不支援的資料格式，資料結構:', Object.keys(data));
				updateLoadStatus('❌ 不支援的資料格式，請檢查檔案結構');
				return;
			}
			
			totalNodes = features.length;
			updateLoadStatus(`找到 ${totalNodes} 個 Feature，開始處理...`);
			
			// 提取饋線資訊
			if (features.length > 0) {
				extractFeederInfo(features[0], fileName);
			}
			
			// 處理每個 Feature
			features.forEach((feature, index) => {
				try {
					if (!feature.type || feature.type !== 'Feature') {
						console.warn(`Feature ${index} 格式無效:`, feature);
						return;
					}
					
					if (!feature.geometry || !feature.geometry.type) {
						console.warn(`Feature ${index} 缺少 geometry:`, feature);
						return;
					}
					
					const geometryType = feature.geometry.type;
					
					if (geometryType === 'Point') {
						const processedNode = processPointFeature(feature, index);
						if (processedNode) {
							allDevicesData.push(processedNode);
							processedPointCount++;
						}
					} else if (geometryType === 'LineString') {
						const processedLine = processLineFeature(feature, index);
						if (processedLine) {
							allLinesData.push(processedLine);
							processedLineCount++;
						}
					}
				} catch (error) {
					console.warn(`⚠️ Feature ${index} 處理失敗:`, error, feature);
				}
			});
		}
		
		console.log(`✅ 成功處理 ${processedPointCount} 個點設備, ${processedLineCount} 條線段`);
		updateLoadStatus(`✅ 成功載入 ${processedPointCount} 個設備, ${processedLineCount} 條線段`);
		
		// 建立圖層控制
		createLayerControls();
		
		// 自動縮放到資料範圍
		if (processedPointCount > 0 || processedLineCount > 0) {
			fitMapToData();
		}
		
		// 顯示饋線資訊
		displayFeederInfo();
		
		// 顯示高亮控制
		if (processedLineCount > 0) {
			document.getElementById('highlightControls').style.display = 'block';
		}
	}

	// 處理台電 GeoLink - 完全修正版（修正屬性位置）
	function processGeoLink(link, index) {
		console.log(`🔍 處理 GeoLink ${index}:`, link);
		
		if (!link.type || link.type !== 'Feature') {
			console.warn(`GeoLink ${index} 不是有效的 Feature:`, link);
			return null;
		}
		
		const geometry = link.geometry;
		if (!geometry || geometry.type !== 'LineString') {
			console.warn(`GeoLink ${index} 不是線段幾何:`, link);
			return null;
		}
		
		// 🔧 重要修正：GeoLink 的屬性也在 geometry.properties 內部（和 GeoNode 一樣）
		let properties = {};
		
		// 優先順序：geometry.properties > link.properties > 空物件
		if (geometry.properties && typeof geometry.properties === 'object') {
			properties = geometry.properties;
			console.log(`✅ GeoLink ${index} 從 geometry.properties 取得屬性`);
		} else if (link.properties && typeof link.properties === 'object') {
			properties = link.properties;
			console.log(`✅ GeoLink ${index} 從 link.properties 取得屬性`);
		} else {
			console.warn(`GeoLink ${index} 無法找到有效的 properties`);
			properties = {};
		}
		
		console.log(`🔍 GeoLink ${index} 完整屬性:`, properties);
		
		const coordinates = geometry.coordinates;
		
		if (!coordinates || !Array.isArray(coordinates) || coordinates.length < 2) {
			console.warn(`GeoLink ${index} 座標格式無效:`, coordinates);
			return null;
		}
		
		// 轉換座標格式並驗證
		const latLngs = [];
		for (let i = 0; i < coordinates.length; i++) {
			const coord = coordinates[i];
			if (!Array.isArray(coord) || coord.length < 2) {
				console.warn(`GeoLink ${index} 第 ${i} 個座標無效:`, coord);
				continue;
			}
			
			// 處理字串格式座標 - 轉換為數字
			const lng = parseFloat(coord[0]);
			const lat = parseFloat(coord[1]);
			
			if (isNaN(lng) || isNaN(lat)) {
				console.warn(`GeoLink ${index} 第 ${i} 個座標數值無效:`, coord);
				continue;
			}
			
			// 檢查座標合理性（台灣範圍）
			if (lng >= 118 && lng <= 122 && lat >= 21 && lat <= 26) {
				latLngs.push([lat, lng]);
			} else {
				console.warn(`GeoLink ${index} 第 ${i} 個座標超出台灣範圍:`, [lng, lat]);
			}
		}
		
		if (latLngs.length < 2) {
			console.warn(`GeoLink ${index} 有效座標點不足:`, latLngs);
			return null;
		}
		
		// 分類線段 - 根據電壓等級和線路類型
		const category = categorizeGeoLinkAdvanced(properties);
		
		console.log(`✅ GeoLink ${index} 處理成功，座標點數: ${latLngs.length}, 類別: ${category}`);
		
		return {
			coordinates: latLngs,
			properties: properties,
			category: category,
			featureIndex: index,
			type: 'LineString'
		};
	}

	// GeoLink 進階分類 - 完全修正版（加強除錯輸出）
	function categorizeGeoLinkAdvanced(properties) {
		console.log('🔍 GeoLink 完整屬性分析:', properties);
		
		// 🔧 修正：直接從 GeoLink 屬性中取得電壓等級
		let voltageLevel = 'unknown';
		
		// 方法1: 直接從 GeoLink 屬性判斷電壓等級
		const vlevel = properties.VLevel || properties.vlevel || '';
		console.log(`🔍 GeoLink VLevel 原始值:`, vlevel, `(類型: ${typeof vlevel})`);
		
		if (vlevel) {
			const vLevel = parseInt(vlevel);
			if (vLevel === 1) {
				voltageLevel = '11.4kv';
			} else if (vLevel === 2) {
				voltageLevel = '22.8kv';
			}
			console.log(`✅ 從 GeoLink 直接取得電壓等級: VLevel=${vLevel} -> ${voltageLevel}`);
		} else {
			// 方法2: 如果 GeoLink 沒有 VLevel，嘗試查找節點
			const fromId = properties.FromID;
			const toId = properties.ToID;
			
			if (fromId || toId) {
				const fromNode = allDevicesData.find(device => 
					device.properties.ID == fromId || device.properties.ID === fromId
				);
				const toNode = allDevicesData.find(device => 
					device.properties.ID == toId || device.properties.ID === toId
				);
				
				console.log(`🔍 查找節點 - FromID: ${fromId}, ToID: ${toId}`);
				console.log(`🔍 找到起點節點:`, fromNode ? `ID=${fromNode.properties.ID}, VLevel=${fromNode.properties.VLevel}` : '未找到');
				console.log(`🔍 找到終點節點:`, toNode ? `ID=${toNode.properties.ID}, VLevel=${toNode.properties.VLevel}` : '未找到');
				
				const referenceNode = fromNode || toNode;
				if (referenceNode && referenceNode.properties.VLevel) {
					const vLevel = parseInt(referenceNode.properties.VLevel);
					if (vLevel === 1) {
						voltageLevel = '11.4kv';
					} else if (vLevel === 2) {
						voltageLevel = '22.8kv';
					}
					console.log(`✅ 從節點取得電壓等級: VLevel=${vLevel} -> ${voltageLevel}`);
				}
			}
		}
		
		// 🔧 修正：判斷架空/地下 - 檢查所有可能的屬性名稱和值
		const ohug = properties.OHUG || properties.ohug || properties.Ohug || '';
		console.log(`🔍 OHUG 原始值:`, ohug, `(類型: ${typeof ohug})`);
		
		let isUnderground = false;
		
		// 處理不同的資料類型和值
		if (typeof ohug === 'string') {
			isUnderground = (ohug === '1' || ohug.toLowerCase() === 'underground' || ohug.toLowerCase() === 'u');
		} else if (typeof ohug === 'number') {
			isUnderground = (ohug === 1);
		} else if (typeof ohug === 'boolean') {
			isUnderground = ohug;
		}
		
		console.log(`🔍 架設方式判斷: OHUG=${ohug} -> ${isUnderground ? '地下' : '架空'}`);
		
		// 🔧 修正：判斷主幹線/分歧線 - 檢查所有可能的屬性名稱和值
		const cabType = properties.CabType || properties.cabtype || properties.Cabtype || '';
		console.log(`🔍 CabType 原始值:`, cabType, `(類型: ${typeof cabType})`);
		
		let isMainLine = false;
		
		// 處理不同的資料類型和值
		if (typeof cabType === 'string') {
			isMainLine = (cabType === '0' || cabType.toLowerCase() === 'main' || cabType.toLowerCase() === 'm');
		} else if (typeof cabType === 'number') {
			isMainLine = (cabType === 0);
		} else if (typeof cabType === 'boolean') {
			isMainLine = !cabType; // 假設 false 代表主幹線
		}
		
		console.log(`🔍 線路類型判斷: CabType=${cabType} -> ${isMainLine ? '主幹線' : '分歧線'}`);
		
		// 組合分類
		let category = '';
		
		if (voltageLevel === '22.8kv') {
			if (isMainLine) {
				category = isUnderground ? 'line_22_8kv_main_underground' : 'line_22_8kv_main_overhead';
			} else {
				category = isUnderground ? 'line_22_8kv_branch_underground' : 'line_22_8kv_branch_overhead';
			}
		} else if (voltageLevel === '11.4kv') {
			if (isMainLine) {
				category = isUnderground ? 'line_11_4kv_main_underground' : 'line_11_4kv_main_overhead';
			} else {
				category = isUnderground ? 'line_11_4kv_branch_underground' : 'line_11_4kv_branch_overhead';
			}
		} else {
			// 未知電壓等級
			category = isUnderground ? 'line_other_underground' : 'line_other_overhead';
		}
		
		console.log(`✅ 最終分類結果:`);
		console.log(`   - 電壓等級: ${voltageLevel}`);
		console.log(`   - 架設方式: ${isUnderground ? '地下' : '架空'}`);
		console.log(`   - 線路類型: ${isMainLine ? '主幹線' : '分歧線'}`);
		console.log(`   - 最終類別: ${category}`);
		
		return category;
	}
	// 處理台電 GeoNode - 完全修正版（參考你的 Python 程式）
	function processGeoNode(node, index) {
		console.log(`🔍 處理 GeoNode ${index}:`, node);
		
		if (!node.type || node.type !== 'Feature') {
			console.warn(`GeoNode ${index} 不是有效的 Feature:`, node);
			return null;
		}
		
		const geometry = node.geometry;
		if (!geometry || geometry.type !== 'Point') {
			console.warn(`GeoNode ${index} 不是點幾何:`, node);
			return null;
		}
		
		// 🔧 重要修正：根據你的 Python 程式，properties 在 geometry.properties 內部
		const properties = geometry.properties || {};
		const coordinates = geometry.coordinates;
		
		console.log(`🔍 GeoNode ${index} 屬性內容:`, properties);
		console.log(`🔍 GeoNode ${index} 座標:`, coordinates);
		
		if (!coordinates || !Array.isArray(coordinates) || coordinates.length < 2) {
			console.warn(`GeoNode ${index} 座標格式無效:`, coordinates);
			return null;
		}
		
		// 🔧 重要修正：你的資料中座標是字串格式，需要轉換為數字
		const lng = parseFloat(coordinates[0]);
		const lat = parseFloat(coordinates[1]);
		
		if (isNaN(lng) || isNaN(lat)) {
			console.warn(`GeoNode ${index} 座標轉換失敗:`, coordinates);
			return null;
		}
		
		// 檢查座標合理性（台灣範圍）
		if (lng < 118 || lng > 122 || lat < 21 || lat > 26) {
			console.warn(`GeoNode ${index} 座標超出台灣範圍:`, [lng, lat]);
			// 不直接 return null，繼續處理（可能是測試資料）
		}
		
		// 🔧 標準化屬性 - 確保所有屬性都是正確的資料類型
		const standardizedProps = {
			ID: properties.ID || properties.id || `temp_${index}`,
			Area: properties.Area || properties.area || '',
			Feeder: properties.Feeder || properties.feeder || '',
			Tpclid: properties.Tpclid || properties.tpclid || '',
			FSC: properties.FSC || properties.fsc || '',
			VLevel: properties.VLevel || properties.vlevel || '',
			CabType: properties.CabType || properties.cabtype || '',
			OHUG: properties.OHUG || properties.ohug || '',
			Tag: properties.Tag || properties.tag || '',
			Spec: properties.Spec || properties.spec || '',
			Length: properties.Length || properties.length || '',
			Location: properties.Location || properties.location || '',
			Type: properties.Type || properties.type || '',
			Name: properties.Name || properties.name || '',
			Visible: properties.Visible !== undefined ? properties.Visible : true,
			NO: properties.NO || false,
			Auto: properties.Auto || false,
			Fuse: properties.Fuse || false,
			Opposite: properties.Opposite || '',
			
			// 容量相關
			Capacity: properties.Capacity || '',
			Capacities: properties.Capacities || '',
			Capacity1: properties.Capacity1 || '',
			Capacity2: properties.Capacity2 || '',
			Capacity3: properties.Capacity3 || '',
			
			// 相別相關
			Group1: properties.Group1 || '',
			Phase1: properties.Phase1 || '',
			Phase2: properties.Phase2 || '',
			Phase3: properties.Phase3 || '',
			
			// 燈具類型
			LightType1: properties.LightType1 || '',
			LightType2: properties.LightType2 || '',
			LightType3: properties.LightType3 || '',
			SupplyType: properties.SupplyType || '',
			
			// 迴路資訊
			SrcLoop: properties.SrcLoop || null,
			DestLoop: properties.DestLoop || null
		};
		
		// 保留原始屬性（以防有其他未知屬性）
		Object.keys(properties).forEach(key => {
			if (!standardizedProps.hasOwnProperty(key)) {
				standardizedProps[key] = properties[key];
			}
		});
		
		// 分類設備
		const category = categorizeNode(standardizedProps);
		
		console.log(`✅ GeoNode ${index} 處理成功:`);
		console.log(`   - ID: ${standardizedProps.ID}`);
		console.log(`   - FSC: ${standardizedProps.FSC}`);
		console.log(`   - Area: ${standardizedProps.Area}`);
		console.log(`   - Feeder: ${standardizedProps.Feeder}`);
		console.log(`   - 類別: ${category}`);
		console.log(`   - 座標: [${lng}, ${lat}]`);
		
		return {
			coordinates: [lng, lat],
			properties: standardizedProps,
			category: category,
			featureIndex: index,
			type: 'Point'
		};
	}

	// 處理線段 Feature - 新函數
	function processLineFeature(feature, index) {
		const geometry = feature.geometry;
		const properties = feature.properties || {};
		
		if (!geometry.coordinates || !Array.isArray(geometry.coordinates)) {
			console.warn(`線段 Feature ${index} 缺少有效座標:`, feature);
			return null;
		}
		
		const coordinates = geometry.coordinates;
		
		// 驗證 LineString 座標格式
		if (coordinates.length < 2) {
			console.warn(`線段 Feature ${index} 座標點不足:`, coordinates);
			return null;
		}
		
		// 轉換座標格式並驗證
		const latLngs = [];
		for (let i = 0; i < coordinates.length; i++) {
			const coord = coordinates[i];
			if (!Array.isArray(coord) || coord.length < 2) {
				console.warn(`線段 Feature ${index} 第 ${i} 個座標無效:`, coord);
				continue;
			}
			
			// 處理字串格式座標 - 轉換為數字
			const lng = parseFloat(coord[0]);
			const lat = parseFloat(coord[1]);
			
			if (isNaN(lng) || isNaN(lat)) {
				console.warn(`線段 Feature ${index} 第 ${i} 個座標數值無效:`, coord);
				continue;
			}
			
			// 檢查座標合理性（台灣範圍）
			if (lng >= 118 && lng <= 122 && lat >= 21 && lat <= 26) {
				latLngs.push([lat, lng]);
			} else {
				console.warn(`線段 Feature ${index} 第 ${i} 個座標超出台灣範圍:`, [lng, lat]);
			}
		}
		
		if (latLngs.length < 2) {
			console.warn(`線段 Feature ${index} 有效座標點不足:`, latLngs);
			return null;
		}
		
		// 分類線段
		const category = categorizeLineFeatureAdvanced(properties);
		
		console.log(`✅ 線段 Feature ${index} 處理成功，座標點數: ${latLngs.length}, 類別: ${category}`);
		
		return {
			coordinates: latLngs,
			properties: properties,
			category: category,
			featureIndex: index,
			type: 'LineString'
		};
	}

	// 處理點 Feature - 新函數
	function processPointFeature(feature, index) {
		const geometry = feature.geometry;
		const properties = feature.properties || {};
		
		if (!geometry.coordinates || !Array.isArray(geometry.coordinates)) {
			console.warn(`點 Feature ${index} 缺少有效座標:`, feature);
			return null;
		}
		
		const coordinates = geometry.coordinates;
		
		if (coordinates.length < 2) {
			console.warn(`點 Feature ${index} 座標格式無效:`, coordinates);
			return null;
		}
		
		// 確保座標是數字 - 處理字串格式座標
		const lng = parseFloat(coordinates[0]);
		const lat = parseFloat(coordinates[1]);
		
		if (isNaN(lng) || isNaN(lat)) {
			console.warn(`點 Feature ${index} 座標無效:`, coordinates);
			return null;
		}
		
		// 檢查座標合理性（台灣範圍）
		if (lng < 118 || lng > 122 || lat < 21 || lat > 26) {
			console.warn(`點 Feature ${index} 座標超出台灣範圍:`, [lng, lat]);
			return null;
		}
		
		// 分類設備
		const category = categorizeNode(properties);
		
		return {
			coordinates: [lng, lat],
			properties: properties,
			category: category,
			featureIndex: index,
			type: 'Point'
		};
	}

	// 線段分類 - 針對 Feature 格式（進階版）
	function categorizeLineFeatureAdvanced(properties) {
		// 判斷電壓等級（這裡需要根據實際資料調整）
		const vlevel = properties.VLevel || properties.vlevel || '';
		let voltageLevel = 'unknown';
		
		if (vlevel) {
			const vLevel = parseInt(vlevel);
			if (vLevel === 1) {
				voltageLevel = '11.4kv';
			} else if (vLevel === 2) {
				voltageLevel = '22.8kv';
			}
		}
		
		// 判斷架空/地下
		const ohug = properties.OHUG || properties.ohug || '';
		const isUnderground = (ohug === '1' || ohug === 1);
		
		// 判斷主幹線/分歧線
		const cabType = properties.CabType || properties.cabtype || '';
		const isMainLine = (cabType === '0' || cabType === 0);
		
		// 組合分類
		let category = '';
		
		if (voltageLevel === '22.8kv') {
			if (isMainLine) {
				category = isUnderground ? 'line_22_8kv_main_underground' : 'line_22_8kv_main_overhead';
			} else {
				category = isUnderground ? 'line_22_8kv_branch_underground' : 'line_22_8kv_branch_overhead';
			}
		} else if (voltageLevel === '11.4kv') {
			if (isMainLine) {
				category = isUnderground ? 'line_11_4kv_main_underground' : 'line_11_4kv_main_overhead';
			} else {
				category = isUnderground ? 'line_11_4kv_branch_underground' : 'line_11_4kv_branch_overhead';
			}
		} else {
			// 未知電壓等級
			category = isUnderground ? 'line_other_underground' : 'line_other_overhead';
		}
		
		return category;
	}
			
			// 提取饋線資訊 - 修正版
	function extractFeederInfo(firstNode, fileName) {
		let properties = {};
		
		// 台電格式
		if (firstNode.geometry && firstNode.geometry.properties) {
			properties = firstNode.geometry.properties;
		}
		// 標準 GeoJSON 格式
		else if (firstNode.properties) {
			properties = firstNode.properties;
		}
		
		currentFeederInfo = {
			fileName: fileName,
			area: properties.Area || '未知',
			feeder: properties.Feeder || '未知',
			totalDevices: 0,
			totalLines: 0
		};
		
		console.log('📊 饋線資訊:', currentFeederInfo);
	}
			
		   // 顯示饋線資訊 - 改進版
	function displayFeederInfo() {
		if (!currentFeederInfo) return;
		
		// 更新統計數據
		currentFeederInfo.totalDevices = allDevicesData.length;
		currentFeederInfo.totalLines = allLinesData.length;
		
		const infoContainer = document.getElementById('feederInfo');
		if (infoContainer) {
			infoContainer.innerHTML = `
				<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; border-radius: 8px; margin-bottom: 10px;">
					<h3 style="margin: 0 0 8px 0; font-size: 16px;">📊 ${currentFeederInfo.fileName}</h3>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
						<div>🏢 區域: ${currentFeederInfo.area}</div>
						<div>⚡ 饋線: ${currentFeederInfo.feeder}</div>
						<div>📍 設備: ${currentFeederInfo.totalDevices}</div>
						<div>📏 線段: ${currentFeederInfo.totalLines}</div>
					</div>
				</div>
			`;
			infoContainer.style.display = 'block';
		}
	}
			
			// 設備分類 - 根據台電 FSC 代碼（續）
			  function categorizeNode(properties) {
				  const fsc = properties.FSC || properties.fsc || '';
				  const fscNum = parseInt(fsc);
				  
				  // 根據台電 FSC 代碼分類
				  switch (fscNum) {
					  case 106: return 'poles_106';      // 電桿設備
					  case 108: return 'cable_heads';    // 電纜頭
					  case 109: return 'pole_markers';   // 電桿標示
					  case 110: return 'solar';          // 太陽能設備
					  case 114: return 'switches';       // 開關設備
					  case 115: return 'transformers';   // 變壓器
					  case 116: return 'poles_116';      // 終端
					  case 120: return 'grounding';      // 接地設備
					  case 131: return 'others_131';     // 其他設備
					  default: return 'unknown';         // 未知設備
				  }
			  }
			  
			  // 更新圖層分類定義 - 針對線路區隔化
	function createLayerControls() {
    // 定義設備類別 - 根據台電 FSC 分類
    const categories = {
        // 點設備類別
        'poles_106': { name: '🔴 線路節點 (FSC:106)', color: '#e74c3c', count: 0, type: 'point' },
        'cable_heads': { name: '🟠 變電所 (FSC:108)', color: '#f39c12', count: 0, type: 'point' },
        'pole_markers': { name: '🟣 電桿標示 (FSC:109)', color: '#9b59b6', count: 0, type: 'point' },
        'solar': { name: '🟡 太陽能設備 (FSC:110)', color: '#f1c40f', count: 0, type: 'point' },
        'switches': { name: '🟢 開關設備 (FSC:114)', color: '#27ae60', count: 0, type: 'point' },
        'transformers': { name: '🔵 變壓器 (FSC:115)', color: '#3498db', count: 0, type: 'point' },
        'poles_116': { name: '🟤 終端 (FSC:116)', color: '#8b4513', count: 0, type: 'point' },
        'grounding': { name: '⚫ 電桿設備 (FSC:120)', color: '#2c3e50', count: 0, type: 'point' },
        'others_131': { name: '🟣 其他設備 (FSC:131)', color: '#8e44ad', count: 0, type: 'point' },
        'unknown': { name: '🔘 未知設備', color: '#95a5a6', count: 0, type: 'point' },
        
        // 線段類別 - 根據電壓等級、架空地下、主幹分歧區隔
        'line_22_8kv_main_overhead': { name: '🔴 22.8kV 主幹線 (架空)', color: '#dc3545', count: 0, type: 'line', style: 'solid' },
        'line_22_8kv_main_underground': { name: '🔴 22.8kV 主幹線 (地下)', color: '#dc3545', count: 0, type: 'line', style: 'dashed' },
        'line_22_8kv_branch_overhead': { name: '🔵 22.8kV 分歧線 (架空)', color: '#007bff', count: 0, type: 'line', style: 'solid' },
        'line_22_8kv_branch_underground': { name: '🔵 22.8kV 分歧線 (地下)', color: '#007bff', count: 0, type: 'line', style: 'dashed' },
        'line_11_4kv_main_overhead': { name: '🟠 11.4kV 主幹線 (架空)', color: '#fd7e14', count: 0, type: 'line', style: 'solid' },
        'line_11_4kv_main_underground': { name: '🟠 11.4kV 主幹線 (地下)', color: '#fd7e14', count: 0, type: 'line', style: 'dashed' },
        'line_11_4kv_branch_overhead': { name: '🟢 11.4kV 分歧線 (架空)', color: '#28a745', count: 0, type: 'line', style: 'solid' },
        'line_11_4kv_branch_underground': { name: '🟢 11.4kV 分歧線 (地下)', color: '#28a745', count: 0, type: 'line', style: 'dashed' },
        'line_other_overhead': { name: '⚫ 其他線路 (架空)', color: '#6c757d', count: 0, type: 'line', style: 'solid' },
        'line_other_underground': { name: '⚫ 其他線路 (地下)', color: '#6c757d', count: 0, type: 'line', style: 'dashed' }
    };
    
    // 定義不預設顯示的類別
    const initiallyHiddenCategories = [
        'poles_106', 
        'grounding',
        'poles_116',
        'pole_markers',
        'transformers',
        'unknown',
        'others_131',
        'line_22_8kv_branch_overhead',
        'line_22_8kv_branch_underground', 
        'line_11_4kv_branch_overhead',
        'line_11_4kv_branch_underground'
    ];
    
    // 統計點設備數量並建立圖層群組
    allDevicesData.forEach(device => {
        const category = device.category;
        if (categories[category]) {
            categories[category].count++;
        }
        
        if (!layerGroups[category]) {
            layerGroups[category] = L.layerGroup();
            
            // 只有不在隱藏清單的才加入地圖
            if (!initiallyHiddenCategories.includes(category)) {
                layerGroups[category].addTo(map);
            }
        }
        
        const marker = createMarker(device, categories[category].color);
        layerGroups[category].addLayer(marker);
    });

    // 統計線段數量並建立圖層群組
    allLinesData.forEach(line => {
        const category = line.category;
        if (categories[category]) {
            categories[category].count++;
        }
        
        if (!layerGroups[category]) {
            layerGroups[category] = L.layerGroup();
            
            if (!initiallyHiddenCategories.includes(category)) {
                layerGroups[category].addTo(map);
            }
        }
        
        const polyline = createPolylineAdvanced(line, categories[category]);
        layerGroups[category].addLayer(polyline);
        
        if (!initiallyHiddenCategories.includes(category)) {
            if (polyline.arrowMarkers && Array.isArray(polyline.arrowMarkers)) {
                polyline.arrowMarkers.forEach(marker => {
                    arrowLayerGroup.addLayer(marker);
                });
            }
        }
    });
    
    // 更新圖層計數
    layerCounts = Object.keys(categories).reduce((acc, key) => {
        acc[key] = categories[key].count;
        return acc;
    }, {});
    
    // 建立控制介面
    const container = document.getElementById('layerControlsContainer');
    container.innerHTML = '';
    
    // 🆕 新增全選控制區域
    const selectAllContainer = document.createElement('div');
    selectAllContainer.className = 'select-all-container';
	selectAllContainer.innerHTML = `
		<div class="select-all-section">
			<h4>🔧 批次控制</h4>
			<div class="select-all-buttons">
				<button class="select-all-btn equipment" id="equipmentToggleBtn" onclick="toggleAllEquipment()">
					📍 全選設備
				</button>
				<button class="select-all-btn lines" id="linesToggleBtn" onclick="toggleAllLines()">
					⚡ 全選線路
				</button>
				<button class="select-all-btn deselect" onclick="deselectAll()">
					❌ 全部取消
				</button>
			</div>
		</div>
		<hr class="divider">
	`;
    container.appendChild(selectAllContainer);
    
    // 先顯示點設備
    const pointCategories = Object.keys(categories).filter(key => 
        categories[key].type === 'point' && categories[key].count > 0
    );
    if (pointCategories.length > 0) {
        const pointHeader = document.createElement('h4');
        pointHeader.textContent = '📍 點設備';
        pointHeader.style.cssText = 'margin: 10px 0 5px 0; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #ecf0f1; padding-bottom: 3px;';
        container.appendChild(pointHeader);
        
        pointCategories.forEach(categoryKey => {
            const category = categories[categoryKey];
            const layerItem = createLayerControlItem(categoryKey, category);
            container.appendChild(layerItem);
        });
    }
    
    // 再顯示線段
    const lineCategories = Object.keys(categories).filter(key => 
        categories[key].type === 'line' && categories[key].count > 0
    );
    if (lineCategories.length > 0) {
        const lineHeader = document.createElement('h4');
        lineHeader.textContent = '📏 線段';
        lineHeader.style.cssText = 'margin: 15px 0 5px 0; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #ecf0f1; padding-bottom: 3px;';
        container.appendChild(lineHeader);
        
        lineCategories.forEach(categoryKey => {
            const category = categories[categoryKey];
            const layerItem = createLayerControlItem(categoryKey, category);
            container.appendChild(layerItem);
        });
    }
    
    // 顯示統計摘要
    const totalPoints = pointCategories.reduce((sum, key) => sum + categories[key].count, 0);
    const totalLines = lineCategories.reduce((sum, key) => sum + categories[key].count, 0);
    
    const summaryDiv = document.createElement('div');
    summaryDiv.style.cssText = 'margin-top: 15px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 12px; color: #6c757d;';
    summaryDiv.innerHTML = `
        <strong>📊 資料統計</strong><br>
        點設備: ${totalPoints} 個<br>
        線段: ${totalLines} 條
    `;
    container.appendChild(summaryDiv);
}
			  
		// 建立圖層控制項目 - 修改版
		function createLayerControlItem(categoryKey, category) {
			// 🔧 修改：擴展預設隱藏清單，包含所有分歧線段
			const initiallyHiddenCategories = [
				'poles_106', 
				'grounding',
				'poles_116',
				'pole_markers',
				'transformers',
				'unknown',
				'others_131',
				'line_22_8kv_branch_overhead',
				'line_22_8kv_branch_underground', 
				'line_11_4kv_branch_overhead',
				'line_11_4kv_branch_underground'
			];
			
			const isChecked = !initiallyHiddenCategories.includes(categoryKey);
			
			const layerItem = document.createElement('div');
			layerItem.className = 'layer-item';
			
			layerItem.innerHTML = `
				<input type="checkbox" id="layer_${categoryKey}" ${isChecked ? 'checked' : ''} onchange="toggleLayer('${categoryKey}')">
				<label for="layer_${categoryKey}">${category.name}</label>
				<span class="layer-count">${category.count}</span>
			`;
			
			return layerItem;
		}
		// 🆕 切換設備顯示功能
function toggleAllEquipment() {
    const equipmentCategories = [
        'poles_106', 'cable_heads', 'pole_markers', 'solar', 
        'switches', 'transformers', 'poles_116', 'grounding', 
        'others_131', 'unknown'
    ];
    
    const btn = document.getElementById('equipmentToggleBtn');
    const isActive = btn.classList.contains('active');
    
    if (isActive) {
        // 目前是啟用狀態，執行關閉
        equipmentCategories.forEach(category => {
            const checkbox = document.getElementById(`layer_${category}`);
            const layerGroup = layerGroups[category];
            
            if (checkbox && layerGroup && checkbox.checked) {
                checkbox.checked = false;
                map.removeLayer(layerGroup);
            }
        });
        
        // 更新按鈕狀態
        btn.classList.remove('active');
        btn.innerHTML = '📍 全選設備';
        console.log('📍 已隱藏所有設備圖層');
        
    } else {
        // 目前是關閉狀態，執行開啟
        equipmentCategories.forEach(category => {
            const checkbox = document.getElementById(`layer_${category}`);
            const layerGroup = layerGroups[category];
            
            if (checkbox && layerGroup && !checkbox.checked) {
                checkbox.checked = true;
                map.addLayer(layerGroup);
            }
        });
        
        // 更新按鈕狀態
        btn.classList.add('active');
        btn.innerHTML = '📍 隱藏設備';
        console.log('📍 已顯示所有設備圖層');
    }
}

// 🆕 切換線路顯示功能
function toggleAllLines() {
    const lineCategories = [
        'line_22_8kv_main_overhead', 'line_22_8kv_main_underground',
        'line_22_8kv_branch_overhead', 'line_22_8kv_branch_underground',
        'line_11_4kv_main_overhead', 'line_11_4kv_main_underground',
        'line_11_4kv_branch_overhead', 'line_11_4kv_branch_underground',
        'line_other_overhead', 'line_other_underground'
    ];
    
    const btn = document.getElementById('linesToggleBtn');
    const isActive = btn.classList.contains('active');
    
    if (isActive) {
        // 目前是啟用狀態，執行關閉
        lineCategories.forEach(category => {
            const checkbox = document.getElementById(`layer_${category}`);
            const layerGroup = layerGroups[category];
            
            if (checkbox && layerGroup && checkbox.checked) {
                checkbox.checked = false;
                map.removeLayer(layerGroup);
                
                // 隱藏該圖層的箭頭
                layerGroup.eachLayer(layer => {
                    if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                        layer.arrowMarkers.forEach(marker => {
                            arrowLayerGroup.removeLayer(marker);
                        });
                    }
                });
            }
        });
        
        // 更新按鈕狀態
        btn.classList.remove('active');
        btn.innerHTML = '⚡ 全選線路';
        console.log('⚡ 已隱藏所有線路圖層');
        
    } else {
        // 目前是關閉狀態，執行開啟
        lineCategories.forEach(category => {
            const checkbox = document.getElementById(`layer_${category}`);
            const layerGroup = layerGroups[category];
            
            if (checkbox && layerGroup && !checkbox.checked) {
                checkbox.checked = true;
                map.addLayer(layerGroup);
                
                // 顯示該圖層的箭頭
                layerGroup.eachLayer(layer => {
                    if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                        layer.arrowMarkers.forEach(marker => {
                            arrowLayerGroup.addLayer(marker);
                        });
                    }
                });
            }
        });
        
        // 更新按鈕狀態
        btn.classList.add('active');
        btn.innerHTML = '⚡ 隱藏線路';
        console.log('⚡ 已顯示所有線路圖層');
    }
}

		// 🆕 全選設備功能
function selectAllEquipment() {
    const equipmentCategories = [
        'poles_106', 'cable_heads', 'pole_markers', 'solar', 
        'switches', 'transformers', 'poles_116', 'grounding', 
        'others_131', 'unknown'
    ];
    
    equipmentCategories.forEach(category => {
        const checkbox = document.getElementById(`layer_${category}`);
        const layerGroup = layerGroups[category];
        
        if (checkbox && layerGroup && !checkbox.checked) {
            checkbox.checked = true;
            map.addLayer(layerGroup);
        }
    });
    
    console.log('📍 已全選所有設備圖層');
}

// 🆕 全選線路功能
function selectAllLines() {
    const lineCategories = [
        'line_22_8kv_main_overhead', 'line_22_8kv_main_underground',
        'line_22_8kv_branch_overhead', 'line_22_8kv_branch_underground',
        'line_11_4kv_main_overhead', 'line_11_4kv_main_underground',
        'line_11_4kv_branch_overhead', 'line_11_4kv_branch_underground',
        'line_other_overhead', 'line_other_underground'
    ];
    
    lineCategories.forEach(category => {
        const checkbox = document.getElementById(`layer_${category}`);
        const layerGroup = layerGroups[category];
        
        if (checkbox && layerGroup && !checkbox.checked) {
            checkbox.checked = true;
            map.addLayer(layerGroup);
            
            // 顯示該圖層的箭頭
            layerGroup.eachLayer(layer => {
                if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                    layer.arrowMarkers.forEach(marker => {
                        arrowLayerGroup.addLayer(marker);
                    });
                }
            });
        }
    });
    
    console.log('⚡ 已全選所有線路圖層');
}

// 🔧 修改全部取消功能（同時重置按鈕狀態）
function deselectAll() {
    Object.keys(layerGroups).forEach(category => {
        const checkbox = document.getElementById(`layer_${category}`);
        const layerGroup = layerGroups[category];
        
        if (checkbox && layerGroup && checkbox.checked) {
            checkbox.checked = false;
            map.removeLayer(layerGroup);
            
            // 隱藏該圖層的箭頭
            layerGroup.eachLayer(layer => {
                if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                    layer.arrowMarkers.forEach(marker => {
                        arrowLayerGroup.removeLayer(marker);
                    });
                }
            });
        }
    });
    
    // 🆕 重置按鈕狀態
    const equipmentBtn = document.getElementById('equipmentToggleBtn');
    const linesBtn = document.getElementById('linesToggleBtn');
    
    if (equipmentBtn) {
        equipmentBtn.classList.remove('active');
        equipmentBtn.innerHTML = '📍 全選設備';
    }
    
    if (linesBtn) {
        linesBtn.classList.remove('active');
        linesBtn.innerHTML = '⚡ 全選線路';
    }
    
    console.log('❌ 已取消所有圖層並重置按鈕狀態');
}
			  
			  // 建立進階線段 - 支援實線虛線區隔 + 點選高亮
	// 建立進階線段 - 支援實線虛線區隔 + 點選高亮 + 箭頭方向
	function createPolylineAdvanced(lineData, categoryInfo) {
		const coordinates = lineData.coordinates;
		const props = lineData.properties;
		
		// 建立線段樣式
		const lineStyle = {
			color: categoryInfo.color,
			weight: 4,
			opacity: 0.8,
			smoothFactor: 1
		};
		
		// 根據樣式設定實線或虛線
		if (categoryInfo.style === 'dashed') {
			lineStyle.dashArray = '8,8';  // 地下線路用虛線
		} else {
			lineStyle.dashArray = null;     // 架空線路用實線
		}
		
		const polyline = L.polyline(coordinates, lineStyle);
		
		// 儲存原始樣式
		polyline.originalStyle = { ...lineStyle };
		
		// 🔧 新增：添加箭頭標記
		const arrowMarkers = addArrowsToPolyline(polyline, categoryInfo.color);
		
		// 加入點選事件 - 高亮功能
		polyline.on('click', function(e) {
			// 重置之前選中的線段
			if (selectedLine && selectedLine !== polyline) {
				selectedLine.setStyle(selectedLine.originalStyle);
				// 重置之前線段的箭頭顏色
				if (selectedLine.arrowMarkers) {
					selectedLine.arrowMarkers.forEach(marker => {
						updateArrowColor(marker, selectedLine.originalStyle.color);
					});
				}
			}
			
			// 設定新的選中線段
			selectedLine = polyline;
			
			// 應用高亮樣式
			const highlightStyle = {
				color: '#ffff00',  // 黃色高亮
				weight: 6,
				opacity: 1.0,
				dashArray: lineStyle.dashArray  // 保持原有的實線/虛線樣式
			};
			
			polyline.setStyle(highlightStyle);
			
			// 高亮箭頭
			if (arrowMarkers) {
				arrowMarkers.forEach(marker => {
					updateArrowColor(marker, '#ffff00');
				});
			}
			
			// 阻止事件冒泡
			L.DomEvent.stopPropagation(e);
			
			console.log('🎯 線段已高亮:', props.FromID, '->', props.ToID);
		});
		
		// 滑鼠移入效果
		polyline.on('mouseover', function() {
			if (selectedLine !== polyline) {
				const hoverStyle = {
					...lineStyle,
					weight: lineStyle.weight + 1,
					opacity: 1.0
				};
				polyline.setStyle(hoverStyle);
			}
		});
		
		// 滑鼠移出效果
		polyline.on('mouseout', function() {
			if (selectedLine !== polyline) {
				polyline.setStyle(lineStyle);
			}
		});
		
		// 儲存箭頭標記參考
		polyline.arrowMarkers = arrowMarkers;
		
		// 建立彈出視窗內容（保持原有功能）
		let popupContent = '<div style="max-width: 320px; font-size: 13px;">';
		popupContent += `<h4 style="margin: 0 0 10px 0; color: ${categoryInfo.color}; font-size: 14px;">🔗 ${categoryInfo.name}</h4>`;
		
		// 顯示主要屬性
		const importantProps = [
			{ key: 'FromID', label: '起點設備ID' },
			{ key: 'ToID', label: '終點設備ID' },
			{ key: 'FromLoop', label: '起點迴路' },
			{ key: 'ToLoop', label: '終點迴路' },
			{ key: 'CabType', label: '線路類型' },
			{ key: 'OHUG', label: '架設方式' },
			{ key: 'Visible', label: '可見性' }
		];
		
		importantProps.forEach(prop => {
			if (props[prop.key] !== undefined && props[prop.key] !== '') {
				let value = props[prop.key];
				
				// 特殊值轉換
				if (prop.key === 'CabType') {
					if (value === '0' || value === 0) {
						value = '主幹線';
					} else if (value === '1' || value === 1) {
						value = '分歧線';
					}
				} else if (prop.key === 'OHUG') {
					if (value === '0' || value === 0) {
						value = '架空';
					} else if (value === '1' || value === 1) {
						value = '地下';
					}
				} else if (prop.key === 'Visible') {
					value = value ? '是' : '否';
				}
				
				popupContent += `<p style="margin: 3px 0;"><strong>${prop.label}:</strong> ${value}</p>`;
			}
		});
		
		// 顯示線段統計
		const lineLength = calculateLineLength(coordinates);
		const pointCount = coordinates.length;
		
		popupContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #eee;">';
		popupContent += `<p style="margin: 3px 0;"><strong>📍 座標點數:</strong> ${pointCount}</p>`;
		popupContent += `<p style="margin: 3px 0;"><strong>📏 計算長度:</strong> ${lineLength.toFixed(2)} 公尺</p>`;
		popupContent += `<p style="margin: 3px 0;"><strong>➡️ 電流方向:</strong> ${props.FromID} → ${props.ToID}</p>`;
		
		// 顯示起終點座標
		if (coordinates.length > 0) {
			const startPoint = coordinates[0];
			const endPoint = coordinates[coordinates.length - 1];
			popupContent += `<p style="margin: 3px 0; font-size: 11px; color: #666;"><strong>起點:</strong> ${startPoint[0].toFixed(6)}, ${startPoint[1].toFixed(6)}</p>`;
			popupContent += `<p style="margin: 3px 0; font-size: 11px; color: #666;"><strong>終點:</strong> ${endPoint[0].toFixed(6)}, ${endPoint[1].toFixed(6)}</p>`;
		}
		
		popupContent += '<hr style="margin: 5px 0; border: none; border-top: 1px solid #eee;">';
		popupContent += '</div>';
		
		polyline.bindPopup(popupContent);
		
		return polyline;
	}
	// 為線段添加箭頭標記 - 效能優化版
	// 為線段添加箭頭標記 - 修正版（不直接顯示）
	function addArrowsToPolyline(polyline, color) {
		const coordinates = polyline.getLatLngs();
		const arrowMarkers = [];
		
		// 🔧 效能優化：根據地圖縮放等級調整密度
		const currentZoom = map.getZoom();
		let arrowInterval;
		
		if (currentZoom >= 16) {
			arrowInterval = 25;
		} else if (currentZoom >= 14) {
			arrowInterval = 50;
		} else {
			arrowInterval = 100;
		}
		
		const totalLength = calculatePolylineLength(coordinates);
		const maxArrows = 10;
		const calculatedInterval = Math.max(arrowInterval, totalLength / maxArrows);
		
		let currentDistance = 0;
		let nextArrowDistance = calculatedInterval / 2;
		let arrowCount = 0;
		
		for (let i = 1; i < coordinates.length && arrowCount < maxArrows; i++) {
			const segmentLength = coordinates[i-1].distanceTo(coordinates[i]);
			
			while (currentDistance + segmentLength >= nextArrowDistance && arrowCount < maxArrows) {
				const ratio = (nextArrowDistance - currentDistance) / segmentLength;
				const arrowPosition = interpolateLatLng(coordinates[i-1], coordinates[i], ratio);
				const bearing = calculateBearing(coordinates[i-1], coordinates[i]);
				
				const arrowMarker = createArrowMarkerOptimized(arrowPosition, bearing, color);
				arrowMarkers.push(arrowMarker);
				
				// 🔧 修正：不直接添加到地圖，只創建箭頭物件
				// 讓 toggleLayer 函數來控制是否顯示
				// arrowLayerGroup.addLayer(arrowMarker); // 移除這行
				
				nextArrowDistance += calculatedInterval;
				arrowCount++;
			}
			
			currentDistance += segmentLength;
		}
		
		return arrowMarkers;
	}
		// 🔧 效能優化版箭頭創建 - 放大1.5倍
		function createArrowMarkerOptimized(position, bearing, color) {
			// 🔧 修改：箭頭尺寸放大1.5倍（從 3px/6px 改為 4.5px/9px）
			const arrowIcon = L.divIcon({
				html: `<div style="width:0;height:0;border-left:4.5px solid transparent;border-right:4.5px solid transparent;border-bottom:9px solid ${color};transform:rotate(${bearing}deg);"></div>`,
				className: 'arrow-icon',
				iconSize: [18, 18],        // 🔧 從 [6, 6] 改為 [9, 9]
				iconAnchor: [9, 18]     // 🔧 從 [3, 6] 改為 [4.5, 9]
			});
			
			// 🔧 效能優化：禁用不必要的互動
			return L.marker(position, { 
				icon: arrowIcon,
				interactive: false  // 禁用點選事件提升效能
			});
		}
	// 🔧 效能優化版箭頭創建
	function createArrowMarkerOptimized(position, bearing, color) {
		// 簡化的箭頭 HTML - 減少 DOM 複雜度
		const arrowIcon = L.divIcon({
			html: `<div style="width:0;height:0;border-left:3px solid transparent;border-right:3px solid transparent;border-bottom:6px solid ${color};transform:rotate(${bearing}deg);"></div>`,
			className: 'arrow-icon',
			iconSize: [6, 6],
			iconAnchor: [3, 6]
		});
		
		// 🔧 效能優化：禁用不必要的互動
		return L.marker(position, { 
			icon: arrowIcon,
			interactive: false  // 禁用點選事件提升效能
		});
	}
		 
	// 計算線段總長度（使用 Leaflet 的 distanceTo 方法）
	function calculatePolylineLength(coordinates) {
		let totalLength = 0;
		for (let i = 1; i < coordinates.length; i++) {
			totalLength += coordinates[i-1].distanceTo(coordinates[i]);
		}
		return totalLength;
	}
			  
	// 在兩點間插值計算位置
	function interpolateLatLng(latlng1, latlng2, ratio) {
		const lat = latlng1.lat + (latlng2.lat - latlng1.lat) * ratio;
		const lng = latlng1.lng + (latlng2.lng - latlng1.lng) * ratio;
		return L.latLng(lat, lng);
	}

	// 計算兩點間的方位角
	function calculateBearing(latlng1, latlng2) {
		const lat1 = latlng1.lat * Math.PI / 180;
		const lat2 = latlng2.lat * Math.PI / 180;
		const deltaLng = (latlng2.lng - latlng1.lng) * Math.PI / 180;
		
		const x = Math.sin(deltaLng) * Math.cos(lat2);
		const y = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
		
		const bearing = Math.atan2(x, y) * 180 / Math.PI;
		return (bearing + 360) % 360; // 確保結果為正值
	}

	// 創建箭頭標記
	function createArrowMarker(position, bearing, color) {
		const arrowIcon = L.divIcon({
			html: `<div class="arrow-marker" style="border-bottom-color: ${color}; transform: rotate(${bearing}deg);"></div>`,
			className: 'arrow-icon',
			iconSize: [8, 8],
			iconAnchor: [4, 8]
		});
		
		return L.marker(position, { icon: arrowIcon });
	}

	// 更新箭頭顏色
	function updateArrowColor(marker, color) {
		const iconElement = marker.getElement();
		if (iconElement) {
			const arrowDiv = iconElement.querySelector('.arrow-marker');
			if (arrowDiv) {
				arrowDiv.style.borderBottomColor = color;
			}
		}
	}
			  
			 // 計算線段長度 - 新函數
				function calculateLineLength(coordinates) {
					if (!coordinates || coordinates.length < 2) return 0;
					
					let totalLength = 0;
					for (let i = 1; i < coordinates.length; i++) {
						const lat1 = coordinates[i-1][0];
						const lng1 = coordinates[i-1][1];
						const lat2 = coordinates[i][0];
						const lng2 = coordinates[i][1];
						
						// 使用 Haversine 公式計算兩點間距離
						const distance = getDistanceFromLatLonInM(lat1, lng1, lat2, lng2);
						totalLength += distance;
					}
					
					return totalLength;
				}
	// Haversine 公式計算兩點間距離（公尺）
	function getDistanceFromLatLonInM(lat1, lon1, lat2, lon2) {
		const R = 6371000; // 地球半徑（公尺）
		const dLat = deg2rad(lat2 - lat1);
		const dLon = deg2rad(lon2 - lon1);
		const a = 
			Math.sin(dLat/2) * Math.sin(dLat/2) +
			Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
			Math.sin(dLon/2) * Math.sin(dLon/2);
		const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
		const d = R * c;
		return d;
	}
			  
		  function deg2rad(deg) {
		return deg * (Math.PI/180);
	}
			 // 建立標記彈出視窗內容 - 移除動畫效果
	// 建立標記彈出視窗內容 - 效能優化版（加入 Opposite 星星檢查）
	function createMarker(deviceData, color) {
    const coords = deviceData.coordinates;
    const props = deviceData.properties;
    
    // 🌟 檢查是否有 Opposite 參數且 FSC 是 114
    const hasOpposite = props.FSC === '114' && props.Opposite && props.Opposite.trim() !== '';
    
    // 根據 FSC 建立簡化圖標（保留你的原始設計）
    const iconConfig = getSimpleDeviceIcon(props);
    
    // 根據 FSC 動態調整圖標大小
    let iconSize = [16, 16];
    let iconAnchor = [8, 8];

    if (props.FSC === '114') {
        iconSize = [24, 24];
        iconAnchor = [12, 12];
    }

    const customIcon = L.divIcon({
        html: iconConfig.html,
        className: 'simple-device-icon',
        iconSize: iconSize,
        iconAnchor: iconAnchor
    });
    
    const marker = L.marker([coords[1], coords[0]], { icon: customIcon });
    
    // 🌟 如果是 FSC 114 且有 Opposite 參數，創建紅色星星標記
    if (hasOpposite) {
        console.log(`⭐ 發現 FSC 114 設備有 Opposite 參數: ID=${props.ID}, Opposite=${props.Opposite}`);
        createOppositeStarMarker([coords[1], coords[0]], props.Opposite);
    }
    
    // 🆕 建立增強版彈出視窗內容（結合原始內容 + Google 功能）
    let popupContent = '<div style="max-width: 320px; font-size: 13px; font-family: Arial, sans-serif;">';
    
    // 🎨 標題區域（保留你的原始設計）
    popupContent += `<div style="background: linear-gradient(135deg, ${color}, ${adjustColor(color, -20)}); color: white; padding: 12px; margin: -10px -10px 15px -10px; border-radius: 8px 8px 0 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">`;
    popupContent += `<h3 style="margin: 0; font-size: 16px; font-weight: bold;">🏗️ ${getDeviceTypeName(props.FSC)}</h3>`;
    popupContent += `<div style="font-size: 12px; opacity: 0.9; margin-top: 4px;">設備ID: ${props.ID || 'N/A'}</div>`;
    popupContent += `</div>`;
    
    popupContent += `<div style="padding: 0 5px;">`;
    
    // 🌟 Opposite 資訊顯示（保留你的原始設計）
    if (hasOpposite) {
        popupContent += `<div style="background: #ffebee; border: 1px solid #f44336; border-radius: 4px; padding: 8px; margin-bottom: 10px;">`;
        popupContent += `<p style="margin: 0; font-weight: bold; color: #c62828;"><span style="color: #ff0000;">⭐</span> Opposite: ${props.Opposite}</p>`;
        popupContent += `</div>`;
    }
    
    // 📊 主要屬性顯示（保留你的原始邏輯）
    const importantProps = [
        { key: 'ID', label: '設備ID' },
        { key: 'Tpclid', label: '台電ID' },
        { key: 'FSC', label: 'FSC代碼' },
        { key: 'Area', label: '區域' },
        { key: 'Feeder', label: '饋線' },
        { key: 'VLevel', label: '電壓等級' },
        { key: 'Location', label: '位置' },
        { key: 'Spec', label: '規格' },
        { key: 'Length', label: '長度' },
        { key: 'Type', label: '類型' },
        { key: 'Phase1', label: '相別1' },
        { key: 'Phase2', label: '相別2' },
        { key: 'Phase3', label: '相別3' },
        { key: 'Capacity1', label: '容量1' },
        { key: 'Capacity2', label: '容量2' },
        { key: 'Capacity3', label: '容量3' },
        { key: 'SupplyType', label: '供電型式' }
    ];
    
    // 顯示重要屬性（保留你的原始處理邏輯）
    const displayedProps = [];
    importantProps.forEach(prop => {
        if (props[prop.key] !== undefined && props[prop.key] !== '' && props[prop.key] !== '0.0') {
            let value = props[prop.key];
            
            // 特殊值處理（保留你的原始邏輯）
            if (prop.key === 'VLevel') {
                if (value === '1') value = '11.4kV';
                else if (value === '2') value = '22.8kV';
                else if (value === '3') value = '特高壓';
            } else if (prop.key.includes('Capacity') && value !== '0.0') {
                value += ' kVA';
            } else if (prop.key === 'Length' && value !== '0.0') {
                value += ' 公尺';
            }
            
            displayedProps.push({ label: prop.label, value: value });
        }
    });
    
    // 用網格顯示屬性
    if (displayedProps.length > 0) {
        popupContent += `<div style="display: grid; grid-template-columns: auto 1fr; gap: 6px 12px; margin-bottom: 12px; font-size: 12px;">`;
        displayedProps.forEach(prop => {
            popupContent += `<strong>${prop.label}:</strong><span>${prop.value}</span>`;
        });
        popupContent += `</div>`;
    }
    
    // 📍 座標顯示（保留你的原始格式）
    popupContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #eee;">';
    popupContent += `<p style="margin: 3px 0; font-size: 11px; color: #666;"><strong>📍 座標:</strong> ${coords[1].toFixed(6)}, ${coords[0].toFixed(6)}</p>`;
    
    // 🔄 迴路資訊顯示（保留你的原始邏輯）
    if (props.SrcLoop || props.DestLoop) {
        popupContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #eee;">';
        popupContent += '<p style="margin: 5px 0 3px 0; font-weight: bold; color: #2c3e50;">🔄 迴路資訊:</p>';
        
        if (props.SrcLoop && props.SrcLoop.Loop) {
            popupContent += `<p style="margin: 2px 0; font-size: 12px;">來源: ${props.SrcLoop.Loop} (${props.SrcLoop.Name || ''})</p>`;
        }
        
        if (props.DestLoop && Array.isArray(props.DestLoop)) {
            props.DestLoop.forEach((dest, index) => {
                if (dest.Loop) {
                    popupContent += `<p style="margin: 2px 0; font-size: 12px;">目標${index + 1}: ${dest.Loop} (${dest.Name || ''})</p>`;
                }
            });
        }
    }
    
    // 🆕 Google 服務按鈕區域
    const lat = coords[1];
    const lng = coords[0];
    const deviceName = props.Name || props.ID || '設備位置';
    
    popupContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #eee;">';
    popupContent += `<div style="margin-top: 12px;">`;
    popupContent += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">`;
    
    // 街景圖按鈕
    popupContent += `<button onclick="openStreetView(${lat}, ${lng})" 
                            style="background: linear-gradient(135deg, #4285f4, #34a853); 
                                   color: white; border: none; padding: 8px 6px; 
                                   border-radius: 6px; cursor: pointer; font-size: 11px; 
                                   font-weight: bold; transition: all 0.2s;
                                   box-shadow: 0 2px 4px rgba(66, 133, 244, 0.3);"
                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(66, 133, 244, 0.4)';"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(66, 133, 244, 0.3)';">
                        🗺️ 街景圖
                    </button>`;
    
    // 導航按鈕
    popupContent += `<button onclick="openNavigation(${lat}, ${lng}, '${encodeURIComponent(deviceName)}')" 
                            style="background: linear-gradient(135deg, #ea4335, #fbbc04); 
                                   color: white; border: none; padding: 8px 6px; 
                                   border-radius: 6px; cursor: pointer; font-size: 11px; 
                                   font-weight: bold; transition: all 0.2s;
                                   box-shadow: 0 2px 4px rgba(234, 67, 53, 0.3);"
                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(234, 67, 53, 0.4)';"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(234, 67, 53, 0.3)';">
                        🧭 導航
                    </button>`;
    
    popupContent += `</div>`;
    
    // 複製座標按鈕
    popupContent += `<button onclick="copyCoordinates(${lat}, ${lng})" 
                            style="width: 100%; background: #6c757d; 
                                   color: white; border: none; padding: 6px; 
                                   border-radius: 4px; cursor: pointer; font-size: 10px;
                                   transition: all 0.2s;"
                            onmouseover="this.style.background='#5a6268';"
                            onmouseout="this.style.background='#6c757d';">
                        📋 複製座標
                    </button>`;
    
    popupContent += `</div>`;
    popupContent += `</div>`;
    popupContent += '</div>';
    
    marker.bindPopup(popupContent, {
        maxWidth: 350,
        className: 'custom-popup'
    });
    
    return marker;
}
// 🆕 開啟 Google 街景圖
function openStreetView(lat, lng) {
    const streetViewUrl = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lat},${lng}`;
    window.open(streetViewUrl, '_blank');
    console.log(`🗺️ 開啟街景圖: ${lat}, ${lng}`);
}

// 🆕 開啟 Google 導航
function openNavigation(lat, lng, name) {
    // 嘗試多種導航方式，優先使用 Google Maps
    const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_place_id=${encodeURIComponent(name)}`;
    
    // 檢測是否為行動裝置
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (isMobile) {
        // 行動裝置優先嘗試開啟 Google Maps App
        const appUrl = `google.navigation:q=${lat},${lng}`;
        const fallbackUrl = googleMapsUrl;
        
        // 嘗試開啟 App，失敗則開啟網頁版
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.src = appUrl;
        document.body.appendChild(iframe);
        
        setTimeout(() => {
            document.body.removeChild(iframe);
            window.open(fallbackUrl, '_blank');
        }, 1000);
    } else {
        // 桌面版直接開啟網頁版 Google Maps
        window.open(googleMapsUrl, '_blank');
    }
    
    console.log(`🧭 開啟導航至: ${name} (${lat}, ${lng})`);
}

// 🆕 複製座標到剪貼簿
function copyCoordinates(lat, lng) {
    const coordinates = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
    
    if (navigator.clipboard && window.isSecureContext) {
        // 現代瀏覽器的剪貼簿 API
        navigator.clipboard.writeText(coordinates).then(() => {
            showToast(`📋 座標已複製: ${coordinates}`, 'success');
        }).catch(err => {
            console.error('複製失敗:', err);
            fallbackCopyText(coordinates);
        });
    } else {
        // 舊版瀏覽器的備用方法
        fallbackCopyText(coordinates);
    }
}

// 🆕 備用複製方法
function fallbackCopyText(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        document.execCommand('copy');
        showToast(`📋 座標已複製: ${text}`, 'success');
    } catch (err) {
        console.error('複製失敗:', err);
        showToast('❌ 複製失敗，請手動複製', 'error');
    }
    
    document.body.removeChild(textArea);
}

// 🆕 顯示載入提示訊息
function showToast(message, type = 'info') {
  // 創建提示元素
  const toast = document.createElement('div');
  toast.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      padding: 12px 20px;
      border-radius: 6px;
      color: white;
      font-weight: bold;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      max-width: 300px;
  `;
  
  // 根據類型設定顏色
  switch(type) {
      case 'success':
          toast.style.background = '#28a745';
          break;
      case 'error':
          toast.style.background = '#dc3545';
          break;
      case 'warning':
          toast.style.background = '#ffc107';
          toast.style.color = '#000';
          break;
      default:
          toast.style.background = '#17a2b8';
  }
  
  toast.textContent = message;
  document.body.appendChild(toast);
  
  // 3秒後自動移除
  setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateX(100%)';
      setTimeout(() => {
          if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
          }
      }, 300);
  }, 3000);
}

// 🆕 顏色調整輔助函數
function adjustColor(color, percent) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    
    return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
}

	// 🌟 修改：創建 Opposite 紅色星星標記 - 調整垂直位置避免遮擋開關
	function createOppositeStarMarker(position, oppositeText) {
		console.log(`⭐ 創建 Opposite 紅色星星標記: ${oppositeText} at`, position);
		
		const starIcon = L.divIcon({
			html: `
				<div class="opposite-star-marker">
					<div class="star-icon">⭐</div>
					<div class="opposite-text">${oppositeText}</div>
				</div>
			`,
			className: 'opposite-star-icon',
			iconSize: [60, 25],   
			iconAnchor: [8, 35]   // 🔧 修改：從 [8, 20] 改為 [8, 35]，讓星星往上偏移更多
		});
		
		const starMarker = L.marker(position, { 
			icon: starIcon,
			zIndexOffset: 1000  // 確保星星顯示在最上層
		});
		
		// 加入到星星圖層群組
		oppositeLayerGroup.addLayer(starMarker);
		
		// 加入到全域星星陣列
		oppositeStarMarkers.push(starMarker);
		
		// 加入點選事件顯示詳細資訊
		starMarker.on('click', function(e) {
			const popup = L.popup()
				.setLatLng(position)
				.setContent(`
					<div style="text-align: center; padding: 5px;">
						<h4 style="margin: 0 0 5px 0; color: #ff0000;">⭐ Opposite 標記</h4>
						<p style="margin: 0; font-weight: bold; color: #c62828;">${oppositeText}</p>
						<p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">FSC 114 開關設備</p>
					</div>
				`)
				.openOn(map);
			
			// 阻止事件冒泡
			L.DomEvent.stopPropagation(e);
		});
		
		return starMarker;
	}
	// 簡化設備圖標 - 效能優化版
	function getSimpleDeviceIcon(props) {
		const fsc = props.FSC || props.fsc || '';
		const baseStyle = `
			width: 12px; 
			height: 12px; 
			display: flex; 
			align-items: center; 
			justify-content: center; 
			font-size: 8px; 
			font-weight: bold;
			border: 1px solid white;
			box-shadow: 0 1px 2px rgba(0,0,0,0.3);
		`;
		
		switch (fsc) {
			case '120': // 接地設備 - 圓圈 + 45度斜線
				return {
					html: `<div style="${baseStyle} 
						background-color: #2c3e50; 
						border-radius: 50%;
						position: relative;
					">
						<div style="
							position: absolute;
							width: 10px;
							height: 1px;
							background-color: white;
							transform: rotate(45deg);
							top: 50%;
							left: 50%;
							margin-left: -5px;
							margin-top: -0.5px;
						"></div>
					</div>`
				};
				
			case '114': // 開關設備 - 🔧 調整圈圈大小
				const switchType = getSwitchType(props);
				return {
					html: `<div style="
						width: 20px; 
						height: 20px; 
						display: flex; 
						align-items: center; 
						justify-content: center; 
						font-size: 12px; 
						font-weight: bold;
						border: 2px solid white;
						box-shadow: 0 2px 4px rgba(0,0,0,0.4);
						background-color: #27ae60; 
						border-radius: 50%;
						color: white;
					">${switchType}</div>`
				};

				
			case '115': // 變壓器 - 三角形 (放大1.5倍)
				return {
					html: `<div style="
						width: 0;
						height: 0;
						border-left: 9px solid transparent;
						border-right: 9px solid transparent;
						border-bottom: 15px solid #3498db;
						filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
					"></div>`
				};

				
			case '106': // 電桿設備 - 深灰色小圓點
				return {
					html: `<div style="
						width: 6px; 
						height: 6px; 
						background-color: #34495e; 
						border-radius: 50%;
						border: 1px solid white;
						box-shadow: 0 1px 2px rgba(0,0,0,0.3);
					"></div>`
				};

			case '108': // 電纜頭 - 大方形 + "變"字
				return {
					html: `<div style="
						width: 20px; 
						height: 20px; 
						background-color: #f39c12; 
						border-radius: 3px;
						border: 2px solid white;
						box-shadow: 0 2px 4px rgba(0,0,0,0.4);
						display: flex;
						align-items: center;
						justify-content: center;
						font-size: 12px;
						font-weight: bold;
						color: white;
						text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
					">變</div>`
				};

				
			case '109': // 電桿標示 - 菱形
				return {
					html: `<div style="
						width: 8px;
						height: 8px;
						background-color: #9b59b6;
						transform: rotate(45deg);
						border: 1px solid white;
						box-shadow: 0 1px 2px rgba(0,0,0,0.3);
					"></div>`
				};
				
			case '110': // 太陽能設備 - 斜放太陽能板
				return {
					html: `<div style="
						width: 12px;
						height: 8px;
						background: linear-gradient(135deg, #3498db 0%, #2980b9 50%, #1f4e79 100%);
						transform: rotate(-15deg) skewX(-10deg);
						border: 1px solid white;
						box-shadow: 0 1px 2px rgba(0,0,0,0.3);
						position: relative;
					">
						<div style="
							position: absolute;
							top: 1px;
							left: 1px;
							right: 1px;
							height: 1px;
							background-color: rgba(255,255,255,0.4);
						"></div>
						<div style="
							position: absolute;
							top: 4px;
							left: 1px;
							right: 1px;
							height: 1px;
							background-color: rgba(255,255,255,0.2);
						"></div>
					</div>`
				};

				
			case '116': // 電桿設備 - 圓點（不同顏色）
				return {
					html: `<div style="${baseStyle} 
						background-color: #8b4513; 
						border-radius: 50%;
					"></div>`
				};
				
			case '131': // 其他設備 - 八角形
				return {
					html: `<div style="
						width: 10px;
						height: 10px;
						background-color: #8e44ad;
						clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
						border: 1px solid white;
						box-shadow: 0 1px 2px rgba(0,0,0,0.3);
					"></div>`
				};
				
			default: // 未知設備 - 簡單圓點
				return {
					html: `<div style="${baseStyle} 
						background-color: #95a5a6; 
						border-radius: 50%;
					"></div>`
				};
		}
	}

	// 🔧 修正：判斷開關類型 - 根據設備屬性返回正確英文字母
	function getSwitchType(props) {
		console.log('🔍 判斷開關類型，設備屬性:', props);
		
		// 根據設備屬性判斷開關類型
		const auto = props.Auto;
		const fuse = props.Fuse;
		const no = props.NO;
		const type = props.Type || '';
		const spec = props.Spec || '';
		const swtype = props.SrcLoop ? props.SrcLoop.Type : undefined;
		
		console.log(`🔍 開關屬性分析: Auto=${auto}, Fuse=${fuse}, NO=${no}, Type="${type}", Spec="${spec}"`);
		console.log(swtype);
		
		// 🔧 修正：判斷邏輯並返回對應英文字母
		if (fuse === true || fuse === '1' || fuse === 1 || type.includes('熔絲') || spec.includes('FUSE')) {
			console.log('✅ 判斷為熔絲 (F)');
			return 'F'; // 熔絲 (Fuse)
		} else if (auto === true || auto === '1' || auto === 1 || type.includes('自動') || spec.includes('AUTO')) {
			console.log('✅ 判斷為自動化開關 (A)');
			return 'A'; // 自動化開關 (Automatic)
		} else if (no === true || no === '1' || no === 1 || type.includes('分段') || spec.includes('SECT') || spec.includes('DISCONNECT') || swtype === 2 ||swtype ==='2') {
			console.log('✅ 判斷為分段開關 (D)');
			return 'D'; // 分段開關 (Disconnector)
		} else if (type.includes('氣封') || spec.includes('SECTIONALIZER') || spec.includes('氣封')) {
			console.log('✅ 判斷為氣封開關 (S)');
			return 'S'; // 氣封開關 (Sectionalizer)
		} else {
			console.log('⚠️ 未知開關類型，使用預設 (S)');
			return 'S'; // 預設為氣封開關 (Switch/Sectionalizer)
		}
	}


	// 取得設備圖標
	// 🔧 修正版：取得設備圖示 - 使用正確的圖示
function getDeviceIcon(fsc) {
    const icons = {
        '106': { 
            url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png', 
            size: [20, 32], 
            anchor: [10, 32] 
        }, // 線路節點
        '108': { 
            url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png', 
            size: [25, 41], 
            anchor: [12, 41] 
        }, // 變電所
        '114': { 
            url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png', 
            size: [20, 32], 
            anchor: [10, 32] 
        }, // 開關設備
        '115': { 
            url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png', 
            size: [20, 32], 
            anchor: [10, 32] 
        }, // 變壓器
        '110': { 
            url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png', 
            size: [20, 32], 
            anchor: [10, 32] 
        }, // 太陽能
        '120': { 
            url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-black.png', 
            size: [18, 29], 
            anchor: [9, 29] 
        }, // 電桿設備
    };
    
    return icons[fsc] || { 
        url: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png', 
        size: [18, 29], 
        anchor: [9, 29] 
    };
}

	// 🔧 修正：取得設備類型名稱 - 配合您的 FSC 分類
	function getDeviceTypeName(fsc) {
		const types = {
			'106': '線路節點',
			'108': '變電所', 
			'109': '電桿標示',
			'110': '太陽能設備',
			'114': '開關設備',
			'115': '變壓器',
			'116': '終端',
			'120': '電桿設備',
			'131': '其他設備'
		};
		return types[fsc] || `FSC-${fsc}` || '未知設備';
	}
			  
	function toggleLayer(categoryKey) {
    const checkbox = document.getElementById(`layer_${categoryKey}`);
    const layerGroup = layerGroups[categoryKey];
    
    if (!layerGroup) return;
    
    if (checkbox.checked) {
        map.addLayer(layerGroup);
        
        // 🔧 修正：顯示該圖層中所有線段的箭頭
        layerGroup.eachLayer(layer => {
            if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                layer.arrowMarkers.forEach(marker => {
                    arrowLayerGroup.addLayer(marker); // 添加到箭頭圖層群組
                });
            }
        });
    } else {
        map.removeLayer(layerGroup);
        
        // 🔧 修正：隱藏該圖層中所有線段的箭頭
        layerGroup.eachLayer(layer => {
            if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                layer.arrowMarkers.forEach(marker => {
                    arrowLayerGroup.removeLayer(marker); // 從箭頭圖層群組移除
                });
            }
        });
    }
}
			  
			// 清除所有圖層 - 完全修改版（加入星星清除）
			function clearAllLayers() {
				console.log('🧹 開始清除所有圖層、箭頭和星星...');
				
				// 清除現有圖層
				Object.values(layerGroups).forEach(layerGroup => {
					if (map.hasLayer(layerGroup)) {
						map.removeLayer(layerGroup);
					}
				});
				
				// 🔧 重要：清除所有箭頭標記
				clearAllArrows();
				
				// 🌟 新增：清除所有星星標記
				clearAllOppositeStars();
				
				// 重置變數
				layerGroups = {};
				selectedLine = null;
				
				console.log('✅ 所有圖層、箭頭和星星已清除');
			}
			
			// 🌟 新增：專門清除星星的函數
	function clearAllOppositeStars() {
		console.log(`🧹 清除 ${oppositeStarMarkers.length} 個星星標記...`);
		
		// 方法1：從圖層群組清除（效能較好）
		if (oppositeLayerGroup) {
			oppositeLayerGroup.clearLayers();
		}
		
		// 方法2：逐一清除（備用方案）
		oppositeStarMarkers.forEach(marker => {
			if (map.hasLayer(marker)) {
				map.removeLayer(marker);
			}
		});
		
		// 重置星星陣列
		oppositeStarMarkers = [];
		
		console.log('✅ 所有星星已清除');
	}
			
			// 🔧 新增：專門清除箭頭的函數
	function clearAllArrows() {
		console.log(`🧹 清除 ${allArrowMarkers.length} 個箭頭標記...`);
		
		// 方法1：從圖層群組清除（效能較好）
		if (arrowLayerGroup) {
			arrowLayerGroup.clearLayers();
		}
		
		// 方法2：逐一清除（備用方案）
		allArrowMarkers.forEach(marker => {
			if (map.hasLayer(marker)) {
				map.removeLayer(marker);
			}
		});
		
		// 重置箭頭陣列
		allArrowMarkers = [];
		
		console.log('✅ 所有箭頭已清除');
	}
			  
			  // 自動縮放到資料範圍
			  function fitMapToData() {
				  const bounds = L.latLngBounds();
				  let hasData = false;
				  
				  // 加入點設備範圍
				  allDevicesData.forEach(device => {
					  const [lng, lat] = device.coordinates;
					  bounds.extend([lat, lng]);
					  hasData = true;
				  });
				  
				  // 加入線段範圍
				  allLinesData.forEach(line => {
					  line.coordinates.forEach(coord => {
						  bounds.extend(coord);
						  hasData = true;
					  });
				  });
				  
				  if (hasData) {
					  // 加入一些邊界填充
					  map.fitBounds(bounds, { padding: [20, 20] });
				  }
			  }
			  
// 🔧 修正版：頁面載入完成後的初始化 - 移除重新載入相關邏輯
// 🔧 修正版：頁面載入完成後的初始化 - 優先處理分享連結
document.addEventListener('DOMContentLoaded', function() {
    // 初始化地圖
    initMap();
    initMobileOptimizations();
    
    // 🔧 重要修正：優先檢查分享連結，然後再載入災情資料
    setTimeout(() => {
        const isDisasterShareLink = handleDisasterShareLink();
        
        if (isDisasterShareLink) {
            // 🔧 如果是災情分享連結，立即載入災情資料
            console.log('🔗 檢測到災情分享連結，優先載入災情資料...');
            loadDisasterData().then(() => {
                // 災情資料載入完成後，再次嘗試開啟分享連結
                setTimeout(() => {
                    handleDisasterShareLink();
                }, 500);
            });
        } else {
            // 🔧 不是災情分享連結，正常載入
            loadMapFromURL();
            
            // 延遲載入災情資料（不阻塞主要功能）
            setTimeout(() => {
                loadDisasterData();
            }, 2000);
        }
    }, 1000);
    
    // 監聽全螢幕變化（不重新載入）
    document.addEventListener('fullscreenchange', function() {
        setTimeout(() => {
            if (map) {
                map.invalidateSize();
                console.log('🗺️ 全螢幕狀態變化，地圖已調整');
            }
        }, 100);
    });
    
    // 監聽視窗大小變化（不重新載入）
    window.addEventListener('resize', function() {
        setTimeout(() => {
            if (map) {
                map.invalidateSize();
                console.log('🗺️ 視窗大小變化，地圖已調整');
            }
        }, 100);
    });
});

			  
			  
// 🆕 修改後的初始化下拉選單函數
// 🔧 修正版：初始化下拉選單函數 - 支援手機版重新初始化
function initializeFeederDropdown() {
    const dropdown = document.getElementById('feederDropdown');
    const inputField = document.getElementById('feederInput');
    
    if (!dropdown || !inputField) {
        console.warn('⚠️ 找不到饋線下拉選單或輸入框');
        return;
    }
    
    // 清空現有選項
    dropdown.innerHTML = '<option value="">選擇饋線</option>';
    
    // 加入饋線選項
    feederList.forEach(feeder => {
        const option = document.createElement('option');
        option.value = feeder;
        option.textContent = feeder;
        dropdown.appendChild(option);
    });
    
    // 🔧 重要：移除舊的事件監聽器（避免重複綁定）
    dropdown.removeEventListener('change', handleDropdownChange);
    inputField.removeEventListener('input', handleInputChange);
    
    // 🔧 重要：重新綁定事件監聽器
    dropdown.addEventListener('change', handleDropdownChange);
    inputField.addEventListener('input', handleInputChange);
    
    console.log(`✅ 下拉選單已初始化，包含 ${feederList.length} 個饋線`);
}

// 🆕 新增：下拉選單變化處理函數
function handleDropdownChange(event) {
    const selectedFeeder = event.target.value;
    const inputField = document.getElementById('feederInput');
    
    console.log('📋 下拉選單選擇:', selectedFeeder);
    
    if (selectedFeeder && inputField) {
        inputField.value = selectedFeeder;
        console.log('✅ 已同步到輸入框:', selectedFeeder);
        
        // 🆕 顯示提示
        showToast(`已選擇饋線: ${selectedFeeder}`, 'info');
    }
}

// 🆕 新增：輸入框變化處理函數
function handleInputChange(event) {
    const inputValue = event.target.value.toUpperCase();
    const dropdown = document.getElementById('feederDropdown');
    
    console.log('⌨️ 輸入框變化:', inputValue);
    
    if (dropdown) {
        // 同步下拉選單選擇
        dropdown.value = feederList.includes(inputValue) ? inputValue : '';
        console.log('✅ 已同步到下拉選單');
    }
}
// 🆕 從雲端載入饋線資料
// 🔧 修正：從雲端載入饋線資料 - 改善 UI 反饋
// 🔧 修正版：載入函數中加入更好的錯誤處理
async function loadFeederFromCloud() {
    const feederInput = document.getElementById('feederInput');
    const feederName = feederInput.value.trim().toUpperCase();
    const loadBtn = document.querySelector('.load-feeder-btn');
    const section = document.querySelector('.feeder-selection-section');
    
    if (!feederName) {
        showToast('請輸入饋線名稱或從下拉選單選擇！', 'error');
        feederInput.focus();
        return;
    }
    
    if (!feederList.includes(feederName)) {
        showToast(`找不到饋線 "${feederName}"，請檢查名稱是否正確！`, 'error');
        feederInput.focus();
        return;
    }
    
    const fileName = `119_${feederName}.json`;
    
    try {
        // 1. 檢查本地儲存
        let jsonData = localStorageManager.loadFromLocal(fileName);
        if (jsonData) {
            await processJsonDataAsync(jsonData, fileName);
            showToast('⚡ 瞬間載入！(本地)', 'success');
            return;
        }
        
        // 2. 檢查記憶體快取
        jsonData = feederCache.get(fileName);
        if (jsonData) {
            await processJsonDataAsync(jsonData, fileName);
            showToast('⚡ 快速載入！(快取)', 'success');
            return;
        }
        
        // 3. 從雲端載入
        loadBtn.disabled = true;
        loadBtn.textContent = '⚡ 饋線載入中...';
        section.classList.add('loading');
        
        const startTime = Date.now();
        updateProgress(0, '準備載入...');
        
        // 🔧 修正：檢查檔案 ID 是否存在
        let fileId;
        try {
            fileId = getFileIdByName(fileName);
        } catch (error) {
            throw new Error(`找不到檔案 ${fileName}：${error.message}`);
        }
        
        const bestUrl = await getBestDownloadUrl(fileId);
        
        updateProgress(10, '建立連線...');
        
        // 🔧 修正：加入更詳細的錯誤處理
        try {
            jsonData = await fastJsonLoader.loadJsonWithStream(bestUrl, (percent, text) => {
                updateProgress(10 + (percent * 0.7), text);
            });
        } catch (loadError) {
            console.error('載入錯誤詳情:', loadError);
            
            if (loadError.message.includes('HTML')) {
                throw new Error('Google Drive 檔案無法直接存取，請檢查檔案權限設定');
            } else if (loadError.message.includes('HTTP 404')) {
                throw new Error(`檔案不存在或已被刪除：${fileName}`);
            } else if (loadError.message.includes('HTTP 403')) {
                throw new Error(`檔案存取權限不足：${fileName}`);
            } else {
                throw new Error(`載入失敗：${loadError.message}`);
            }
        }
        
        updateProgress(85, '處理資料...');
        
        // 4. 儲存到快取和本地
        feederCache.set(fileName, jsonData);
        await localStorageManager.saveToLocal(fileName, jsonData);
        
        updateProgress(95, '渲染地圖...');
        
        // 5. 處理資料
        await processJsonDataAsync(jsonData, fileName);
        
        updateProgress(100, '載入完成！');
        
        const loadTime = ((Date.now() - startTime) / 1000).toFixed(2);
        console.log(`🎉 饋線載入完成: ${loadTime}秒`);
        
        section.classList.add('success');
        showToast(`🚀 載入完成！(${loadTime}秒)`, 'success');
        
        // 背景預載入
        setTimeout(() => preloadAdjacentFeeders(feederName), 1000);
        
    } catch (error) {
        console.error('❌ 饋線載入失敗:', error);
        section.classList.add('error');
        updateProgress(0, '載入失敗');
        showToast(`載入失敗: ${error.message}`, 'error');
        
    } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = '⚡ 載入饋線';
        section.classList.remove('loading');
        
        setTimeout(() => {
            section.classList.remove('success', 'error');
        }, 3000);
    }
}
// 🆕 智慧預載入相鄰饋線
async function preloadAdjacentFeeders(currentFeeder) {
    console.log(`🔮 開始預載入 ${currentFeeder} 的相鄰饋線...`);
    
    const adjacentFeeders = getAdjacentFeeders(currentFeeder);
    const maxPreload = 3;
    const feedersToPreload = adjacentFeeders.slice(0, maxPreload);
    
    console.log(`📋 預載入清單: ${feedersToPreload.join(', ')}`);
    
    feedersToPreload.forEach(async (feeder, index) => {
        try {
            await new Promise(resolve => setTimeout(resolve, index * 1000));
            
            const fileName = `119_${feeder}.json`;
            
            if (feederCache.get(fileName)) {
                console.log(`⚡ ${feeder} 已在快取中，跳過預載入`);
                return;
            }
            
            console.log(`🔮 預載入: ${feeder}`);
            const fileId = getFileIdByName(fileName);
            const bestUrl = await getBestDownloadUrl(fileId);
            const jsonData = await fastJsonLoader.loadJsonWithStream(bestUrl);
            feederCache.set(fileName, jsonData);
            console.log(`✅ 預載入完成: ${feeder}`);
            
        } catch (error) {
            console.log(`⚠️ 預載入失敗: ${feeder} -`, error.message);
        }
    });
}

// 🆕 取得相鄰饋線
function getAdjacentFeeders(currentFeeder) {
    const adjacent = [];
    
    const match = currentFeeder.match(/^(\d+[A-Z]+)(\d+)$/);
    if (!match) return adjacent;
    
    const prefix = match[1];
    const number = parseInt(match[2]);
    
    for (let offset = -2; offset <= 2; offset++) {
        if (offset === 0) continue;
        
        const adjacentNumber = number + offset;
        if (adjacentNumber < 1 || adjacentNumber > 99) continue;
        
        const adjacentFeeder = `${prefix}${adjacentNumber.toString().padStart(2, '0')}`;
        
        if (feederList.includes(adjacentFeeder)) {
            adjacent.push(adjacentFeeder);
        }
    }
    
    return adjacent;
}


// 🆕 檔案名稱對應到 Google Drive 檔案 ID
// 🆕 修改後的 getFileIdByName 函數
function getFileIdByName(fileName) {
    const fileId = feederDataMap[fileName];
    if (!fileId) {
        throw new Error(`找不到檔案 ${fileName} 的 Google Drive ID`);
    }
    return fileId;
}

// 🆕 從 Google Sheet JSON API 載入饋線資料
async function loadFeederDataFromSheet() {
    // 🔧 替換為您的 GAS Web App URL
    const gasWebAppUrl = 'https://script.google.com/macros/s/AKfycby6Bx8OuXitOT-6vWxBcOUrvHgWGQIK_DO9F_Db-10uEwKPjw-Hqd8ka5MvTq3Hh68/exec';
    
    try {
        console.log('🔄 正在從 JSON API 載入饋線資料...');
        
        const response = await fetch(`${gasWebAppUrl}?action=getFeederData&_t=${Date.now()}`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            feederDataMap = result.data.feederMap;
            feederList = result.data.feederList;
            
            console.log(`✅ 成功載入 ${result.data.count} 個饋線資料`);
            console.log('📋 饋線清單:', feederList);
            console.log('🕒 最後更新:', result.data.lastUpdate);
            
            // 初始化下拉選單
            initializeFeederDropdown();
            
            // 更新狀態顯示
            updateLoadStatus(`✅ 已載入 ${result.data.count} 個饋線資料 (${new Date(result.data.lastUpdate).toLocaleString('zh-TW')})`);
            
            return true;
        } else {
            throw new Error(result.error || '載入失敗');
        }
        
    } catch (error) {
        console.error('❌ 載入饋線資料失敗:', error);
        
        // 🔄 使用備用的靜態清單
        console.log('🔄 使用備用饋線清單...');
        feederList = [
            '6A22', '6A23', '6A24', '6A25', '6A31', '6A32', '6A33', '6A34', '6A35',
            '6A41', '6A42', '6A43', '6A44', '6A45', '6A51', '6A52', '6A53', '6A54'
            // ... 其他饋線名稱
        ];
        
        // 建立備用的檔案 ID 對應表（如果有的話）
        feederDataMap = {};
        feederList.forEach(feeder => {
            feederDataMap[`119_${feeder}.json`] = 'backup_file_id'; // 這裡需要實際的檔案 ID
        });
        
        initializeFeederDropdown();
        updateLoadStatus(`⚠️ 使用備用清單 (${feederList.length} 個饋線)`);
        
        return false;
    }
}
// 🆕 新增：檢查 API 健康狀態
async function checkAPIHealth() {
    const gasWebAppUrl = 'https://script.google.com/macros/s/您的GAS_DEPLOYMENT_ID/exec';
    
    try {
        const response = await fetch(`${gasWebAppUrl}?action=health`);
        const result = await response.json();
        
        if (result.success) {
            console.log('✅ API 健康狀態良好:', result.data);
            return true;
        } else {
            console.warn('⚠️ API 健康檢查失敗:', result.error);
            return false;
        }
    } catch (error) {
        console.error('❌ API 健康檢查錯誤:', error);
        return false;
    }
}

// 🆕 建立進度條
function createProgressBar() {
    const progressHtml = `
        <div id="loadProgress" style="display: none; margin: 10px 0;">
            <div style="background: #e9ecef; border-radius: 10px; overflow: hidden; height: 8px;">
                <div id="progressBar" style="background: linear-gradient(90deg, #28a745, #20c997); 
                     height: 100%; width: 0%; transition: width 0.3s ease;"></div>
            </div>
            <div id="progressText" style="text-align: center; font-size: 12px; color: #666; margin-top: 4px;">
                載入中...
            </div>
        </div>
    `;
    
    const section = document.querySelector('.feeder-selection-section');
    if (section && !document.getElementById('loadProgress')) {
        section.insertAdjacentHTML('beforeend', progressHtml);
    }
}

// 🆕 更新進度
function updateProgress(percent, text) {
    const progressDiv = document.getElementById('loadProgress');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    
    if (progressDiv && progressBar && progressText) {
        progressDiv.style.display = 'block';
        progressBar.style.width = `${percent}%`;
        progressText.textContent = text;
        
        if (percent >= 100) {
            setTimeout(() => {
                progressDiv.style.display = 'none';
            }, 1000);
        }
    }
}
// 🆕 取得最佳下載 URL
// 🔧 修正版：取得最佳下載 URL
async function getBestDownloadUrl(fileId) {
    // 🆕 使用 GAS 作為代理伺服器
    const gasWebAppUrl = 'https://script.google.com/macros/s/AKfycby6Bx8OuXitOT-6vWxBcOUrvHgWGQIK_DO9F_Db-10uEwKPjw-Hqd8ka5MvTq3Hh68/exec';
    
    const proxyUrl = `${gasWebAppUrl}?action=getFileContent&fileId=${fileId}`;
    
    console.log(`🎯 使用 GAS 代理載入: ${fileId}`);
    return proxyUrl;
}

// 🆕 非同步處理 JSON 資料
async function processJsonDataAsync(jsonData, fileName) {
    return new Promise((resolve) => {
        const processChunk = (deadline) => {
            const startTime = performance.now();
            
            try {
                processJsonData(jsonData, fileName);
                resolve();
            } catch (error) {
                if (performance.now() - startTime > 16) {
                    console.log('🔄 分割處理大型資料...');
                    setTimeout(() => processChunk({ timeRemaining: () => 50 }), 0);
                } else {
                    throw error;
                }
            }
        };
        
        if (window.requestIdleCallback) {
            requestIdleCallback(processChunk);
        } else {
            setTimeout(() => processChunk({ timeRemaining: () => 50 }), 0);
        }
    });
}
// 🆕 預載入熱門饋線
async function preloadPopularFeeders() {
    const popularFeeders = ['6A22', '6A23', '6A24', '6A25'];
    
    console.log('🔥 預載入熱門饋線...');
    showToast('🔥 開始預載入熱門饋線...', 'info');
    
    let successful = 0;
    for (const feeder of popularFeeders) {
        try {
            const fileName = `119_${feeder}.json`;
            if (feederCache.get(fileName)) continue;
            
            const fileId = getFileIdByName(fileName);
            const bestUrl = await getBestDownloadUrl(fileId);
            const jsonData = await fastJsonLoader.loadJsonWithStream(bestUrl);
            feederCache.set(fileName, jsonData);
            successful++;
        } catch (error) {
            console.warn(`預載入 ${feeder} 失敗:`, error);
        }
    }
    
    showToast(`🔥 已預載入 ${successful} 個熱門饋線`, 'success');
}

// 🆕 顯示快取狀態
function showCacheStats() {
    const stats = feederCache.getStats();
    const localSize = localStorageManager.getStorageSize();
    
    const message = `📊 快取狀態報告\n\n` +
                   `記憶體快取: ${stats.count} 個檔案\n` +
                   `快取大小: ${(stats.totalSize / 1024).toFixed(1)} KB\n` +
                   `本地儲存: ${(localSize / 1024).toFixed(1)} KB\n\n` +
                   `快取檔案:\n${stats.items.join('\n')}`;
    
    alert(message);
}

// 🆕 快取管理系統
class FeederCache {
    constructor() {
        this.cache = new Map();
        this.maxCacheSize = 10;
        this.cacheExpiry = 30 * 60 * 1000; // 30分鐘過期
    }
    
    set(fileName, data) {
        const cacheData = {
            data: data,
            timestamp: Date.now(),
            size: JSON.stringify(data).length
        };
        
        if (this.cache.size >= this.maxCacheSize) {
            const oldestKey = this.cache.keys().next().value;
            this.cache.delete(oldestKey);
            console.log(`🗑️ 移除舊快取: ${oldestKey}`);
        }
        
        this.cache.set(fileName, cacheData);
        console.log(`💾 快取已儲存: ${fileName} (${(cacheData.size/1024).toFixed(1)}KB)`);
    }
    
    get(fileName) {
        const cached = this.cache.get(fileName);
        if (!cached) return null;
        
        if (Date.now() - cached.timestamp > this.cacheExpiry) {
            this.cache.delete(fileName);
            console.log(`⏰ 快取已過期: ${fileName}`);
            return null;
        }
        
        console.log(`⚡ 使用快取: ${fileName}`);
        return cached.data;
    }
    
    clear() {
        this.cache.clear();
        console.log('🧹 已清除所有快取');
    }
    
    getStats() {
        const totalSize = Array.from(this.cache.values())
            .reduce((sum, item) => sum + item.size, 0);
        
        return {
            count: this.cache.size,
            totalSize: totalSize,
            items: Array.from(this.cache.keys())
        };
    }
}

// 🆕 高效 JSON 處理類別
// 🔧 修正版：高效 JSON 處理類別
class FastJsonLoader {
    constructor() {
        this.chunkSize = 1024 * 64;
        this.timeout = 10000;
    }
    
    async loadJsonWithStream(url, onProgress = null) {
        console.log('🌊 啟動載入...');
        const startTime = Date.now();
        
        try {
            // 🔧 檢查是否為 GAS 代理 URL
            if (url.includes('script.google.com')) {
                return await this.loadFromGASProxy(url, onProgress);
            } else {
                return await this.loadDirectly(url, onProgress);
            }
            
        } catch (error) {
            console.error('❌ 載入失敗:', error);
            throw error;
        }
    }
    
    // 🆕 從 GAS 代理載入
    async loadFromGASProxy(url, onProgress = null) {
        console.log('🔄 使用 GAS 代理載入...');
        
        if (onProgress) onProgress(10, '連接 GAS 代理...');
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        if (onProgress) onProgress(50, '接收資料...');
        
        const result = await response.json();
        
        if (onProgress) onProgress(80, '解析資料...');
        
        if (!result.success) {
            throw new Error(result.error || '載入失敗');
        }
        
        if (onProgress) onProgress(100, '載入完成');
        
        console.log(`✅ GAS 代理載入成功: ${result.data.fileName}`);
        return result.data.data; // 返回實際的 JSON 資料
    }
    
    // 🆕 直接載入（備用方案）
    async loadDirectly(url, onProgress = null) {
        console.log('🔄 直接載入...');
        
        const response = await fetch(url, {
            headers: {
                'Cache-Control': 'no-cache',
                'Accept': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const contentLength = response.headers.get('content-length');
        const total = contentLength ? parseInt(contentLength) : 0;
        let loaded = 0;
        
        const reader = response.body.getReader();
        const chunks = [];
        
        while (true) {
            const { done, value } = await reader.read();
            
            if (done) break;
            
            chunks.push(value);
            loaded += value.length;
            
            if (onProgress && total > 0) {
                const percent = Math.round((loaded / total) * 100);
                onProgress(percent, `載入中... ${this.formatBytes(loaded)}/${this.formatBytes(total)}`);
            }
        }
        
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const combined = new Uint8Array(totalLength);
        let offset = 0;
        
        for (const chunk of chunks) {
            combined.set(chunk, offset);
            offset += chunk.length;
        }
        
        const text = new TextDecoder().decode(combined);
        
        // 🔧 檢查是否為 HTML（Google Drive 登入頁面）
        if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
            throw new Error('收到 HTML 回應而非 JSON 檔案，可能需要登入 Google Drive');
        }
        
        const jsonData = JSON.parse(text);
        
        const loadTime = ((Date.now() - Date.now()) / 1000).toFixed(2);
        console.log(`⚡ 直接載入完成: ${loadTime}秒, 大小: ${this.formatBytes(totalLength)}`);
        
        return jsonData;
    }
    
    formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }
}

// 🆕 本地儲存管理
class LocalStorageManager {
    constructor() {
        this.prefix = 'feeder_';
        this.maxSize = 50 * 1024 * 1024; // 50MB 限制
    }
    
    async saveToLocal(fileName, data) {
        try {
            const compressed = this.compressData(data);
            const key = this.prefix + fileName;
            
            if (this.getStorageSize() + compressed.length > this.maxSize) {
                this.cleanOldData();
            }
            
            localStorage.setItem(key, compressed);
            localStorage.setItem(key + '_timestamp', Date.now().toString());
            
            console.log(`💾 已儲存到本地: ${fileName}`);
            
        } catch (error) {
            console.warn('⚠️ 本地儲存失敗:', error);
        }
    }
    
    loadFromLocal(fileName) {
        try {
            const key = this.prefix + fileName;
            const compressed = localStorage.getItem(key);
            const timestamp = localStorage.getItem(key + '_timestamp');
            
            if (!compressed || !timestamp) return null;
            
            const age = Date.now() - parseInt(timestamp);
            if (age > 24 * 60 * 60 * 1000) {
                this.removeFromLocal(fileName);
                return null;
            }
            
            const data = this.decompressData(compressed);
            console.log(`📱 從本地載入: ${fileName}`);
            return data;
            
        } catch (error) {
            console.warn('⚠️ 本地載入失敗:', error);
            return null;
        }
    }
    
    compressData(data) {
        return JSON.stringify(data);
    }
    
    decompressData(compressed) {
        return JSON.parse(compressed);
    }
    
    getStorageSize() {
        let total = 0;
        for (let key in localStorage) {
            if (key.startsWith(this.prefix)) {
                total += localStorage[key].length;
            }
        }
        return total;
    }
    
    cleanOldData() {
        const items = [];
        for (let key in localStorage) {
            if (key.startsWith(this.prefix) && key.endsWith('_timestamp')) {
                const timestamp = parseInt(localStorage[key]);
                items.push({ key: key.replace('_timestamp', ''), timestamp });
            }
        }
        
        items.sort((a, b) => a.timestamp - b.timestamp);
        const toRemove = items.slice(0, Math.ceil(items.length / 3));
        
        toRemove.forEach(item => {
            localStorage.removeItem(item.key);
            localStorage.removeItem(item.key + '_timestamp');
        });
        
        console.log(`🧹 清理了 ${toRemove.length} 個舊檔案`);
    }
    
    removeFromLocal(fileName) {
        const key = this.prefix + fileName;
        localStorage.removeItem(key);
        localStorage.removeItem(key + '_timestamp');
    }
}


let isFollowingLocation = false; // 改名
let locationWatchId = null; // 改名
let lastKnownPosition = null; // 新增

// 新增：測量工具相關變數
let measureDistanceMode = false;
let measureMarkers = [];
let measureLines = [];

// 修改主要切換函數
function toggleFollowLocation() {
    console.log('📱 切換跟隨位置，當前狀態:', isFollowingLocation);
    
    if (!isFollowingLocation) {
        startFollowingLocation();
    } else {
        stopFollowingLocation();
    }
}

// 新的跟隨位置函數
function startFollowingLocation() {
    console.log('📱 開始跟隨裝置位置...');
    
    // 檢查定位支援
    if (!navigator.geolocation) {
        showToast('❌ 您的裝置不支援定位功能', 'error');
        return;
    }
    
    isFollowingLocation = true;
    
    // 更新按鈕狀態
    const btn = document.getElementById('followLocationBtn');
    if (btn) {
        btn.classList.add('active');
        btn.textContent = '🛑 停止跟隨';
        btn.style.backgroundColor = '#dc3545';
        btn.style.color = 'white';
    }
    
    // 開始監控位置變化
    locationWatchId = navigator.geolocation.watchPosition(
        function(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const currentPosition = L.latLng(lat, lng);
            
            console.log(`📍 位置更新: ${lat.toFixed(6)}, ${lng.toFixed(6)}, 精度: ${accuracy}m`);
            
            // 檢查位置變化是否足夠大
            if (lastKnownPosition && lastKnownPosition.distanceTo(currentPosition) < 10) {
                return; // 變化太小，不更新
            }
            
            lastKnownPosition = currentPosition;
            
            // 更新或創建位置標記
            if (!userLocationMarker) {
                const locationIcon = L.divIcon({
                    html: '<div class="location-marker"><div class="center-dot"></div></div>',
                    className: 'custom-location-icon',
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                userLocationMarker = L.marker([lat, lng], {
                    icon: locationIcon,
                    zIndexOffset: 1000
                }).addTo(map);
            } else {
                userLocationMarker.setLatLng([lat, lng]);
            }
            
            // 平滑移動地圖到新位置
            map.flyTo([lat, lng], Math.max(map.getZoom(), 16), {
                duration: 1.5,
                easeLinearity: 0.25
            });
            
            //showToast(`📍 位置已更新 (精度: ${accuracy.toFixed(0)}m)`, 'info');
        },
        function(error) {
            console.error('位置監控錯誤:', error);
            let errorMessage = '❌ 位置監控失敗';
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage = '❌ 定位權限被拒絕';
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage = '❌ 位置資訊無法取得';
                    break;
                case error.TIMEOUT:
                    errorMessage = '❌ 定位請求超時';
                    break;
            }
            
            showToast(errorMessage, 'error');
            stopFollowingLocation();
        },
        {
            enableHighAccuracy: true,
            maximumAge: 5000,        // 5秒內的位置可重複使用
            timeout: 15000           // 15秒超時
        }
    );
    
    showToast('📱 開始跟隨裝置位置', 'success');
}

function stopFollowingLocation() {
    console.log('🛑 停止跟隨裝置位置...');
    
    if (locationWatchId) {
        navigator.geolocation.clearWatch(locationWatchId);
        locationWatchId = null;
    }
    
    isFollowingLocation = false;
    lastKnownPosition = null;
    
    // 重置按鈕狀態
    const btn = document.getElementById('followLocationBtn');
    if (btn) {
        btn.classList.remove('active');
        btn.textContent = '📱 跟隨位置';
        btn.style.backgroundColor = '';
        btn.style.color = '';
    }
    
    showToast('🛑 已停止跟隨裝置位置', 'info');
}




// 新增：圖層切換功能
function initializeLayerSwitcher() {
    const baseLayerRadios = document.querySelectorAll('input[name="baseLayer"]');
    
    baseLayerRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            if (this.checked) {
                switchBaseLayer(this.value);
            }
        });
    });
}

function switchBaseLayer(layerName) {
    // 移除當前基礎圖層
    if (window.currentBaseLayer) {
        map.removeLayer(window.currentBaseLayer);
    }
    
    // 加入新的基礎圖層
    if (window.mapLayers[layerName]) {
        window.currentBaseLayer = window.mapLayers[layerName].addTo(map);
        console.log(`🗺️ 切換到圖層: ${layerName}`);
        showToast(`🗺️ 已切換到 ${getLayerDisplayName(layerName)}`, 'success');
    }
}

function getLayerDisplayName(layerName) {
    const names = {
        googleStreets: 'Google 街景圖',
        googleSatellite: 'Google 衛星影像',
        googleHybrid: 'Google 混合圖',
        openStreetMap: 'OpenStreetMap',
        nlscMap: '國土測繪電子地圖',
        nlscPhoto: '國土測繪正射影像',
        cartoDB: 'CartoDB 淡色',
        stamen: 'Stamen 黑白',
        esriSatellite: 'Esri 衛星影像'
    };
    return names[layerName] || layerName;
}

// 新增：疊加圖層控制
function toggleTrafficLayer() {
    const checkbox = document.getElementById('trafficLayer');
    
    if (checkbox.checked) {
        // 加入交通路況圖層（使用 Google 交通資訊）
        if (!window.overlayLayers.traffic) {
            window.overlayLayers.traffic = L.tileLayer('https://{s}.google.com/vt/lyrs=h@{time}&x={x}&y={y}&z={z}', {
                maxZoom: 22,
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                time: Date.now(),
                opacity: 0.7
            });
        }
        window.overlayLayers.traffic.addTo(map);
        showToast('🚦 已開啟交通路況', 'info');
    } else {
        if (window.overlayLayers.traffic) {
            map.removeLayer(window.overlayLayers.traffic);
        }
        showToast('🚦 已關閉交通路況', 'info');
    }
}

function toggleWeatherLayer() {
    const checkbox = document.getElementById('weatherLayer');
    
    if (checkbox.checked) {
        // 加入天氣雷達圖層
        if (!window.overlayLayers.weather) {
            window.overlayLayers.weather = L.tileLayer('https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=YOUR_API_KEY', {
                maxZoom: 22,
                opacity: 0.6,
                attribution: '© OpenWeatherMap'
            });
        }
        window.overlayLayers.weather.addTo(map);
        showToast('🌧️ 已開啟天氣雷達', 'info');
    } else {
        if (window.overlayLayers.weather) {
            map.removeLayer(window.overlayLayers.weather);
        }
        showToast('🌧️ 已關閉天氣雷達', 'info');
    }
}

function toggleTerrainLayer() {
    const checkbox = document.getElementById('terrainLayer');
    
    if (checkbox.checked) {
        // 加入地形等高線圖層
        if (!window.overlayLayers.terrain) {
            window.overlayLayers.terrain = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                maxZoom: 22,
                opacity: 0.5,
                attribution: '© OpenTopoMap'
            });
        }
        window.overlayLayers.terrain.addTo(map);
        showToast('🏔️ 已開啟地形等高線', 'info');
    } else {
        if (window.overlayLayers.terrain) {
            map.removeLayer(window.overlayLayers.terrain);
        }
        showToast('🏔️ 已關閉地形等高線', 'info');
    }
}

// 新增：調整圖層透明度
function adjustLayerOpacity(value) {
    const opacity = value / 100;
    document.getElementById('opacityValue').textContent = value + '%';
    
    if (window.currentBaseLayer) {
        window.currentBaseLayer.setOpacity(opacity);
    }
}

// 🔧 修正版：全螢幕功能 - 移除重新載入邏輯
function toggleFullscreen() {
    const btn = document.querySelector('.fullscreen-btn');
    
    if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
        // 進入全螢幕
        const element = document.documentElement;
        
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
        
    } else {
        // 退出全螢幕
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
}

// 🔧 修正版：全螢幕狀態變化處理 - 移除重新載入
function handleFullscreenChange() {
    const btn = document.querySelector('.fullscreen-btn');
    const body = document.body;
    
    const isFullscreen = !!(document.fullscreenElement || 
                           document.webkitFullscreenElement || 
                           document.mozFullScreenElement || 
                           document.msFullscreenElement);
    
    if (isFullscreen) {
        // 進入全螢幕模式
        btn.textContent = '🔳 退出全螢幕';
        btn.title = '點擊退出全螢幕模式 (或按 ESC)';
        body.classList.add('fullscreen-mode');
        showToast('🔲 已進入全螢幕模式，點擊左上角按鈕或按 ESC 退出', 'info');
        
        // 🔧 調整地圖大小但不重新載入
        setTimeout(() => {
            if (map) {
                map.invalidateSize();
                console.log('🗺️ 地圖大小已調整（全螢幕模式）');
            }
        }, 100);
        
    } else {
        // 退出全螢幕模式
        btn.textContent = '🔲 全螢幕';
        btn.title = '點擊進入全螢幕模式';
        body.classList.remove('fullscreen-mode');
        showToast('🔳 已退出全螢幕模式', 'info');
        
        // 🔧 調整地圖大小但不重新載入
        setTimeout(() => {
            if (map) {
                map.invalidateSize();
                console.log('🗺️ 地圖大小已調整（一般模式）');
            }
        }, 100);
    }
}


// 🆕 綁定全螢幕事件監聽器
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);

// 🆕 ESC 鍵退出全螢幕提示
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && (document.fullscreenElement || document.webkitFullscreenElement)) {
        showToast('🔳 按 ESC 鍵退出全螢幕', 'info');
    }
});
// 新增：測量工具初始化
function initializeMeasureTools() {
    // 初始化測量相關的地圖事件監聽
    map.on('click', handleMapClick);
}

function toggleMeasureDistance() {
    const btn = document.getElementById('measureDistanceBtn');
    
    if (measureDistanceMode) {
        measureDistanceMode = false;
        btn.classList.remove('active');
        btn.textContent = '📏 測距';
        map.getContainer().style.cursor = '';
    } else {
        measureDistanceMode = true;
        measureAreaMode = false;
        btn.classList.add('active');
        btn.textContent = '⏹️ 停止測距';
        document.getElementById('measureAreaBtn').classList.remove('active');
        document.getElementById('measureAreaBtn').textContent = '📐 測面積';
        map.getContainer().style.cursor = 'crosshair';
        showToast('📏 點擊地圖開始測距', 'info');
    }
}

function handleMapClick(e) {
    if (measureDistanceMode) {
        addMeasurePoint(e.latlng, 'distance');
    }
}

function addMeasurePoint(latlng, type) {
    const marker = L.circleMarker(latlng, {
        radius: 5,
        fillColor: '#ff0000',
        color: '#ffffff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.8
    }).addTo(map);
    
    measureMarkers.push(marker);
    
    if (measureMarkers.length >= 2) {
        drawDistanceLine();
    }
}


function drawDistanceLine() {
    if (measureMarkers.length < 2) return;
    
    const points = measureMarkers.map(marker => marker.getLatLng());
    const line = L.polyline(points, {color: 'red', weight: 3}).addTo(map);
    measureLines.push(line);
    
    // 計算總距離
    let totalDistance = 0;
    for (let i = 1; i < points.length; i++) {
        totalDistance += points[i-1].distanceTo(points[i]);
    }
    
    const distanceText = totalDistance > 1000 ? 
        `${(totalDistance/1000).toFixed(2)} 公里` : 
        `${totalDistance.toFixed(0)} 公尺`;
    
    // 在線段中點顯示距離
    const midpoint = points[Math.floor(points.length/2)];
    const popup = L.popup()
        .setLatLng(midpoint)
        .setContent(`📏 距離: ${distanceText}`)
        .openOn(map);
}



function clearMeasurements() {
    // 清除所有測量標記
    measureMarkers.forEach(marker => map.removeLayer(marker));
    measureMarkers = [];
    
    // 清除所有測量線段
    measureLines.forEach(line => map.removeLayer(line));
    measureLines = [];
    
    // 關閉測量模式
    measureDistanceMode = false;
    
    // 重置按鈕狀態
    document.getElementById('measureDistanceBtn').classList.remove('active');
    document.getElementById('measureDistanceBtn').textContent = '📏 測距';
    
    // 重置滑鼠游標
    map.getContainer().style.cursor = '';
    
    // 關閉所有彈出視窗
    map.closePopup();
    
    showToast('🗑️ 已清除所有測量', 'info');
}






// 新增：從 URL 載入地圖位置
function loadMapFromURL() {
    const hash = window.location.hash.substring(1);
    if (hash) {
        const parts = hash.split('/');
        if (parts.length >= 3) {
            const zoom = parseFloat(parts[0]);
            const lat = parseFloat(parts[1]);
            const lng = parseFloat(parts[2]);
            const bearing = parts[3] ? parseFloat(parts[3]) : 0;
            
            if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lng)) {
                map.setView([lat, lng], zoom);
                if (!isNaN(bearing)) {
                    setMapRotation(bearing);
                }
            }
        }
    }
}


// 新增：自訂標記功能
let customMarkers = [];

function addCustomMarker(lat, lng) {
    const markerText = prompt('請輸入標記名稱:', '自訂標記');
    if (markerText) {
        const marker = L.marker([lat, lng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        marker.bindPopup(`
            <div style="text-align: center;">
                <h4>📌 ${markerText}</h4>
                <p><strong>座標:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                <button onclick="removeCustomMarker(this)" data-marker-id="${customMarkers.length}"
                        style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">
                    🗑️ 刪除標記
                </button>
            </div>
        `).openPopup();
        
        customMarkers.push(marker);
        showToast(`📌 已新增標記: ${markerText}`, 'success');
    }
}

function removeCustomMarker(button) {
    const markerId = parseInt(button.getAttribute('data-marker-id'));
    if (customMarkers[markerId]) {
        map.removeLayer(customMarkers[markerId]);
        customMarkers[markerId] = null;
        map.closePopup();
        showToast('🗑️ 已刪除標記', 'info');
    }
}

// 新增：批次清除自訂標記
function clearAllCustomMarkers() {
    customMarkers.forEach(marker => {
        if (marker) {
            map.removeLayer(marker);
        }
    });
    customMarkers = [];
    showToast('🗑️ 已清除所有自訂標記', 'info');
}

// 新增：匯出地圖為圖片功能
function exportMapAsImage() {
    // 使用 html2canvas 或類似庫來截圖
    // 這裡提供一個簡化版本
    showToast('📸 地圖截圖功能開發中...', 'info');
}

// 新增：分享地圖位置功能
function shareMapLocation() {
    const center = map.getCenter();
    const zoom = map.getZoom();
    const bearing = currentRotation;
    
    const shareUrl = `${window.location.origin}${window.location.pathname}#${zoom}/${center.lat.toFixed(6)}/${center.lng.toFixed(6)}/${bearing}`;
    
    if (navigator.share) {
        navigator.share({
            title: '饋線圖地圖位置',
            text: `查看這個地圖位置 (縮放: ${zoom}, 方位: ${Math.round(bearing)}°)`,
            url: shareUrl
        });
    } else {
        // 備用方案：複製到剪貼簿
        navigator.clipboard.writeText(shareUrl).then(() => {
            showToast('🔗 地圖位置連結已複製到剪貼簿', 'success');
        });
    }
}

// 頁面載入完成後的額外初始化
document.addEventListener('DOMContentLoaded', function() {
    // 載入 URL 中的地圖位置
    setTimeout(loadMapFromURL, 1000);
    
    // 監聽全螢幕變化
    document.addEventListener('fullscreenchange', function() {
        setTimeout(() => {
            map.invalidateSize();
        }, 100);
    });
    
    // 監聽視窗大小變化
    window.addEventListener('resize', function() {
        setTimeout(() => {
            map.invalidateSize();
        }, 100);
    });
});

// 圖層選單控制
function toggleLayerMenu() {
    const menu = document.getElementById('layerMenu');
    const isVisible = menu.style.display !== 'none';
    menu.style.display = isVisible ? 'none' : 'block';
}



// 🆕 新增：疊加圖層控制函數
// 🔧 修改：移除 checkbox 依賴的版本
function toggleOverlayLayer(layerName, forceState = null) {
    const layer = window.overlayLayers[layerName];
    if (!layer) {
        console.warn(`找不到圖層: ${layerName}`);
        showToast(`❌ 圖層 ${layerName} 暫時無法使用`, 'error');
        return;
    }
    
    // 檢查圖層是否已在地圖上
    const isLayerOnMap = map.hasLayer(layer);
    const shouldAdd = forceState !== null ? forceState : !isLayerOnMap;
    
    if (shouldAdd && !isLayerOnMap) {
        layer.addTo(map);
        showToast(`✅ 已開啟 ${getOverlayDisplayName(layerName)}`, 'success');
        console.log(`🗺️ 開啟圖層: ${layerName}`);
    } else if (!shouldAdd && isLayerOnMap) {
        map.removeLayer(layer);
        showToast(`❌ 已關閉 ${getOverlayDisplayName(layerName)}`, 'info');
        console.log(`🗺️ 關閉圖層: ${layerName}`);
    }
    
    return !isLayerOnMap; // 回傳新的狀態
}

// 🆕 新增：直接控制圖層的便利函式
function showOverlayLayer(layerName) {
    return toggleOverlayLayer(layerName, true);
}

function hideOverlayLayer(layerName) {
    return toggleOverlayLayer(layerName, false);
}

// 🆕 新增：批次控制圖層
function toggleMultipleLayers(layerNames, state = null) {
    layerNames.forEach(layerName => {
        toggleOverlayLayer(layerName, state);
    });
}


// 🆕 新增：取得疊加圖層顯示名稱
function getOverlayDisplayName(layerName) {
    const names = {
        roadNetwork: '路網圖層',
        railway: '鐵路圖層',
        landmark: '公有土地圖',
        cadastre: '行政區界圖',
        section: '段籍圖',
        village: '村里界圖',
        wayMeter: '公路里程標誌',
        kaohsiungSlope: '高雄山坡地範圍',
        urbanPlan: '高雄市都市計畫圖',
        urbanPlanBoundary: '高雄市都市計畫範圍圖',
        trafficNetwork: '國土計畫圖'
    };
    return names[layerName] || layerName;
}


// 🆕 手機版導航功能
// 🔧 修正版：手機版導航初始化 - 加入事件綁定檢查
function initMobileNavigation() {
  console.log('📱 初始化手機版導航...');
  
  // 檢查是否為手機版
  const isMobile = window.innerWidth <= 768;
  if (!isMobile) {
      console.log('🖥️ 非手機版，跳過手機導航初始化');
      return;
  }
  
  const mobileNav = document.querySelector('.mobile-nav');
  const sidebar = document.querySelector('.sidebar');
  const mapContainer = document.querySelector('.map-container');
  
  if (!mobileNav || !sidebar || !mapContainer) {
      console.error('❌ 手機版導航元素未找到');
      return;
  }
  
  // 🆕 檢查關鍵控制元素是否存在
  const feederInput = document.getElementById('feederInput');
  const feederDropdown = document.getElementById('feederDropdown');
  
  if (!feederInput || !feederDropdown) {
      console.warn('⚠️ 關鍵控制元素尚未就緒，延遲初始化');
      setTimeout(initMobileNavigation, 200);
      return;
  }
  
  // 立即啟用導航功能
  mobileNav.style.display = 'flex';
  
  // 預設顯示地圖
  showMobileTab('map');
  
  // 綁定導航標籤點擊事件
  const navTabs = mobileNav.querySelectorAll('.nav-tab');
  navTabs.forEach(tab => {
      // 🔧 移除舊的事件監聽器（避免重複綁定）
      tab.removeEventListener('click', handleTabClick);
      
      // 重新綁定事件
      tab.addEventListener('click', handleTabClick);
  });
  
  console.log('✅ 手機版導航初始化完成');
}
// 🆕 標籤點擊處理函數
function handleTabClick(event) {
    const tabName = event.target.dataset.tab;
    const navTabs = document.querySelectorAll('.nav-tab');
    
    // 移除所有啟用狀態
    navTabs.forEach(t => t.classList.remove('active'));
    
    // 啟用當前標籤
    event.target.classList.add('active');
    
    // 顯示對應內容
    showMobileTab(tabName);
    
    console.log(`📱 切換到標籤: ${tabName}`);
}

// 🆕 顯示手機版標籤內容
function showMobileTab(tabName) {
  const sidebar = document.querySelector('.sidebar');
  const mapContainer = document.querySelector('.map-container');
  
  if (!sidebar || !mapContainer) return;
  
  // 隱藏所有內容
  sidebar.style.display = 'none';
  mapContainer.style.display = 'none';
  
  switch(tabName) {
      case 'map':
          mapContainer.style.display = 'block';
          break;
          
      case 'controls':
      case 'info':
          sidebar.style.display = 'block';
          // 🆕 如果是控制或資訊標籤，可以滾動到特定區域
          if (tabName === 'info' && currentFeederInfo) {
              const feederInfo = document.getElementById('feederInfo');
              if (feederInfo) {
                  feederInfo.scrollIntoView({ behavior: 'smooth' });
              }
          }
          break;
  }
}


// 🔧 修正版：重新初始化所有控制項 - 確保事件綁定
function reinitializeControls() {
    console.log('🔄 開始重新初始化控制項...');
    
    try {
        // 1. 重新初始化饋線下拉選單
        if (typeof initializeFeederDropdown === 'function' && feederList && feederList.length > 0) {
            initializeFeederDropdown();
            console.log('✅ 饋線下拉選單已重新初始化');
        }
        
        // 2. 重新綁定檔案上傳事件
        const fileInput = document.getElementById('fileInput');
        if (fileInput && typeof handleFileInput === 'function') {
            fileInput.removeEventListener('change', handleFileInput);
            fileInput.addEventListener('change', handleFileInput);
            console.log('✅ 檔案上傳事件已重新綁定');
        }
        
        // 3. 檢查關鍵元素是否存在
        const feederInput = document.getElementById('feederInput');
        const feederDropdown = document.getElementById('feederDropdown');
        const loadButton = document.querySelector('.load-feeder-btn');
        
        console.log('🔍 關鍵元素檢查:');
        console.log('  - 饋線輸入框:', feederInput ? '✅ 存在' : '❌ 不存在');
        console.log('  - 饋線下拉選單:', feederDropdown ? '✅ 存在' : '❌ 不存在');
        console.log('  - 載入按鈕:', loadButton ? '✅ 存在' : '❌ 不存在');
        
        // 4. 重新綁定其他事件（如果需要）
        bindAdditionalEvents();
        
        console.log('✅ 所有控制項重新初始化完成');
        return true;
        
    } catch (error) {
        console.error('❌ 重新初始化控制項失敗:', error);
        return false;
    }
}

// 🆕 綁定額外的事件
function bindAdditionalEvents() {
    // 重新綁定搜尋半徑變化事件（如果有的話）
    const searchRadius = document.getElementById('searchRadius');
    if (searchRadius) {
        // 可以在這裡添加半徑變化的事件處理
    }
    
    // 重新綁定其他控制項的事件...
}
// 🆕 檔案輸入處理函數（從原本的匿名函數提取出來）
function handleFileInput(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.name.toLowerCase().endsWith('.json')) {
        alert('請選擇 JSON 格式的檔案！');
        return;
    }
    
    // 顯示載入指示器
    document.getElementById('loadingIndicator').classList.add('show');
    updateLoadStatus(`正在讀取檔案: ${file.name}...`);
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const jsonData = JSON.parse(e.target.result);
            processJsonData(jsonData, file.name);
        } catch (error) {
            console.error('❌ JSON 解析錯誤:', error);
            updateLoadStatus('❌ 檔案格式錯誤，請檢查 JSON 格式');
            alert('檔案格式錯誤，請確認是有效的 JSON 檔案！');
        } finally {
            // 隱藏載入指示器
            document.getElementById('loadingIndicator').classList.remove('show');
        }
    };
    
    reader.onerror = function() {
        updateLoadStatus('❌ 檔案讀取失敗');
        document.getElementById('loadingIndicator').classList.remove('show');
    };
    
    reader.readAsText(file);
}
// 🆕 資訊面板功能
// 🔧 修正版：資訊面板 - 不覆蓋原內容
function showInfoPanel() {
    const sidebar = document.querySelector('.sidebar');
    
    // 🔧 重要修正：先隱藏原內容，而不是替換
    const originalContent = sidebar.innerHTML;
    
    // 暫存原內容到 data 屬性
    sidebar.setAttribute('data-original-content', originalContent);
    
    const infoContent = `
        <div style="padding: 20px; background: white; height: 100%; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3 style="color: #2c3e50; margin: 0;">📋 系統資訊</h3>
                <button onclick="restoreOriginalContent()" 
                        style="background: #6c757d; color: white; border: none; padding: 5px 10px; 
                               border-radius: 4px; cursor: pointer; font-size: 12px;">
                    ✕ 關閉
                </button>
            </div>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #495057;">🔧 版本資訊</h4>
                <p style="margin: 5px 0;"><strong>版本：</strong>2.0.0</p>
                <p style="margin: 5px 0;"><strong>更新：</strong>${new Date().toLocaleDateString('zh-TW')}</p>
            </div>
            
            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #1976d2;">📖 功能說明</h4>
                <ul style="margin: 0; padding-left: 20px;">
                    <li style="margin: 8px 0;">🗺️ <strong>地圖檢視：</strong>瀏覽饋線分佈圖</li>
                    <li style="margin: 8px 0;">⚙️ <strong>饋線控制：</strong>載入和管理饋線資料</li>
                    <li style="margin: 8px 0;">📏 <strong>測距工具：</strong>測量地圖上的距離</li>
                    <li style="margin: 8px 0;">🎛️ <strong>圖層控制：</strong>顯示/隱藏不同圖層</li>
                </ul>
            </div>
            
            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #856404;">💡 使用提示</h4>
                <p style="margin: 5px 0; font-size: 14px;">• 點擊線段可以高亮顯示</p>
                <p style="margin: 5px 0; font-size: 14px;">• 長按地圖可以開啟右鍵選單</p>
                <p style="margin: 5px 0; font-size: 14px;">• 使用雙指縮放調整地圖大小</p>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
                <button onclick="switchToControlsTab()" 
                        style="padding: 12px; background: linear-gradient(135deg, #28a745, #20c997); 
                               color: white; border: none; border-radius: 8px; cursor: pointer; 
                               font-size: 14px; font-weight: bold;
                               box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);">
                    ⚙️ 控制面板
                </button>
                
                <button onclick="switchToMapTab()" 
                        style="padding: 12px; background: linear-gradient(135deg, #3498db, #2980b9); 
                               color: white; border: none; border-radius: 8px; cursor: pointer; 
                               font-size: 14px; font-weight: bold;
                               box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);">
                    🗺️ 返回地圖
                </button>
            </div>
        </div>
    `;
    
    sidebar.innerHTML = infoContent;
}

// 🔧 修正版：恢復原始內容函數 - 確保完全恢復
function restoreOriginalContent() {
    console.log('🔄 恢復原始內容...');
    
    const sidebar = document.querySelector('.sidebar');
    if (!sidebar) {
        console.error('❌ 找不到側邊欄');
        return false;
    }
    
    const originalContent = sidebar.getAttribute('data-original-content');
    if (originalContent) {
        sidebar.innerHTML = originalContent;
        sidebar.removeAttribute('data-original-content');
        
        // 🔧 重要：重新初始化控制項
        setTimeout(() => {
            reinitializeControls();
            console.log('✅ 原始內容已恢復並重新初始化');
        }, 100);
        
        return true;
    } else {
        console.warn('⚠️ 沒有找到原始內容備份');
        return false;
    }
}
// 🆕 切換到地圖標籤
function switchToMapTab() {
    const mapTab = document.querySelector('[data-tab="map"]');
    if (mapTab) {
        mapTab.click();
    }
}
// 🔧 修正版：切換到控制面板
function switchToControlsTab() {
    // 先恢復原始內容
    restoreOriginalContent();
    
    // 然後切換到控制標籤
    const controlsTab = document.querySelector('[data-tab="controls"]');
    if (controlsTab) {
        controlsTab.click();
    }
}

// 🆕 切換到地圖標籤
function switchToMapTab() {
    const mapTab = document.querySelector('[data-tab="map"]');
    if (mapTab) {
        mapTab.click();
    }
}

// 🔧 修正版：監聽視窗大小變化 - 移除重新載入邏輯
window.addEventListener('resize', function() {
    // 🔧 重要：移除重新載入邏輯，只保留必要的調整
    initMobileOptimizations();
    
    // 🔧 修正：當從手機切換到桌面時，只調整顯示狀態，不重新載入
    if (window.innerWidth > 768) {
        const sidebar = document.querySelector('.sidebar');
        const mapContainer = document.querySelector('.map-container');
        
        if (sidebar && mapContainer) {
            sidebar.style.display = 'block';
            mapContainer.style.display = 'block';
            
            // 🔧 重要：恢復原始側邊欄內容（如果被修改過），但不重新載入整個頁面
            const originalContent = sidebar.getAttribute('data-original-content');
            if (originalContent) {
                sidebar.innerHTML = originalContent;
                sidebar.removeAttribute('data-original-content');
                reinitializeControls();
            }
        }
    }
    
    // 🔧 只調整地圖大小，不重新載入
    setTimeout(() => {
        if (map) {
            map.invalidateSize();
            console.log('🗺️ 視窗大小變化，地圖已調整');
        }
    }, 100);
});

// 🔧 修正版：手機版控制面板 - 隱藏檔案載入功能
function initMobileOptimizations() {
    if (window.innerWidth <= 768) {
        // 🔧 隱藏檔案載入相關控制項
        const fileControls = document.querySelectorAll('#fileInput, label[for="fileInput"], .file-upload-section');
        fileControls.forEach(control => {
            if (control) {
                control.style.display = 'none';
            }
        });
        
        // 🔧 隱藏包含"載入配電系統檔案"的整個區塊
        const uploadSections = document.querySelectorAll('.upload-section, .file-section');
        uploadSections.forEach(section => {
            if (section && section.textContent.includes('載入配電系統檔案')) {
                section.style.display = 'none';
            }
        });
        
        console.log('📱 手機版優化：已隱藏檔案載入功能');
    }
}

// 🆕 載入停電資料
// 🔧 修改：載入停電資料函數 - 更新狀態顯示邏輯
async function loadOutageData() {
    const outageApiUrl = 'https://script.google.com/macros/s/AKfycbygPaZiiAgb4gqSBP4rYDz8yqXMThTm7r6YyeJoFeRbv4tL57UWlc8YbQ5-SrkVfD-n/exec';
    
    try {
        console.log('🔄 正在載入停電資料...');
        updateOutageStatus('正在載入停電資料...');
        
        const response = await fetch(outageApiUrl);
        const result = await response.json();
        
        if (result && result.data) {
            outageData = result.data;
            
            // 🔧 修改：統計有饋線資料的記錄數量
            const validRecords = outageData.filter(record => 
                record.饋線 && record.饋線.toString().trim() !== ''
            );
            
            console.log(`✅ 成功載入 ${outageData.length} 筆停電資料，其中 ${validRecords.length} 筆有饋線資料`);
            
            // 🔧 修改：狀態顯示改為統計有饋線資料的數量
            updateOutageStatus(`✅ 已載入 ${validRecords.length} 筆有饋線資料的停電記錄 (${new Date(result.meta.lastUpdate).toLocaleString('zh-TW')})`);
            
            // 建立饋線跳脫清單
            createOutageFeederList();
            
            return true;
        } else {
            throw new Error('無效的停電資料格式');
        }
        
    } catch (error) {
        console.error('❌ 載入停電資料失敗:', error);
        updateOutageStatus('❌ 停電資料載入失敗');
        return false;
    }
}




// 🆕 更新停電狀態顯示
function updateOutageStatus(message) {
    const statusElement = document.getElementById('outageStatus');
    if (statusElement) {
        statusElement.textContent = message;
    }
}

// 🔧 修改：建立饋線跳脫清單 - 統計有饋線資料的記錄數量
function createOutageFeederList() {
    const listContainer = document.getElementById('outageFeederList');
    if (!listContainer || !outageData) return;
    
    // 🔧 修改：統計有饋線資料的記錄數量
    const validRecords = outageData.filter(record => 
        record.饋線 && record.饋線.toString().trim() !== ''
    );
    
    // 更新狀態顯示 - 使用有效記錄數量
    updateOutageStatus(`✅ 已載入 ${validRecords.length} 筆有饋線資料的停電記錄 (共 ${outageData.length} 筆原始資料)`);
    
    // 提取所有跳脫的饋線
    const feederMap = new Map();
    
    validRecords.forEach(record => {
        const feeder = record.饋線;
        if (feeder && feeder.trim() !== '') {
            if (!feederMap.has(feeder)) {
                feederMap.set(feeder, []);
            }
            feederMap.get(feeder).push(record);
        }
    });
    
    // 建立清單 HTML
    let listHtml = '';
    
    if (feederMap.size === 0) {
        listHtml = '<div style="text-align: center; color: #28a745; padding: 20px;">✅ 目前無饋線跳脫</div>';
    } else {
        feederMap.forEach((records, feeder) => {
            const recordCount = records.length;
            const latestRecord = records[0]; // 假設第一筆是最新的
            
            // 判斷饋線狀態顏色
            const statusColor = getFeederStatusColor(records);
            const statusText = getFeederStatusText(records);
            
            listHtml += `
                <div class="outage-feeder-item" style="margin-bottom: 10px; padding: 12px; background: white; border-radius: 6px; border-left: 4px solid ${statusColor}; cursor: pointer;"
                     onclick="selectOutageFeeder('${feeder}')">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: ${statusColor}; font-size: 14px;">⚡ ${feeder}</strong>
                            <div style="font-size: 11px; color: #666; margin-top: 2px;">
                                ${latestRecord.時間} | ${latestRecord.處理部門}
                            </div>
                            <div style="font-size: 10px; color: ${statusColor}; margin-top: 2px; font-weight: bold;">
                                ${statusText}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <span style="background: ${statusColor}; color: white; padding: 2px 6px; border-radius: 12px; font-size: 10px;">
                                ${recordCount} 筆
                            </span>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 4px;">
                        ${latestRecord.故障區間 || '查詢中...'}
                    </div>
                </div>
            `;
        });
    }
    
    listContainer.innerHTML = listHtml;
}

// 🆕 判斷饋線狀態顏色
function getFeederStatusColor(records) {
    // 檢查是否有任何記錄有"主幹復電"文字
    const hasMainPowerRestored = records.some(record => 
        record.主幹復電 && record.主幹復電.toString().trim() !== ''
    );
    
    if (hasMainPowerRestored) {
        return '#28a745'; // 綠色 - 主幹已復電
    }
    
    // 檢查是否有任何記錄有"查報完成"文字
    const hasInvestigationCompleted = records.some(record => 
        record.查報完成 && record.查報完成.toString().trim() !== ''
    );
    
    if (hasInvestigationCompleted) {
        return '#6c757d'; // 灰色 - 查報完成
    }
    
    return '#dc3545'; // 紅色 - 故障中
}
// 🆕 取得饋線狀態文字
function getFeederStatusText(records) {
    // 檢查是否有任何記錄有"主幹復電"文字
    const hasMainPowerRestored = records.some(record => 
        record.主幹復電 && record.主幹復電.toString().trim() !== ''
    );
    
    if (hasMainPowerRestored) {
        return '✅ 主幹已復電';
    }
    
    // 檢查是否有任何記錄有"查報完成"文字
    const hasInvestigationCompleted = records.some(record => 
        record.查報完成 && record.查報完成.toString().trim() !== ''
    );
    
    if (hasInvestigationCompleted) {
        return '📋 查報完成';
    }
    
    return '🔴 故障中';
}
// 🔧 修改：選擇停電饋線 - 不自動載入饋線
function selectOutageFeeder(feeder) {
    console.log(`🔍 選擇停電饋線: ${feeder}`);
    
    // 找到該饋線的所有停電記錄
    const feederRecords = outageData.filter(record => record.饋線 === feeder);
    
    if (feederRecords.length === 0) {
        showToast(`找不到饋線 ${feeder} 的停電記錄`, 'error');
        return;
    }
    
    // 只顯示詳細資訊彈窗，不自動載入饋線
    showFeederOutageDetails(feeder, feederRecords);
}

// 🆕 顯示饋線停電詳細資訊
// 🔧 修改：顯示饋線停電詳細資訊 - 改為側邊欄顯示
function showFeederOutageDetails(feeder, records) {
    const statusColor = getFeederStatusColor(records);
    const statusText = getFeederStatusText(records);
    
    // 🆕 檢查是否為手機版
    const isMobile = window.innerWidth <= 768;
    
    if (isMobile) {
        // 手機版：在側邊欄顯示
        showFeederDetailsInSidebar(feeder, records, statusColor, statusText);
    } else {
        // 桌面版：保持原有的地圖彈窗
        showFeederDetailsInPopup(feeder, records, statusColor, statusText);
    }
}

// 🆕 桌面版彈窗顯示（保持原有功能）
// 🔧 修改：桌面版彈窗顯示 - 加入無座標調閱功能
function showFeederDetailsInPopup(feeder, records, statusColor, statusText) {
    let detailHtml = `
        <div style="max-width: 450px; max-height: 500px; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: ${statusColor}; margin: 0;">⚡ ${feeder}</h3>
                <span style="background: ${statusColor}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">
                    ${statusText}
                </span>
            </div>
            
            <!-- 🆕 快速載入饋線按鈕 -->
            <div style="margin-bottom: 15px;">
                <button onclick="loadFeederDirectly('${feeder}')" 
                        style="width: 100%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: bold;">
                    🗺️ 直接載入 ${feeder} 饋線圖
                </button>
            </div>
    `;
    
    records.forEach((record, index) => {
        const hasCoordinates = record.故障區間圖號座標1 && record.故障區間圖號座標2;
        const recordStatusColor = getRecordStatusColor(record);
        
        detailHtml += `
            <div style="margin-bottom: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid ${recordStatusColor};">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: ${recordStatusColor};">事故 #${record.編號}</strong>
                    <span style="font-size: 11px; color: #666;">${record.時間}</span>
                </div>
                
                <div style="font-size: 12px; line-height: 1.4;">
                    <p><strong>事故別:</strong> ${record.事故別}</p>
                    <p><strong>故障區間:</strong> ${record.故障區間 || 'N/A'}</p>
                    <p><strong>處理部門:</strong> ${record.處理部門}</p>
                    <p><strong>派查狀態:</strong> ${record.派查狀態 || 'N/A'}</p>
                    <p><strong>派查人員:</strong> ${record.派查人員 || 'N/A'}</p>
                    ${record.事故原因 ? `<p><strong>事故原因:</strong> ${record.事故原因}</p>` : ''}
                    ${record.主幹復電 ? `<p style="color: #28a745;"><strong>✅ 主幹復電:</strong> ${record.主幹復電}</p>` : ''}
                    ${record.查報完成 ? `<p style="color: #6c757d;"><strong>📋 查報完成:</strong> ${record.查報完成}</p>` : ''}
                </div>
                
                <!-- 🔧 修改：操作按鈕 - 有座標和無座標都能操作 -->
				<div style="margin: 10px -8px 5px -8px;">
					${hasCoordinates ? `
						<button onclick="showFaultLocation('${record.故障區間圖號座標1}', '${record.故障區間圖號座標2}', '${feeder}', '${record.故障區間}')" 
								style="padding: 18px 24px; background: linear-gradient(135deg, #ff6b35, #f7931e); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 18px; font-weight: bold; width: calc(100% + 16px); transition: all 0.3s ease; box-shadow: 0 6px 12px rgba(255, 107, 53, 0.4); text-shadow: 0 2px 4px rgba(0,0,0,0.3); display: block; position: relative; letter-spacing: 0.5px;"
								onmouseover="this.style.transform='translateY(-4px) scale(1.03)'; this.style.boxShadow='0 8px 20px rgba(255, 107, 53, 0.5)';"
								onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 6px 12px rgba(255, 107, 53, 0.4)';">
							🎯 查看故障區間並載入饋線
						</button>
					` : `
						<button onclick="loadFeederWithRecord('${feeder}', '${record.故障區間}', ${index})" 
								style="padding: 15px 20px; background: linear-gradient(135deg, #17a2b8, #138496); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; width: calc(100% + 16px); transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(23, 162, 184, 0.3); text-shadow: 0 1px 2px rgba(0,0,0,0.2);"
								onmouseover="this.style.transform='translateY(-2px) scale(1.02)'; this.style.boxShadow='0 6px 12px rgba(23, 162, 184, 0.4)';"
								onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 8px rgba(23, 162, 184, 0.3)';">
							🗺️ 載入饋線並查看故障區間
						</button>
					`}
				</div>
            </div>
        `;
    });
    
    detailHtml += `
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="map.closePopup()" 
                        style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    關閉
                </button>
            </div>
        </div>
    `;
    
    const popup = L.popup({
        maxWidth: 500,
        closeButton: true
    })
    .setLatLng(map.getCenter())
    .setContent(detailHtml)
    .openOn(map);
}

// 🔧 修改：在側邊欄顯示饋線詳情（手機版）- 加入無座標調閱功能
function showFeederDetailsInSidebar(feeder, records, statusColor, statusText) {
    const sidebar = document.querySelector('.sidebar');
    if (!sidebar) return;
    
    // 建立詳情容器
    const detailsContainer = document.createElement('div');
    detailsContainer.id = 'feederDetailsContainer';
    detailsContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: white;
        z-index: 2000;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
    `;
    
    let detailHtml = `
        <div style="margin-bottom: 20px;">
            <!-- 標題列 -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #eee;">
                <div>
                    <h2 style="color: ${statusColor}; margin: 0; font-size: 20px;">⚡ ${feeder}</h2>
                    <span style="background: ${statusColor}; color: white; padding: 6px 12px; border-radius: 15px; font-size: 12px; font-weight: bold; margin-top: 8px; display: inline-block;">
                        ${statusText}
                    </span>
                </div>
                <button onclick="closeFeederDetails()" 
                        style="background: #dc3545; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                    ✕
                </button>
            </div>
            
            <!-- 統計資訊 -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 24px; font-weight: bold; color: ${statusColor};">${records.length}</div>
                    <div style="font-size: 12px; color: #666;">事故筆數</div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 14px; font-weight: bold; color: #666;">${records[0].處理部門}</div>
                    <div style="font-size: 12px; color: #666;">處理部門</div>
                </div>
            </div>
            
            <!-- 🆕 快速載入饋線按鈕 -->
            <div style="margin-bottom: 20px;">
                <button onclick="loadFeederDirectlyMobile('${feeder}')" 
                        style="width: 100%; padding: 15px; background: linear-gradient(135deg, #007bff, #0056b3); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,123,255,0.3);">
                    🗺️ 直接載入 ${feeder} 饋線圖
                </button>
            </div>
        </div>
        
        <!-- 事故清單 -->
        <div style="margin-bottom: 20px;">
            <h3 style="color: #333; margin-bottom: 15px; font-size: 16px;">📋 事故詳情</h3>
    `;
    
    records.forEach((record, index) => {
        const hasCoordinates = record.故障區間圖號座標1 && record.故障區間圖號座標2;
        const recordStatusColor = getRecordStatusColor(record);
        
        detailHtml += `
            <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 10px; border: 1px solid #eee; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <!-- 事故標題 -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div>
                        <strong style="color: ${recordStatusColor}; font-size: 16px;">事故 #${record.編號}</strong>
                        <div style="font-size: 12px; color: #666; margin-top: 2px;">${record.時間}</div>
                    </div>
                    <div style="width: 8px; height: 40px; background: ${recordStatusColor}; border-radius: 4px;"></div>
                </div>
                
                <!-- 事故資訊 -->
                <div style="font-size: 14px; line-height: 1.6; margin-bottom: 12px;">
                    <div style="margin-bottom: 8px;">
                        <span style="color: #666; font-size: 12px;">事故別</span><br>
                        <strong>${record.事故別}</strong>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <span style="color: #666; font-size: 12px;">故障區間</span><br>
                        <strong>${record.故障區間 || 'N/A'}</strong>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <span style="color: #666; font-size: 12px;">派查狀態</span><br>
                        <strong>${record.派查狀態 || 'N/A'}</strong>
                    </div>
                    ${record.派查人員 ? `
                        <div style="margin-bottom: 8px;">
                            <span style="color: #666; font-size: 12px;">派查人員</span><br>
                            <strong>${record.派查人員}</strong>
                        </div>
                    ` : ''}
                    ${record.事故原因 ? `
                        <div style="margin-bottom: 8px;">
                            <span style="color: #666; font-size: 12px;">事故原因</span><br>
                            <strong>${record.事故原因}</strong>
                        </div>
                    ` : ''}
                    ${record.主幹復電 ? `
                        <div style="margin-bottom: 8px; padding: 8px; background: #d4edda; border-radius: 6px;">
                            <span style="color: #155724; font-size: 12px;">✅ 主幹復電</span><br>
                            <strong style="color: #155724;">${record.主幹復電}</strong>
                        </div>
                    ` : ''}
                    ${record.查報完成 ? `
                        <div style="margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 6px;">
                            <span style="color: #6c757d; font-size: 12px;">📋 查報完成</span><br>
                            <strong style="color: #6c757d;">${record.查報完成}</strong>
                        </div>
                    ` : ''}
                </div>
                
                <!-- 🔧 修改：操作按鈕 - 有座標和無座標都能操作 -->
				<div style="margin-top: 8px;">
					${hasCoordinates ? `
						<button onclick="showFaultLocationMobile('${record.故障區間圖號座標1}', '${record.故障區間圖號座標2}', '${feeder}', '${record.故障區間}')" 
								style="padding: 16px 20px; background: linear-gradient(135deg, #ff6b35, #f7931e); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(255, 107, 53, 0.3); text-shadow: 0 1px 2px rgba(0,0,0,0.2); letter-spacing: 0.5px;"
								onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 12px rgba(255, 107, 53, 0.4)';"
								onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 8px rgba(255, 107, 53, 0.3)';">
							🎯 查看故障區間並載入饋線
						</button>
					` : `
						<button onclick="loadFeederWithRecordMobile('${feeder}', '${record.故障區間}', ${index})" 
								style="padding: 14px 18px; background: linear-gradient(135deg, #17a2b8, #138496); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 15px; font-weight: bold; width: 100%; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(23, 162, 184, 0.3);"
								onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 6px 10px rgba(23, 162, 184, 0.4)';"
								onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 8px rgba(23, 162, 184, 0.3)';">
							🗺️ 載入饋線並查看故障區間
						</button>
					`}
				</div>
            </div>
        `;
    });
    
    detailHtml += `
        </div>
        
        <!-- 底部操作區 -->
        <div style="position: sticky; bottom: 0; background: white; padding: 15px 0; border-top: 1px solid #eee; margin-top: 20px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button onclick="closeFeederDetails()" 
                        style="padding: 12px; background: #6c757d; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    ← 返回清單
                </button>
                <button onclick="showOutageMapMobile('${feeder}')" 
                        style="padding: 12px; background: #dc3545; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    🗺️ 查看地圖
                </button>
            </div>
        </div>
    `;
    
    detailsContainer.innerHTML = detailHtml;
    document.body.appendChild(detailsContainer);
    
    // 防止背景滾動
    document.body.style.overflow = 'hidden';
}

// 🆕 直接載入饋線（手機版）
function loadFeederDirectlyMobile(feeder) {
    closeFeederDetails();
    
    setTimeout(() => {
        loadFeederDirectly(feeder);
    }, 300);
}

// 🆕 直接載入饋線（通用）
function loadFeederDirectly(feeder) {
    const feederInput = document.getElementById('feederInput');
    if (feederInput) {
        if (feederList.includes(feeder)) {
            feederInput.value = feeder;
            showToast(`🔄 正在載入饋線 ${feeder}...`, 'info');
            loadFeederFromCloud();
            
            // 關閉彈窗（如果有的話）
            if (map.getPopup()) {
                map.closePopup();
            }
        } else {
            showToast(`⚠️ 饋線 ${feeder} 不在可載入清單中`, 'warning');
        }
    }
}
// 🆕 載入饋線並標註故障區間（通用）
function loadFeederWithRecord(feeder, faultSection, recordIndex) {
    const feederInput = document.getElementById('feederInput');
    if (feederInput) {
        if (feederList.includes(feeder)) {
            feederInput.value = feeder;
            showToast(`🔄 正在載入饋線 ${feeder}...`, 'info');
            
            // 載入饋線後標註故障區間
            loadFeederFromCloud().then(() => {
                // 延遲一下讓饋線載入完成
                setTimeout(() => {
                    highlightFaultSection(feeder, faultSection, recordIndex);
                }, 1000);
            });
            
            // 關閉彈窗（如果有的話）
            if (map.getPopup()) {
                map.closePopup();
            }
        } else {
            showToast(`⚠️ 饋線 ${feeder} 不在可載入清單中`, 'warning');
        }
    }
}
// 🆕 標註故障區間（文字搜尋）
function highlightFaultSection(feeder, faultSection, recordIndex) {
    if (!faultSection || faultSection === 'N/A') {
        showToast(`📍 已載入饋線 ${feeder}，請手動查找故障位置`, 'info');
        return;
    }
    
    console.log(`🔍 搜尋故障區間: ${faultSection}`);
    
    // 在地圖上搜尋包含故障區間文字的標記或線段
    let found = false;
    
    // 搜尋所有圖層
    map.eachLayer(function(layer) {
        if (layer.getPopup && layer.getPopup()) {
            const popupContent = layer.getPopup().getContent();
            if (popupContent && popupContent.includes(faultSection)) {
                // 找到相關的標記，高亮顯示
                if (layer.setStyle) {
                    layer.setStyle({
                        color: '#ff0000',
                        weight: 8,
                        opacity: 1,
                        dashArray: '10,5'
                    });
                }
                
                // 移動到該位置
                if (layer.getBounds) {
                    map.fitBounds(layer.getBounds(), { padding: [20, 20] });
                } else if (layer.getLatLng) {
                    map.setView(layer.getLatLng(), 16);
                }
                
                // 顯示彈窗
                layer.openPopup();
                found = true;
                
                showToast(`📍 已找到並標註故障區間: ${faultSection}`, 'success');
                return false; // 停止搜尋
            }
        }
        
        // 搜尋標記的 tooltip 或其他屬性
        if (layer.getTooltip && layer.getTooltip()) {
            const tooltipContent = layer.getTooltip().getContent();
            if (tooltipContent && tooltipContent.includes(faultSection)) {
                if (layer.setStyle) {
                    layer.setStyle({
                        color: '#ff0000',
                        weight: 6,
                        opacity: 1
                    });
                }
                
                if (layer.getLatLng) {
                    map.setView(layer.getLatLng(), 16);
                } else if (layer.getBounds) {
                    map.fitBounds(layer.getBounds(), { padding: [20, 20] });
                }
                
                layer.openTooltip();
                found = true;
                
                showToast(`📍 已找到並標註故障區間: ${faultSection}`, 'success');
                return false;
            }
        }
    });
    
    if (!found) {
        showToast(`📍 已載入饋線 ${feeder}，但未找到故障區間 "${faultSection}" 的精確位置`, 'warning');
        
        // 創建一個通用的故障區間提示
        const centerPopup = L.popup()
            .setLatLng(map.getCenter())
            .setContent(`
                <div style="text-align: center;">
                    <h4 style="color: #dc3545;">⚡ ${feeder}</h4>
                    <p><strong>故障區間:</strong> ${faultSection}</p>
                    <p style="font-size: 12px; color: #666;">
                        請在地圖上手動查找相關位置
                    </p>
                    <button onclick="map.closePopup()" 
                            style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                        關閉
                    </button>
                </div>
            `)
            .openOn(map);
    }
}

// 🆕 關閉饋線詳情
function closeFeederDetails() {
    const detailsContainer = document.getElementById('feederDetailsContainer');
    if (detailsContainer) {
        detailsContainer.remove();
        document.body.style.overflow = 'auto'; // 恢復背景滾動
    }
}
// 🆕 手機版故障位置顯示
function showFaultLocationMobile(coord1, coord2, feeder, faultSection) {
    // 先關閉詳情頁面
    closeFeederDetails();
    
    // 延遲一點再執行地圖操作，讓頁面有時間切換
    setTimeout(() => {
        showFaultLocation(coord1, coord2, feeder, faultSection);
    }, 300);
}
// 🆕 手機版地圖顯示
function showOutageMapMobile(feeder) {
    // 先關閉詳情頁面
    closeFeederDetails();
    
    // 延遲一點再執行地圖操作
    setTimeout(() => {
        // 找到該饋線的所有記錄
        const feederRecords = outageData.filter(record => record.饋線 === feeder);
        
        // 清除現有標記
        clearFaultMarkers();
        
        let markerCount = 0;
        const bounds = L.latLngBounds();
        
        feederRecords.forEach(record => {
            const coord1 = record.故障區間圖號座標1;
            const coord2 = record.故障區間圖號座標2;
            
            if (coord1 && coord2) {
                try {
                    const pos1 = convertPowerCoordinate(coord1);
                    const pos2 = convertPowerCoordinate(coord2);
                    
                    const [lng1, lat1] = pos1.split(',').map(Number);
                    const [lng2, lat2] = pos2.split(',').map(Number);
                    
                    const faultLine = L.polyline([[lat1, lng1], [lat2, lng2]], {
                        color: getRecordStatusColor(record),
                        weight: 4,
                        opacity: 0.7
                    }).addTo(map);
                    
                    faultLine.bindPopup(`
                        <div style="text-align: center;">
                            <h4 style="color: ${getRecordStatusColor(record)};">⚡ ${feeder}</h4>
                            <p><strong>故障區間:</strong> ${record.故障區間}</p>
                            <p><strong>時間:</strong> ${record.時間}</p>
                        </div>
                    `);
                    
                    faultLineMarkers.push(faultLine);
                    bounds.extend([[lat1, lng1], [lat2, lng2]]);
                    markerCount++;
                    
                } catch (error) {
                    console.warn(`座標轉換失敗: ${coord1}, ${coord2}`, error);
                }
            }
        });
        
        if (markerCount > 0) {
            map.fitBounds(bounds, { padding: [20, 20] });
            showToast(`🗺️ 已顯示 ${feeder} 的 ${markerCount} 個故障位置`, 'success');
        } else {
            showToast('❌ 無有效座標資料可顯示', 'error');
        }
    }, 300);
}
// 🆕 取得個別記錄的狀態顏色
function getRecordStatusColor(record) {
    if (record.主幹復電 && record.主幹復電.toString().trim() !== '') {
        return '#28a745'; // 綠色 - 主幹已復電
    }
    
    if (record.查報完成 && record.查報完成.toString().trim() !== '') {
        return '#6c757d'; // 灰色 - 查報完成
    }
    
    return '#dc3545'; // 紅色 - 故障中
}

// 🆕 顯示故障位置
// 🔧 修改：顯示故障位置 - 加入自動載入饋線
function showFaultLocation(coord1, coord2, feeder, faultSection) {
    try {
        console.log(`🗺️ 顯示故障位置: ${coord1} - ${coord2}`);
        
        // 轉換座標
        const pos1 = convertPowerCoordinate(coord1);
        const pos2 = convertPowerCoordinate(coord2);
        
        const [lng1, lat1] = pos1.split(',').map(Number);
        const [lng2, lat2] = pos2.split(',').map(Number);
        
        // 清除之前的故障標記
        clearFaultMarkers();
        
        // 建立閃爍標記
        const marker1 = createBlinkingMarker([lat1, lng1], `故障起點\n${coord1}`, '#ff0000');
        const marker2 = createBlinkingMarker([lat2, lng2], `故障終點\n${coord2}`, '#ff0000');
        
        // 建立連接線
        const faultLine = L.polyline([[lat1, lng1], [lat2, lng2]], {
            color: '#ff0000',
            weight: 6,
            opacity: 0.8,
            dashArray: '10,10',
            className: 'fault-line-animation'
        }).addTo(map);
        
        // 儲存標記以便後續清除
        faultLineMarkers.push(marker1, marker2, faultLine);
        
        // 移動地圖到故障區域
        const bounds = L.latLngBounds([[lat1, lng1], [lat2, lng2]]);
        map.fitBounds(bounds, { padding: [50, 50] });
        
        // 🆕 自動載入該饋線資料
        const feederInput = document.getElementById('feederInput');
        if (feederInput && feederList.includes(feeder)) {
            feederInput.value = feeder;
            showToast(`🔄 正在載入饋線 ${feeder}...`, 'info');
            loadFeederFromCloud();
        } else if (!feederList.includes(feeder)) {
            showToast(`⚠️ 饋線 ${feeder} 不在可載入清單中`, 'warning');
        }
        
        // 顯示故障資訊
        const midLat = (lat1 + lat2) / 2;
        const midLng = (lng1 + lng2) / 2;
        
        const infoPopup = L.popup()
            .setLatLng([midLat, midLng])
            .setContent(`
                <div style="text-align: center;">
                    <h4 style="color: #dc3545; margin: 0 0 8px 0;">⚡ 故障區間</h4>
                    <p style="margin: 4px 0;"><strong>饋線:</strong> ${feeder}</p>
                    <p style="margin: 4px 0;"><strong>區間:</strong> ${faultSection}</p>
                    <p style="margin: 4px 0; font-size: 11px; color: #666;">
                        ${coord1} ↔ ${coord2}
                    </p>
                    <button onclick="clearFaultMarkers()" 
                            style="margin-top: 8px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">
                        清除標記
                    </button>
                </div>
            `)
            .openOn(map);
        
        showToast(`🗺️ 已標記 ${feeder} 故障位置`, 'success');
        
    } catch (error) {
        console.error('顯示故障位置失敗:', error);
        showToast(`❌ 座標轉換失敗: ${error.message}`, 'error');
    }
}

// 🆕 建立閃爍標記
function createBlinkingMarker(position, title, color) {
    const blinkingIcon = L.divIcon({
        html: `
            <div style="
                width: 20px; 
                height: 20px; 
                background: ${color}; 
                border: 3px solid white; 
                border-radius: 50%; 
                box-shadow: 0 0 10px rgba(255,0,0,0.6);
                animation: blink 1s infinite;
            "></div>
            <style>
                @keyframes blink {
                    0%, 50% { opacity: 1; transform: scale(1); }
                    25%, 75% { opacity: 0.3; transform: scale(1.2); }
                }
            </style>
        `,
        className: 'blinking-marker',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    
    const marker = L.marker(position, { icon: blinkingIcon })
        .bindPopup(title)
        .addTo(map);
    
    return marker;
}

// 🆕 清除故障標記
function clearFaultMarkers() {
    faultLineMarkers.forEach(marker => {
        if (map.hasLayer(marker)) {
            map.removeLayer(marker);
        }
    });
    faultLineMarkers = [];
    map.closePopup();
    console.log('🧹 已清除故障標記');
}

// 🆕 重新整理停電資料
async function refreshOutageData() {
    updateOutageStatus('正在重新整理...');
    const success = await loadOutageData();
    if (success) {
        showToast('✅ 停電資料已更新', 'success');
    } else {
        showToast('❌ 停電資料更新失敗', 'error');
    }
}

// 🆕 顯示停電地圖總覽
function showOutageMap() {
    if (!outageData || outageData.length === 0) {
        showToast('❌ 無停電資料可顯示', 'error');
        return;
    }
    
    // 清除現有標記
    clearFaultMarkers();
    
    let markerCount = 0;
    const bounds = L.latLngBounds();
    
    outageData.forEach(record => {
        const coord1 = record.故障區間圖號座標1;
        const coord2 = record.故障區間圖號座標2;
        
        if (coord1 && coord2) {
            try {
                const pos1 = convertPowerCoordinate(coord1);
                const pos2 = convertPowerCoordinate(coord2);
                
                const [lng1, lat1] = pos1.split(',').map(Number);
                const [lng2, lat2] = pos2.split(',').map(Number);
                
                // 建立故障線段
                const faultLine = L.polyline([[lat1, lng1], [lat2, lng2]], {
                    color: '#dc3545',
                    weight: 4,
                    opacity: 0.7
                }).addTo(map);
                
                // 加入彈窗資訊
                faultLine.bindPopup(`
                    <div style="text-align: center;">
                        <h4 style="color: #dc3545;">⚡ ${record.饋線}</h4>
                        <p><strong>故障區間:</strong> ${record.故障區間}</p>
                        <p><strong>時間:</strong> ${record.時間}</p>
                        <p><strong>處理部門:</strong> ${record.處理部門}</p>
                    </div>
                `);
                
                faultLineMarkers.push(faultLine);
                bounds.extend([[lat1, lng1], [lat2, lng2]]);
                markerCount++;
                
            } catch (error) {
                console.warn(`座標轉換失敗: ${coord1}, ${coord2}`, error);
            }
        }
    });
    
    if (markerCount > 0) {
        map.fitBounds(bounds, { padding: [20, 20] });
        showToast(`🗺️ 已顯示 ${markerCount} 個故障位置`, 'success');
    } else {
        showToast('❌ 無有效座標資料可顯示', 'error');
    }
}

// 載入災情資料
// 🔧 修正版：載入災情資料 - 回傳 Promise
async function loadDisasterData() {
    const gasWebAppUrl = 'https://script.google.com/macros/s/AKfycbxWA8-1wYXphRX54QJwhTaE9T5A6eUZyQs2kYDfGw2fS5ELp75uY_P6SjYx1EuMtjFr/exec';
    
    try {
        console.log('🔄 正在載入災情資料...');
        updateDisasterStatus('正在載入災情資料...');
        
        const response = await fetch(`${gasWebAppUrl}?action=getData&_t=${Date.now()}`);
        const result = await response.json();
        
        if (result.success && Array.isArray(result.data)) {
            disasterData = result.data;
            console.log(`✅ 成功載入 ${disasterData.length} 筆災情資料`);
            
            updateDisasterStatus(`✅ 已載入 ${disasterData.length} 筆災情資料 (${new Date(result.meta.lastUpdate).toLocaleString('zh-TW')})`);
            createDisasterReportList();
            
            // 🔧 重要：回傳成功的 Promise
            return Promise.resolve(result.data);
        } else {
            throw new Error(result.error || '無效的災情資料格式');
        }
        
    } catch (error) {
        console.error('❌ 載入災情資料失敗:', error);
        updateDisasterStatus('❌ 災情資料載入失敗');
        
        // 🔧 重要：回傳失敗的 Promise
        return Promise.reject(error);
    }
}

// 更新災情狀態顯示
function updateDisasterStatus(message) {
    const statusElement = document.getElementById('disasterStatus');
    if (statusElement) {
        statusElement.textContent = message;
    }
}

// 建立災情報告清單
function createDisasterReportList() {
    const listContainer = document.getElementById('disasterReportList');
    if (!listContainer || !disasterData) return;
    
    let listHtml = '';
    
    if (disasterData.length === 0) {
        listHtml = '<div style="text-align: center; color: #28a745; padding: 20px;">✅ 目前無災情報告</div>';
    } else {
        disasterData.forEach((report, index) => {
            const repairStatus = report['修復狀態'] || '未修復';
            const statusColor = getRepairStatusColor(repairStatus);
            const severityLevel = report['嚴重等級'] || '未定義';
            
            listHtml += `
                <div class="disaster-report-item" style="margin-bottom: 10px; padding: 12px; background: white; border-radius: 6px; border-left: 4px solid ${statusColor}; cursor: pointer;"
                     onclick="selectDisasterReport('${report.id}')">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: ${statusColor}; font-size: 14px;">🚨 ${report.incidents?.[0]?.type || '災情報告'}</strong>
                            <div style="font-size: 11px; color: #666; margin-top: 2px;">
                                ${report.timestamp} | ${report['巡修部門'] || '未指定'}
                            </div>
                            <div style="font-size: 10px; color: ${statusColor}; margin-top: 2px; font-weight: bold;">
                                ${repairStatus}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <span class="severity-badge severity-${severityLevel.replace(/\s+/g, '-')}">${severityLevel}</span>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 4px;">
                        ${report.location?.tpcMapNumber || report.location?.poleNumber || '位置資訊不完整'}
                    </div>
                </div>
            `;
        });
    }
    
    listContainer.innerHTML = listHtml;
}

// 取得修復狀態顏色
function getRepairStatusColor(status) {
    switch(status) {
        case '已修復': return '#28a745';
        case '已派修': return '#ffc107';
        default: return '#dc3545';
    }
}

// 選擇災情報告
function selectDisasterReport(reportId) {
    console.log(`🔍 選擇災情報告: ${reportId}`);
    
    const report = disasterData.find(r => r.id === reportId);
    if (!report) {
        showToast(`找不到災情報告 ${reportId}`, 'error');
        return;
    }
    
    showDisasterReportDetails(report);
}

// 顯示災情報告詳情
function showDisasterReportDetails(report) {
    // 清除現有災情標記
    clearDisasterMarkers();
    
    // 在地圖上標記位置
    if (report.location && report.location.latitude && report.location.longitude) {
        const marker = createDisasterMarker(report);
        disasterMarkers.push(marker);
        
        // 移動地圖到該位置
        map.setView([report.location.latitude, report.location.longitude], 16);
        
        // 打開彈出窗口
        marker.openPopup();
    } else {
        showToast('該報告沒有有效的位置資訊', 'warning');
    }
}

// 建立災情標記
// 🔧 修正版：建立災情標記 - 恢復正常彈出視窗功能
function createDisasterMarker(report) {
    const repairStatus = report['修復狀態'] || '未修復';
    const severityLevel = report['嚴重等級'] || '未定義';
    
    // 根據狀態設置圖標顏色
    let iconUrl;
    if (repairStatus === '已修復') {
        iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png';
    } else {
        switch (severityLevel) {
            case '極嚴重':
                iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png';
                break;
            case '嚴重':
                iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png';
                break;
            case '一般':
                iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png';
                break;
            case '輕微':
                iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png';
                break;
            case '不影響':
                iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png';
                break;
            default:
                iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png';
        }
    }
    
    const customIcon = L.icon({
        iconUrl: iconUrl,
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
    });
    
    const marker = L.marker([report.location.latitude, report.location.longitude], {
        icon: customIcon
    }).addTo(map);
    
    // 建立彈出窗口內容
    let popupContent = createDisasterPopupContent(report);
    
    // 🔧 重要修正：使用標準的 Leaflet 彈出視窗綁定，不要自訂點擊事件
    marker.bindPopup(popupContent, {
        maxWidth: 320,
        minWidth: 280,
        className: 'disaster-popup'
    });
    
    return marker;
}

// 🔧 修正版：建立災情彈出窗口內容 - 新增複製標籤資訊功能
function createDisasterPopupContent(report) {
    const repairStatus = report['修復狀態'] || '未修復';
    const severityLevel = report['嚴重等級'] || '未定義';
    
    let popupContent = `<div class="popup-content">`;
    
    // 添加修復狀態標籤
    if (repairStatus === '已修復') {
        popupContent += `<span class="repair-status-badge repair-status-completed">修復訖</span>`;
    } else if (repairStatus === '已派修') {
        popupContent += `<span class="repair-status-badge repair-status-dispatched">已派修</span>`;
        if (report['派修時間']) {
            popupContent += `
                <div style="margin-top: 5px; padding: 8px; background-color: #f8f9fa; border-radius: 5px; font-size: 12px;">
                    <p style="margin: 0;"><strong>派修人員:</strong> ${report['修復人員'] || '未指定'}</p>
                    <p style="margin: 0;"><strong>派修時間:</strong> ${report['派修時間']}</p>
                </div>
            `;
        }
    } else {
        popupContent += `<span class="repair-status-badge repair-status-pending">未派修</span>`;
    }
    
    popupContent += `<h6>報告時間: ${report.timestamp || '未知'}</h6>`;
    
    // 添加事故清單
    popupContent += `<p class="mt-2"><strong>事故:</strong> `;
    if (Array.isArray(report.incidents) && report.incidents.length > 0) {
        const incidentTexts = report.incidents.map(incident => 
            `${incident.type || '未知'} (${incident.quantity || 0} ${incident.unit || ''})`
        );
        popupContent += incidentTexts.join(', ');
    } else {
        popupContent += '無事故數據';
    }
    popupContent += `</p>`;
    
    // 添加位置資訊
    if (report.location?.tpcMapNumber) {
        popupContent += `<strong>台電圖號:</strong> ${report.location.tpcMapNumber}<br>`;
    }
    if (report.location?.poleNumber) {
        popupContent += `<strong>桿號:</strong> ${report.location.poleNumber}<br>`;
    }
    
    // 添加設備資訊
    if (report['饋線代號']) {
        popupContent += `<strong>饋線代號:</strong> ${report['饋線代號']}<br>`;
    }
    if (report['線路類型']) {
        popupContent += `<strong>線路類型:</strong> ${report['線路類型']}<br>`;
    }
    if (report['巡修部門']) {
        popupContent += `<strong>巡修部門:</strong> ${report['巡修部門']}<br>`;
    }
    
    // 添加備註
    if (report.remarks && report.remarks.trim() !== '') {
        popupContent += `<strong>備註:</strong> <span style="color: #dc3545;">${report.remarks}</span><br>`;
    }
    
    // 照片預覽（保持原有功能）
    if (Array.isArray(report.photos) && report.photos.length > 0) {
        popupContent += `<div class="popup-photos" style="margin-top: 10px;">
            <strong>照片 (${report.photos.length}):</strong><br>
            <div class="photo-gallery" style="display: flex; gap: 5px; flex-wrap: wrap; margin-top: 5px;">`;
        
        report.photos.forEach((photo, photoIndex) => {
            let photoUrl, photoName;
            
            if (typeof photo === 'string') {
                photoUrl = photo;
                photoName = `照片 ${photoIndex+1}`;
            } else if (photo && typeof photo === 'object') {
                photoUrl = photo.url || photo.src || photo.path || '';
                photoName = photo.name || `照片 ${photoIndex+1}`;
            } else {
                return;
            }
            
            if (!photoUrl) return;
            
            const thumbnailUrl = fixGoogleDrivePhotoUrl(photoUrl, false);
            
            popupContent += `
                <div style="position: relative; width: 60px; height: 60px; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; background: #f8f9fa;">
                    <img src="${thumbnailUrl}" 
                         alt="${photoName}" 
                         onclick="openPhotoModalSafe('${photoUrl}', '${report.id}_${photoIndex}')" 
                         style="width: 100%; height: 100%; object-fit: cover; cursor: pointer; transition: transform 0.2s;"
                         onload="this.parentElement.style.background='transparent'"
                         onerror="handleThumbnailError(this, '${photoUrl}', '${photoIndex}')"
                         onmouseover="this.style.transform='scale(1.05)'"
                         onmouseout="this.style.transform='scale(1)'">
                    <div class="photo-placeholder" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #e9ecef; display: none; align-items: center; justify-content: center; font-size: 8px; color: #6c757d; text-align: center; line-height: 1.2;">
                        📷<br>照片<br>${photoIndex + 1}
                    </div>
                </div>
            `;
        });
        
        popupContent += `</div>`;
        popupContent += `<div style="font-size: 10px; color: #6c757d; margin-top: 5px; text-align: center;">點擊照片放大檢視</div></div>`;
    }
    
    // 導航功能
    if (report.location?.latitude && report.location?.longitude) {
        const lat = report.location.latitude;
        const lng = report.location.longitude;
        const locationName = getDisasterLocationName(report);
        
        popupContent += `<div style="margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">`;
        
        // 街景按鈕
        popupContent += `
            <button onclick="openStreetView(${lat}, ${lng})" 
                    style="padding: 8px 6px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;"
                    title="開啟 Google 街景圖">
                🗺️ 街景
            </button>
        `;
        
        // 導航按鈕
        popupContent += `
            <button onclick="openNavigation(${lat}, ${lng}, '${encodeURIComponent(locationName)}')" 
                    style="padding: 8px 6px; background: #34a853; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;"
                    title="開啟 Google 導航">
                🧭 導航
            </button>
        `;
        
        popupContent += `</div>`;
        
        // 複製座標按鈕
        popupContent += `
            <div style="margin-top: 8px;">
                <button onclick="copyCoordinates(${lat}, ${lng})" 
                        style="width: 100%; padding: 6px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;"
                        title="複製經緯度座標">
                    📋 複製座標 (${lat.toFixed(6)}, ${lng.toFixed(6)})
                </button>
            </div>
        `;
        
        // 🆕 新增：複製標籤資訊按鈕
        popupContent += `
            <div style="margin-top: 6px;">
                <button onclick="copyDisasterMarkerInfo('${report.id}', ${lat}, ${lng})" 
                        style="width: 100%; padding: 6px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;"
                        title="複製可分享的標籤連結">
                    🔗 複製標籤資訊
                </button>
            </div>
        `;
        
    } else {
        // 如果沒有座標，顯示無法導航的提示
        popupContent += `
            <div style="margin-top: 10px; padding: 8px; background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; text-align: center;">
                <span style="color: #721c24; font-size: 11px;">❌ 此災情無位置資訊，無法提供導航功能</span>
            </div>
        `;
    }
    
    popupContent += `</div>`;
    
    return popupContent;
}
// 🔧 修正版：複製災情標籤資訊功能 - 使用指定的網址
function copyDisasterMarkerInfo(reportId, lat, lng) {
    try {
        // 找到對應的災情報告
        const report = disasterData.find(r => r.id === reportId);
        if (!report) {
            showToast('❌ 找不到災情資料', 'error');
            return;
        }
        
        // 🔧 修正：使用指定的正式網址而不是當前頁面網址
        const baseUrl = 'https://feeder-map.vercel.app/';
        const shareUrl = `${baseUrl}#disaster/${reportId}/${lat.toFixed(6)}/${lng.toFixed(6)}`;
        
        // 建立標籤資訊文字
        const repairStatus = report['修復狀態'] || '未修復';
        const severityLevel = report['嚴重等級'] || '未定義';
        const incidentText = Array.isArray(report.incidents) && report.incidents.length > 0 
            ? report.incidents.map(incident => `${incident.type || '未知'} (${incident.quantity || 0} ${incident.unit || ''})`).join(', ')
            : '無事故數據';
        
        // 🔧 修正：格式化時間顯示
        const formattedTime = formatDisasterTime(report.timestamp);
        
        const shareText = `🚨 災情標籤資訊

📅 時間：${formattedTime}
🔧 狀態：${repairStatus}
⚠️ 等級：${severityLevel}
🚨 事故：${incidentText}
${report.location?.tpcMapNumber ? `📍 台電圖號：${report.location.tpcMapNumber}` : ''}
${report.location?.poleNumber ? `🏗️ 桿號：${report.location.poleNumber}` : ''}
${report['饋線代號'] ? `⚡ 饋線：${report['饋線代號']}` : ''}
${report['巡修部門'] ? `🏢 部門：${report['巡修部門']}` : ''}
${report.remarks ? `💬 備註：${report.remarks}` : ''}

📍 位置：${lat.toFixed(6)}, ${lng.toFixed(6)}
🔗 查看詳情：${shareUrl}

※ 點擊連結可在地圖上開啟此災情標籤`;

        // 複製到剪貼簿
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(shareText).then(() => {
                showToast('🔗 災情標籤資訊已複製！可分享給他人查看', 'success');
                
                // 同時儲存 URL 狀態
                window.history.pushState(
                    { type: 'disaster', reportId, lat, lng }, 
                    `災情 ${reportId}`, 
                    shareUrl
                );
                
            }).catch(err => {
                console.error('複製失敗:', err);
                fallbackCopyDisasterInfo(shareText);
            });
        } else {
            fallbackCopyDisasterInfo(shareText);
        }
        
    } catch (error) {
        console.error('❌ 複製災情標籤資訊失敗:', error);
        showToast('❌ 複製失敗，請稍後再試', 'error');
    }
}
// 🆕 格式化災情時間顯示
function formatDisasterTime(timestamp) {
    if (!timestamp) return '未知';
    
    try {
        // 如果已經是格式化的字串，直接返回
        if (typeof timestamp === 'string' && !timestamp.includes('GMT')) {
            return timestamp;
        }
        
        // 如果是 Date 物件或時間戳記，格式化為台灣時間
        const date = new Date(timestamp);
        if (isNaN(date.getTime())) {
            return timestamp; // 如果無法解析，返回原始值
        }
        
        // 格式化為 YYYY/MM/DD HH:mm:ss 格式
        return date.toLocaleString('zh-TW', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
        });
        
    } catch (error) {
        console.error('時間格式化錯誤:', error);
        return timestamp;
    }
}
// 🆕 備用複製方法
function fallbackCopyDisasterInfo(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        document.execCommand('copy');
        showToast('🔗 災情標籤資訊已複製！可分享給他人查看', 'success');
    } catch (err) {
        console.error('複製失敗:', err);
        showToast('❌ 複製失敗，請手動複製資訊', 'error');
        
        // 顯示文字讓用戶手動複製
        alert('請手動複製以下資訊：\n\n' + text);
    }
    
    document.body.removeChild(textArea);
}

// 🔧 修正版：處理分享連結開啟 - 加入重試機制
function handleDisasterShareLink() {
    const hash = window.location.hash;
    
    // 檢查是否為災情分享連結格式：#disaster/reportId/lat/lng
    const disasterMatch = hash.match(/^#disaster\/([^\/]+)\/([0-9.-]+)\/([0-9.-]+)$/);
    
    if (disasterMatch) {
        const reportId = disasterMatch[1];
        const lat = parseFloat(disasterMatch[2]);
        const lng = parseFloat(disasterMatch[3]);
        
        console.log(`🔗 檢測到災情分享連結: ${reportId} at (${lat}, ${lng})`);
        
        // 🔧 立即嘗試開啟，如果失敗會自動重試
        openSharedDisasterMarker(reportId, lat, lng);
        
        return true;
    }
    
    return false;
}


// 🔧 修正版：開啟分享的災情標籤 - 加入智能重試機制
function openSharedDisasterMarker(reportId, lat, lng, retryCount = 0) {
    const maxRetries = 5; // 最多重試5次
    const retryDelay = 1000; // 每次重試間隔1秒
    
    console.log(`🔗 嘗試開啟災情標籤 (第${retryCount + 1}次): ${reportId}`);
    
    // 確保災情資料已載入
    if (!disasterData || disasterData.length === 0) {
        if (retryCount < maxRetries) {
            console.log(`🔄 災情資料尚未載入，${retryDelay/1000}秒後重試...`);
            showToast(`🔄 災情資料載入中，請稍候... (${retryCount + 1}/${maxRetries})`, 'info');
            
            // 🔧 如果是第一次重試，嘗試載入災情資料
            if (retryCount === 0) {
                loadDisasterData();
            }
            
            setTimeout(() => {
                openSharedDisasterMarker(reportId, lat, lng, retryCount + 1);
            }, retryDelay);
            return;
        } else {
            // 🔧 重試次數用完，顯示位置但無詳細資料
            console.warn('⚠️ 災情資料載入失敗，顯示基本位置資訊');
            showBasicLocationMarker(reportId, lat, lng);
            return;
        }
    }
    
    // 尋找對應的災情報告
    const report = disasterData.find(r => r.id === reportId);
    
    if (report) {
        // 🔧 成功找到報告
        console.log(`✅ 找到災情報告: ${reportId}`);
        
        // 移動地圖到指定位置
        map.setView([lat, lng], 16);
        
        // 建立並顯示災情標記
        const marker = createDisasterMarker(report);
        disasterMarkers.push(marker);
        
        // 開啟彈出視窗
        setTimeout(() => {
            marker.openPopup();
            showToast(`✅ 已開啟分享的災情標籤：${report.id}`, 'success');
        }, 500);
        
    } else {
        // 🔧 找不到報告，但有災情資料，可能是ID不匹配
        console.warn(`⚠️ 找不到災情報告 ${reportId}，但有 ${disasterData.length} 筆災情資料`);
        
        if (retryCount < 2) {
            // 🔧 前兩次重試時，等待更長時間讓資料完全載入
            setTimeout(() => {
                openSharedDisasterMarker(reportId, lat, lng, retryCount + 1);
            }, 2000);
            return;
        }
        
        // 🔧 最終找不到，顯示基本位置
        showBasicLocationMarker(reportId, lat, lng);
    }
}
// 🆕 顯示基本位置標記（當找不到詳細災情資料時）
function showBasicLocationMarker(reportId, lat, lng) {
    console.log(`📍 顯示基本位置標記: ${reportId} at (${lat}, ${lng})`);
    
    // 移動地圖到位置
    map.setView([lat, lng], 16);
    
    // 建立一個基本標記
    const tempMarker = L.marker([lat, lng], {
        icon: L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        })
    }).addTo(map);
    
    tempMarker.bindPopup(`
        <div style="text-align: center; min-width: 200px;">
            <h4 style="color: #dc3545; margin: 0 0 10px 0;">🚨 分享的災情位置</h4>
            <p style="margin: 5px 0;"><strong>災情ID:</strong> ${reportId}</p>
            <p style="margin: 5px 0;"><strong>座標:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
            <div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin: 10px 0; font-size: 12px; color: #856404;">
                ⚠️ 災情詳細資料可能已更新或移除
            </div>
            <div style="margin-top: 15px;">
                <button onclick="refreshDisasterDataAndRetry('${reportId}', ${lat}, ${lng})" 
                        style="padding: 8px 12px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 8px;">
                    🔄 重新載入災情資料
                </button>
                <button onclick="map.removeLayer(this._source._popup._source)" 
                        style="padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    關閉標記
                </button>
            </div>
        </div>
    `).openPopup();
    
    // 儲存標記以便清理
    disasterMarkers.push(tempMarker);
    
    showToast(`📍 已顯示災情位置，但詳細資料可能已更新`, 'warning');
}
// 🆕 重新載入災情資料並重試開啟標籤
function refreshDisasterDataAndRetry(reportId, lat, lng) {
    showToast('🔄 正在重新載入災情資料...', 'info');
    
    // 清除現有標記
    clearDisasterMarkers();
    
    // 重新載入災情資料
    loadDisasterData().then(() => {
        // 載入完成後重試開啟標籤
        setTimeout(() => {
            openSharedDisasterMarker(reportId, lat, lng, 0);
        }, 500);
    }).catch(error => {
        console.error('❌ 重新載入災情資料失敗:', error);
        showToast('❌ 災情資料載入失敗', 'error');
    });
}

// 🆕 取得災情位置名稱
function getDisasterLocationName(report) {
    let locationName = '災情位置';
    
    if (report.location?.tpcMapNumber) {
        locationName = `台電圖號 ${report.location.tpcMapNumber}`;
    } else if (report.location?.poleNumber) {
        locationName = `電桿 ${report.location.poleNumber}`;
    } else if (report['饋線代號']) {
        locationName = `饋線 ${report['饋線代號']} 災情`;
    } else if (Array.isArray(report.incidents) && report.incidents.length > 0) {
        locationName = `${report.incidents[0].type || '災情'} 現場`;
    }
    
    return locationName;
}

// 🆕 開啟 Google 導航
function openNavigation(lat, lng, name) {
    // 檢測是否為行動裝置
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (isMobile) {
        // 行動裝置優先嘗試開啟 Google Maps App
        const appUrl = `google.navigation:q=${lat},${lng}`;
        const fallbackUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_place_id=${encodeURIComponent(name)}`;
        
        // 嘗試開啟 App，失敗則開啟網頁版
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.src = appUrl;
        document.body.appendChild(iframe);
        
        setTimeout(() => {
            document.body.removeChild(iframe);
            window.open(fallbackUrl, '_blank');
        }, 1000);
    } else {
        // 桌面版直接開啟網頁版 Google Maps
        const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_place_id=${encodeURIComponent(name)}`;
        window.open(googleMapsUrl, '_blank');
    }
    
    console.log(`🧭 開啟導航至: ${name} (${lat}, ${lng})`);
    showToast(`🧭 正在開啟導航至 ${decodeURIComponent(name)}`, 'info');
}
// 🆕 縮圖載入錯誤處理
function handleThumbnailError(imgElement, originalUrl, photoIndex) {
    console.log(`❌ 縮圖 ${photoIndex} 載入失敗，顯示 placeholder`);
    
    // 隱藏圖片，顯示 placeholder
    imgElement.style.display = 'none';
    
    const placeholder = imgElement.parentElement.querySelector('.photo-placeholder');
    if (placeholder) {
        placeholder.style.display = 'flex';
        placeholder.style.background = '#fff3cd';
        placeholder.style.borderColor = '#ffc107';
        placeholder.innerHTML = `📷<br>照片<br>${parseInt(photoIndex) + 1}<br><span style="font-size: 6px;">點擊嘗試載入</span>`;
        
        // 讓 placeholder 也可以點擊
        placeholder.style.cursor = 'pointer';
        placeholder.onclick = function() {
            openPhotoModalSafe(originalUrl, `temp_${photoIndex}`);
        };
    }
}

// 照片放大功能
function openPhotoModal(photoUrl, photoId) {
    console.log(`打開照片模態框: ${photoId}, URL: ${photoUrl}`);
    
    const parts = photoId.split('_');
    const reportId = parts[0];
    const photoIndex = parseInt(parts[1] || 0);
    
    const report = disasterData.find(r => r.id === reportId);
    if (report && report.photos && Array.isArray(report.photos)) {
        currentReportId = reportId;
        currentReportPhotos = report.photos;
        currentPhotoIndex = Math.min(photoIndex, currentReportPhotos.length - 1);
        
        setupPhotoModal();
        updatePhotoCounter();
        showCurrentPhoto();
    } else {
        setupSimplePhotoModal(photoUrl);
    }
}

// 設置照片模態框
function setupPhotoModal(isSimpleMode = false) {
    let photoModal = document.getElementById('photo-modal');
    if (!photoModal) {
        photoModal = document.createElement('div');
        photoModal.id = 'photo-modal';
        photoModal.className = 'photo-modal';
        document.body.appendChild(photoModal);
    }
    
    let modalContent = `
        <span class="photo-modal-close" onclick="closePhotoModal()">&times;</span>
        <img class="photo-modal-content" id="modal-photo" 
             onerror="this.onerror=null; this.src='https://via.placeholder.com/400x300?text=照片載入失敗';">
    `;
    
    if (!isSimpleMode && currentReportPhotos.length > 1) {
        modalContent += `
            <div class="photo-navigation">
                <button class="photo-nav-btn" onclick="showPrevPhoto()">&lt;</button>
                <button class="photo-nav-btn" onclick="showNextPhoto()">&gt;</button>
            </div>
            <div class="photo-counter" id="photo-counter"></div>
        `;
    }
    
    photoModal.innerHTML = modalContent;
    photoModal.style.display = 'block';
    
    photoModal.onclick = function(event) {
        if (event.target === photoModal) {
            closePhotoModal();
        }
    };
}

// 設置簡單照片模態框
function setupSimplePhotoModal(photoUrl) {
    currentReportId = null;
    currentReportPhotos = [photoUrl];
    currentPhotoIndex = 0;
    
    setupPhotoModal(true);
    
    const modalPhoto = document.getElementById('modal-photo');
    if (modalPhoto) {
        modalPhoto.src = photoUrl;
    }
}

// 顯示當前照片
function showCurrentPhoto() {
    if (!currentReportPhotos || currentReportPhotos.length === 0) return;
    
    const photo = currentReportPhotos[currentPhotoIndex];
    let photoUrl = typeof photo === 'string' ? photo : (photo.url || '');
    
    const modalPhoto = document.getElementById('modal-photo');
    if (modalPhoto && photoUrl) {
        modalPhoto.src = photoUrl;
    }
    
    updatePhotoCounter();
}

// 更新照片計數器
function updatePhotoCounter() {
    const counterElement = document.getElementById('photo-counter');
    if (counterElement && currentReportPhotos.length > 1) {
        counterElement.textContent = `${currentPhotoIndex + 1} / ${currentReportPhotos.length}`;
    }
}
// 🔧 修正版：上一張照片 - 加入防抖機制
let photoSwitchTimeout = null;
function showPrevPhoto() {
    if (!currentReportPhotos || currentReportPhotos.length <= 1) return;
    
    // 🔧 防抖機制：避免快速連續點擊
    if (photoSwitchTimeout) {
        clearTimeout(photoSwitchTimeout);
    }
    
    photoSwitchTimeout = setTimeout(() => {
        currentPhotoIndex = (currentPhotoIndex - 1 + currentReportPhotos.length) % currentReportPhotos.length;
        showCurrentPhotoSafe();
        photoSwitchTimeout = null;
    }, 100); // 100ms 防抖
}

// 🔧 修正版：下一張照片 - 加入防抖機制
function showNextPhoto() {
    if (!currentReportPhotos || currentReportPhotos.length <= 1) return;
    
    // 🔧 防抖機制：避免快速連續點擊
    if (photoSwitchTimeout) {
        clearTimeout(photoSwitchTimeout);
    }
    
    photoSwitchTimeout = setTimeout(() => {
        currentPhotoIndex = (currentPhotoIndex + 1) % currentReportPhotos.length;
        showCurrentPhotoSafe();
        photoSwitchTimeout = null;
    }, 100); // 100ms 防抖
}

// 🔧 修正版：關閉照片模態框 - 確保完全清理
function closePhotoModal() {
    const photoModal = document.getElementById('photo-modal');
    if (photoModal) {
        // 🔧 重要：清除所有載入狀態
        const modalPhoto = document.getElementById('modal-photo');
        if (modalPhoto) {
            hidePhotoLoadingState(modalPhoto);
            clearPhotoEventHandlers(modalPhoto);
        }
        
        // 🔧 清除防抖計時器
        if (photoSwitchTimeout) {
            clearTimeout(photoSwitchTimeout);
            photoSwitchTimeout = null;
        }
        
        photoModal.style.display = 'none';
    }
    
    // 🆕 移除鍵盤事件監聽器
    document.removeEventListener('keydown', handlePhotoModalKeydown);
    
    currentPhotoIndex = 0;
    currentReportId = null;
    currentReportPhotos = [];
}

// 打開街景圖
function openStreetView(lat, lng) {
    if (!lat || !lng || isNaN(parseFloat(lat)) || isNaN(parseFloat(lng))) {
        alert('無法獲取有效的位置資訊，無法查看街景');
        return;
    }
    
    const streetViewUrl = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lat},${lng}`;
    window.open(streetViewUrl, '_blank');
}

// 派修模態框功能（簡化版）
function openRepairModal(reportId) {
    const report = disasterData.find(r => r.id === reportId);
    if (!report) return;
    
    const newStatus = prompt(`目前狀態：${report['修復狀態'] || '未修復'}\n\n請選擇新狀態：\n1. 未修復\n2. 已派修\n3. 已修復\n\n請輸入數字 1-3:`);
    
    if (newStatus) {
        let status;
        switch(newStatus) {
            case '1': status = '未修復'; break;
            case '2': status = '已派修'; break;
            case '3': status = '已修復'; break;
            default: return;
        }
        
        // 更新本地資料
        report['修復狀態'] = status;
        if (status === '已派修' || status === '已修復') {
            report['派修時間'] = new Date().toLocaleString('zh-TW');
            report['修復人員'] = prompt('請輸入派修人員姓名:') || '未指定';
        }
        
        // 重新建立清單和標記
        createDisasterReportList();
        showDisasterReportDetails(report);
        
        showToast(`✅ 已更新為：${status}`, 'success');
    }
}

// 篩選災情報告
function filterDisasterReports() {
    const filter = document.getElementById('disasterFilter').value;
    
    let filteredData = disasterData;
    if (filter !== 'all') {
        filteredData = disasterData.filter(report => (report['修復狀態'] || '未修復') === filter);
    }
    
    // 暫時替換資料進行顯示
    const originalData = disasterData;
    disasterData = filteredData;
    createDisasterReportList();
    disasterData = originalData;
}

// 🔧 修正版：重新整理災情資料 - 保持地圖狀態
async function refreshDisasterData() {
    updateDisasterStatus('正在重新整理...');
    
    // 🔧 記住當前地圖顯示狀態
    const wasVisible = disasterMapVisible;
    
    const success = await loadDisasterData();
    if (success) {
        showToast('✅ 災情資料已更新', 'success');
        
        // 🔧 如果之前地圖是顯示的，重新顯示
        if (wasVisible) {
            setTimeout(() => {
                displayDisasterMap();
            }, 500);
        }
    } else {
        showToast('❌ 災情資料更新失敗', 'error');
    }
}
// 🔧 修正版：災情地圖狀態管理
let disasterMapVisible = false; // 追蹤災情地圖顯示狀態
// 🔧 修正版：顯示/隱藏災情地圖 - 切換功能
function showDisasterMap() {
    if (!disasterData || disasterData.length === 0) {
        showToast('❌ 無災情資料可顯示', 'error');
        return;
    }
    
    if (disasterMapVisible) {
        // 目前顯示中，執行隱藏
        hideDisasterMap();
    } else {
        // 目前隱藏中，執行顯示
        displayDisasterMap();
    }
}
// 🆕 顯示災情地圖
function displayDisasterMap() {
    console.log('🗺️ 顯示災情地圖...');
    
    // 清除現有標記（防止重複）
    clearDisasterMarkers();
    
    let markerCount = 0;
    const bounds = L.latLngBounds();
    
    disasterData.forEach(report => {
        if (report.location && report.location.latitude && report.location.longitude) {
            const marker = createDisasterMarker(report);
            disasterMarkers.push(marker);
            bounds.extend([report.location.latitude, report.location.longitude]);
            markerCount++;
        }
    });
    
    if (markerCount > 0) {
        map.fitBounds(bounds, { padding: [20, 20] });
        disasterMapVisible = true;
        updateDisasterMapButton();
        showToast(`🗺️ 已顯示 ${markerCount} 個災情位置`, 'success');
    } else {
        showToast('❌ 無有效位置資料可顯示', 'error');
    }
}

// 🆕 隱藏災情地圖
function hideDisasterMap() {
    console.log('🗺️ 隱藏災情地圖...');
    
    clearDisasterMarkers();
    disasterMapVisible = false;
    updateDisasterMapButton();
    showToast('✅ 已隱藏所有災情標記', 'info');
}
// 🆕 更新災情地圖按鈕文字
function updateDisasterMapButton() {
    // 🔧 尋找災情地圖按鈕並更新文字
    const disasterMapButtons = document.querySelectorAll('button[onclick="showDisasterMap()"]');
    
    disasterMapButtons.forEach(button => {
        if (disasterMapVisible) {
            button.textContent = '🙈 隱藏災情';
            button.style.background = '#6c757d';
            button.title = '點擊隱藏所有災情標記';
        } else {
            button.textContent = '🗺️ 災情地圖';
            button.style.background = '#28a745';
            button.title = '點擊顯示所有災情標記';
        }
    });
    
    console.log(`🔄 災情地圖按鈕已更新: ${disasterMapVisible ? '隱藏模式' : '顯示模式'}`);
}

// 🔧 修正版：清除災情標記 - 加入狀態重置
function clearDisasterMarkers() {
    console.log(`🧹 清除 ${disasterMarkers.length} 個災情標記...`);
    
    disasterMarkers.forEach(marker => {
        if (map.hasLayer(marker)) {
            map.removeLayer(marker);
        }
    });
    disasterMarkers = [];
    
    // 🔧 關閉任何開啟的彈出視窗
    map.closePopup();
}

// 🆕 修正 Google Drive 照片 URL
// 🔧 完全修正版：Google Drive 照片 URL 處理 - 多重備援方案
function fixGoogleDrivePhotoUrl(url, isModal = false) {
    if (!url) return '';
    
    console.log('🔍 處理照片 URL:', url, '模態框模式:', isModal);
    
    // 如果是 Google Drive 連結
    if (url.includes('drive.google.com')) {
        // 提取檔案 ID
        let fileId = '';
        
        // 方法1: 從 /file/d/ 格式提取
        const fileMatch = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
        if (fileMatch) {
            fileId = fileMatch[1];
        }
        
        // 方法2: 從 id= 參數提取
        if (!fileId) {
            const idMatch = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
            if (idMatch) {
                fileId = idMatch[1];
            }
        }
        
        if (fileId) {
            if (isModal) {
                // 🔧 模態框使用多重備援方案
                // 優先使用較大的縮圖，而非直接下載
                const largeUrl = `https://drive.google.com/thumbnail?id=${fileId}&sz=w800-h600`;
                console.log('✅ 轉換為大尺寸縮圖 URL:', largeUrl);
                return largeUrl;
            } else {
                // 🔧 縮圖預覽使用小尺寸
                const thumbnailUrl = `https://drive.google.com/thumbnail?id=${fileId}&sz=w200-h200`;
                console.log('✅ 轉換為縮圖 URL:', thumbnailUrl);
                return thumbnailUrl;
            }
        }
    }
    
    // 如果不是 Google Drive 或無法提取 ID，直接返回原 URL
    console.log('⚠️ 使用原始 URL:', url);
    return url;
}

// 🆕 照片載入錯誤處理
function handlePhotoLoadError(imgElement, photoIndex) {
    console.log(`❌ 照片 ${photoIndex} 載入失敗`);
    
    // 隱藏圖片，顯示 placeholder
    imgElement.style.display = 'none';
    
    const placeholder = imgElement.parentElement.querySelector('.photo-placeholder');
    if (placeholder) {
        placeholder.style.display = 'flex';
    }
    
    // 設定背景色表示載入失敗
    imgElement.parentElement.style.background = '#fff3cd';
    imgElement.parentElement.style.borderColor = '#ffc107';
}

// 🔧 修正版：安全的照片模態框開啟
function openPhotoModalSafe(originalUrl, photoId) {
    console.log(`🖼️ 安全開啟照片模態框: ${photoId}`);
    
    const parts = photoId.split('_');
    const reportId = parts[0];
    const photoIndex = parseInt(parts[1] || 0);
    
    const report = disasterData.find(r => r.id === reportId);
    if (report && report.photos && Array.isArray(report.photos)) {
        currentReportId = reportId;
        currentReportPhotos = report.photos;
        currentPhotoIndex = Math.min(photoIndex, currentReportPhotos.length - 1);
        
        setupPhotoModalSafe();
        updatePhotoCounter();
        showCurrentPhotoSafe();
    } else {
        // 簡單模式：只顯示單張照片
        setupSimplePhotoModalSafe(originalUrl);
    }
}

// 🔧 修正版：安全的照片模態框設置 - 改善尺寸控制
function setupPhotoModalSafe() {
    let photoModal = document.getElementById('photo-modal');
    if (!photoModal) {
        photoModal = document.createElement('div');
        photoModal.id = 'photo-modal';
        photoModal.className = 'photo-modal';
        document.body.appendChild(photoModal);
    }
    
    let modalContent = `
        <span class="photo-modal-close" onclick="closePhotoModal()">&times;</span>
        <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; padding: 50px 20px 20px 20px; box-sizing: border-box;">
            <img class="photo-modal-content" id="modal-photo" 
                 style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);"
                 onerror="handleModalPhotoError(this)">
        </div>
    `;
    
    if (currentReportPhotos && currentReportPhotos.length > 1) {
        modalContent += `
            <div class="photo-navigation">
                <button class="photo-nav-btn" onclick="showPrevPhoto()" 
                        style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 20px; cursor: pointer; z-index: 2002;">
                    &#8249;
                </button>
                <button class="photo-nav-btn" onclick="showNextPhoto()"
                        style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 20px; cursor: pointer; z-index: 2002;">
                    &#8250;
                </button>
            </div>
            <div class="photo-counter" id="photo-counter" 
                 style="position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; z-index: 2001;">
            </div>
        `;
    }
    
    photoModal.innerHTML = modalContent;
    photoModal.style.display = 'block';
    
    // 點擊背景關閉
    photoModal.onclick = function(event) {
        if (event.target === photoModal) {
            closePhotoModal();
        }
    };
    
    // 🆕 鍵盤控制
    document.addEventListener('keydown', handlePhotoModalKeydown);
}
// 🔧 修正版：鍵盤控制處理 - 加入防抖
function handlePhotoModalKeydown(event) {
    const photoModal = document.getElementById('photo-modal');
    if (!photoModal || photoModal.style.display === 'none') return;
    
    // 🔧 防止快速按鍵
    if (photoSwitchTimeout) return;
    
    switch(event.key) {
        case 'Escape':
            closePhotoModal();
            break;
        case 'ArrowLeft':
            event.preventDefault();
            showPrevPhoto();
            break;
        case 'ArrowRight':
            event.preventDefault();
            showNextPhoto();
            break;
    }
}
// 🔧 修正版：簡單照片模態框設置
function setupSimplePhotoModalSafe(photoUrl) {
    currentReportId = null;
    currentReportPhotos = [photoUrl];
    currentPhotoIndex = 0;
    
    setupPhotoModalSafe();
    
    const modalPhoto = document.getElementById('modal-photo');
    if (modalPhoto) {
        // 🔧 重要：使用原尺寸照片
        const processedUrl = fixGoogleDrivePhotoUrl(photoUrl, true);
        modalPhoto.src = processedUrl;
        modalPhoto.style.opacity = '0.5';
        modalPhoto.onload = function() {
            this.style.opacity = '1';
        };
    }
}


// 🔧 修正版：安全顯示當前照片 - 加入載入狀態管理
function showCurrentPhotoSafe() {
    if (!currentReportPhotos || currentReportPhotos.length === 0) return;
    
    const photo = currentReportPhotos[currentPhotoIndex];
    let photoUrl = typeof photo === 'string' ? photo : (photo.url || '');
    
    const modalPhoto = document.getElementById('modal-photo');
    if (modalPhoto && photoUrl) {
        // 🔧 重要：先清除之前的載入狀態
        hidePhotoLoadingState(modalPhoto);
        clearPhotoEventHandlers(modalPhoto);
        
        // 🆕 顯示載入狀態
        showPhotoLoadingState(modalPhoto);
        
        // 🔧 使用大尺寸縮圖而非直接下載
        const processedUrl = fixGoogleDrivePhotoUrl(photoUrl, true);
        
        // 🔧 重要：設置載入完成和錯誤處理（只設置一次）
        modalPhoto.onload = function() {
            hidePhotoLoadingState(this);
            console.log(`✅ 照片載入成功: ${processedUrl}`);
        };
        
        modalPhoto.onerror = function() {
            hidePhotoLoadingState(this);
            handleModalPhotoError(this);
        };
        
        // 🔧 重要：最後才設置 src，避免事件處理器未就緒
        modalPhoto.src = processedUrl;
        
        console.log(`🖼️ 開始載入照片: ${processedUrl}`);
    }
    
    updatePhotoCounter();
}
// 🆕 清除照片事件處理器
function clearPhotoEventHandlers(imgElement) {
    imgElement.onload = null;
    imgElement.onerror = null;
}
// 🆕 顯示照片載入狀態
// 🔧 修正版：顯示照片載入狀態 - 避免重複創建
function showPhotoLoadingState(imgElement) {
    if (!imgElement || !imgElement.parentElement) return;
    
    // 🔧 重要：先清除現有的載入指示器
    hidePhotoLoadingState(imgElement);
    
    imgElement.style.opacity = '0.3';
    imgElement.style.filter = 'blur(2px)';
    
    // 🔧 重要：檢查是否已存在載入指示器
    if (document.getElementById('photo-loading')) {
        return; // 已存在，不重複創建
    }
    
    // 創建載入指示器
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'photo-loading';
    loadingDiv.className = 'photo-loading-indicator'; // 🆕 加入 class 便於識別
    loadingDiv.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 15px 25px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 2003;
        display: flex;
        align-items: center;
        gap: 10px;
        pointer-events: none;
    `;
    
    loadingDiv.innerHTML = `
        <div style="width: 20px; height: 20px; border: 2px solid #fff; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
        載入中...
        <style>
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    `;
    
    imgElement.parentElement.appendChild(loadingDiv);
    
    // 🆕 安全措施：10秒後自動清除載入狀態
    setTimeout(() => {
        if (document.getElementById('photo-loading')) {
            console.log('⏰ 載入超時，自動清除載入狀態');
            hidePhotoLoadingState(imgElement);
        }
    }, 10000);
}

// 🔧 修正版：隱藏照片載入狀態 - 確保完全清除
function hidePhotoLoadingState(imgElement) {
    if (!imgElement) return;
    
    imgElement.style.opacity = '1';
    imgElement.style.filter = 'none';
    
    // 🔧 重要：清除所有可能的載入指示器
    const existingLoading = document.querySelectorAll('#photo-loading');
    existingLoading.forEach(loading => loading.remove());
    
    // 🔧 額外檢查父容器中的載入指示器
    if (imgElement.parentElement) {
        const parentLoading = imgElement.parentElement.querySelectorAll('[id*="loading"], [class*="loading"]');
        parentLoading.forEach(loading => {
            if (loading.id === 'photo-loading' || loading.className.includes('photo-loading')) {
                loading.remove();
            }
        });
    }
}
// 🔧 增強版：模態框照片錯誤處理 - 多重備援
function handleModalPhotoError(imgElement) {
    console.log('❌ 模態框照片載入失敗，嘗試備援方案...');
    
    const originalSrc = imgElement.src;
    const currentReportPhoto = currentReportPhotos[currentPhotoIndex];
    let originalUrl = typeof currentReportPhoto === 'string' ? currentReportPhoto : (currentReportPhoto?.url || '');
    
    // 🔧 嘗試不同的備援方案
    if (originalSrc.includes('sz=w800-h600')) {
        // 第一次失敗，嘗試更大的尺寸
        const fileId = extractFileIdFromUrl(originalUrl);
        if (fileId) {
            const xlUrl = `https://drive.google.com/thumbnail?id=${fileId}&sz=w1200-h900`;
            console.log('🔄 嘗試超大尺寸:', xlUrl);
            imgElement.src = xlUrl;
            imgElement.onerror = () => handleModalPhotoError2(imgElement, originalUrl);
            return;
        }
    }
    
    // 如果所有方案都失敗，顯示錯誤訊息
    showPhotoErrorMessage(imgElement, originalUrl);
}
// 🆕 第二層備援處理
function handleModalPhotoError2(imgElement, originalUrl) {
    console.log('❌ 第二層備援也失敗，嘗試原始 URL...');
    
    // 嘗試使用原始 URL
    if (originalUrl && originalUrl !== imgElement.src) {
        imgElement.src = originalUrl;
        imgElement.onerror = () => showPhotoErrorMessage(imgElement, originalUrl);
    } else {
        showPhotoErrorMessage(imgElement, originalUrl);
    }
}
// 🆕 顯示照片錯誤訊息
function showPhotoErrorMessage(imgElement, originalUrl) {
    console.log('❌ 所有照片載入方案都失敗');
    
    // 創建錯誤提示
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 400px;
        height: 300px;
        background: #f8f9fa;
        border: 2px dashed #dee2e6;
        border-radius: 8px;
        color: #6c757d;
        font-size: 16px;
        text-align: center;
        margin: 20px;
    `;
    
    errorDiv.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 15px;">📷</div>
        <div style="font-weight: bold; margin-bottom: 10px;">照片暫時無法載入</div>
        <div style="font-size: 14px; margin-bottom: 15px; color: #999;">
            可能是網路問題或照片權限設定
        </div>
        <button onclick="retryLoadPhoto('${originalUrl}')" 
                style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
            🔄 重新載入
        </button>
        <button onclick="openOriginalPhotoLink('${originalUrl}')" 
                style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; margin-top: 8px;">
            🔗 開啟原始連結
        </button>
    `;
    
    // 替換圖片元素
    imgElement.parentElement.replaceChild(errorDiv, imgElement);
}

// 🆕 重新載入照片
function retryLoadPhoto(originalUrl) {
    console.log('🔄 重新載入照片:', originalUrl);
    
    // 重新設置模態框
    showCurrentPhotoSafe();
}

// 🆕 開啟原始照片連結
function openOriginalPhotoLink(originalUrl) {
    if (originalUrl) {
        window.open(originalUrl, '_blank');
    } else {
        showToast('❌ 無法取得原始照片連結', 'error');
    }
}

// 🆕 從 URL 提取檔案 ID
function extractFileIdFromUrl(url) {
    if (!url) return null;
    
    // 方法1: 從 /file/d/ 格式提取
    const fileMatch = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
    if (fileMatch) {
        return fileMatch[1];
    }
    
    // 方法2: 從 id= 參數提取
    const idMatch = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
    if (idMatch) {
        return idMatch[1];
    }
    
    return null;
}


// 🆕 災情地圖工具列功能
function createDisasterMapToolbar() {
    // 檢查是否已存在工具列
    let toolbar = document.getElementById('disaster-map-toolbar');
    if (toolbar) return;
    
    // 創建工具列
    toolbar = document.createElement('div');
    toolbar.id = 'disaster-map-toolbar';
    toolbar.style.cssText = `
        position: absolute;
        top: 60px;
        right: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        display: none;
        flex-direction: column;
        gap: 8px;
        min-width: 140px;
    `;
    
    toolbar.innerHTML = `
        <button onclick="showDisasterMap()" 
                style="padding: 8px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
            🗺️ 災情地圖
        </button>
        <button onclick="filterDisasterByStatus('未修復')" 
                style="padding: 8px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
            🔴 未修復
        </button>
        <button onclick="filterDisasterByStatus('已派修')" 
                style="padding: 8px 12px; background: #ffc107; color: #212529; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
            🟡 已派修
        </button>
        <button onclick="filterDisasterByStatus('已修復')" 
                style="padding: 8px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
            🟢 已修復
        </button>
        <button onclick="hideDisasterMapToolbar()" 
                style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
            ✕ 關閉
        </button>
    `;
    
    document.querySelector('.map-container').appendChild(toolbar);
}

// 🆕 顯示災情地圖工具列
function showDisasterMapToolbar() {
    createDisasterMapToolbar();
    const toolbar = document.getElementById('disaster-map-toolbar');
    if (toolbar) {
        toolbar.style.display = 'flex';
    }
}

// 🆕 隱藏災情地圖工具列
function hideDisasterMapToolbar() {
    const toolbar = document.getElementById('disaster-map-toolbar');
    if (toolbar) {
        toolbar.style.display = 'none';
    }
}

// 🆕 按狀態篩選災情標記
function filterDisasterByStatus(status) {
    console.log(`🔍 篩選災情狀態: ${status}`);
    
    // 先清除現有標記
    clearDisasterMarkers();
    
    if (!disasterData || disasterData.length === 0) {
        showToast('❌ 無災情資料可顯示', 'error');
        return;
    }
    
    // 篩選資料
    const filteredData = disasterData.filter(report => {
        const repairStatus = report['修復狀態'] || '未修復';
        return repairStatus === status;
    });
    
    if (filteredData.length === 0) {
        showToast(`❌ 沒有 "${status}" 的災情資料`, 'warning');
        disasterMapVisible = false;
        updateDisasterMapButton();
        return;
    }
    
    // 顯示篩選後的標記
    let markerCount = 0;
    const bounds = L.latLngBounds();
    
    filteredData.forEach(report => {
        if (report.location && report.location.latitude && report.location.longitude) {
            const marker = createDisasterMarker(report);
            disasterMarkers.push(marker);
            bounds.extend([report.location.latitude, report.location.longitude]);
            markerCount++;
        }
    });
    
    if (markerCount > 0) {
        map.fitBounds(bounds, { padding: [20, 20] });
        disasterMapVisible = true;
        updateDisasterMapButton();
        showToast(`🗺️ 已顯示 ${markerCount} 個 "${status}" 災情`, 'success');
    }
}

// 🆕 災情地圖快捷鍵
document.addEventListener('keydown', function(e) {
    // Ctrl + D: 切換災情地圖
    if (e.ctrlKey && e.key === 'd') {
        e.preventDefault();
        showDisasterMap();
    }
    
    // Ctrl + Shift + D: 顯示災情工具列
    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        e.preventDefault();
        showDisasterMapToolbar();
    }
});

// 🔧 修正版：初始化時設置按鈕狀態
document.addEventListener('DOMContentLoaded', function() {
    // 延遲設置按鈕狀態，確保 DOM 完全載入
    setTimeout(() => {
        updateDisasterMapButton();
    }, 1000);
});

// 🆕 Supabase 配置
// 🔧 修正：使用您的 Supabase 配置
const SUPABASE_URL = 'https://ulxrlnlebuxforumrsxi.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVseHJsbmxlYnV4Zm9ydW1yc3hpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE2ODkxNjQsImV4cCI6MjA2NzI2NTE2NH0.xn9E81cq1-repD9ku-0UwTupqk-2e0f929Dnyl1OB6M';

let supabase;

// 🔧 修正：初始化 Supabase 連接
function initSupabase() {
    try {
        if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            console.log('✅ Supabase 連接成功');
            return true;
        } else {
            console.error('❌ Supabase SDK 未載入');
            return false;
        }
    } catch (error) {
        console.error('❌ Supabase 連接失敗:', error);
        return false;
    }
}

// 🆕 搜尋鄰近設備和饋線
// 🔧 修正版：搜尋鄰近設備和饋線 - 配合實際資料庫結構
async function searchNearbyFeatures(lat, lng, radiusKm = 2) {
    if (!supabase) {
        showToast('❌ 資料庫連接未初始化', 'error');
        return null;
    }

    try {
        console.log(`🔍 搜尋位置 (${lat}, ${lng}) 半徑 ${radiusKm}km 內的設備和饋線...`);
        
        // 🔧 計算搜尋邊界（粗略估算）
        const latDelta = radiusKm * 0.009; // 約 1km = 0.009度
        const lngDelta = radiusKm * 0.009;
        
        // 🔧 修正：搜尋鄰近設備 - 使用實際的資料庫欄位
        const { data: nearbyDevices, error: devicesError } = await supabase
            .from('devices')
            .select(`
                id,
                feeder_name,
                device_id,
                lat,
                lng,
                fsc,
                area,
                location_name,
                properties
            `)
            .gte('lat', lat - latDelta)
            .lte('lat', lat + latDelta)
            .gte('lng', lng - lngDelta)
            .lte('lng', lng + lngDelta)
            .limit(200); // 限制結果數量

        if (devicesError) {
            console.error('設備查詢錯誤:', devicesError);
            throw devicesError;
        }

        // 🔧 修正：搜尋鄰近饋線 - 使用實際的資料庫欄位
        const { data: nearbyFeeders, error: feedersError } = await supabase
            .from('feeders')
            .select(`
                id,
                name,
                center_lat,
                center_lng,
                device_count,
                line_count,
                total_length,
                areas
            `)
            .gte('center_lat', lat - latDelta)
            .lte('center_lat', lat + latDelta)
            .gte('center_lng', lng - lngDelta)
            .lte('center_lng', lng + lngDelta)
            .limit(50); // 限制饋線數量

        if (feedersError) {
            console.error('饋線查詢錯誤:', feedersError);
            throw feedersError;
        }

        // 🔧 計算精確距離並過濾
        const devicesWithDistance = (nearbyDevices || []).map(device => {
            const distance = calculateDistance(lat, lng, device.lat, device.lng);
            return { ...device, distance };
        }).filter(device => device.distance <= radiusKm)
          .sort((a, b) => a.distance - b.distance);

        const feedersWithDistance = (nearbyFeeders || []).map(feeder => {
            const distance = calculateDistance(lat, lng, feeder.center_lat, feeder.center_lng);
            return { ...feeder, distance };
        }).filter(feeder => feeder.distance <= radiusKm)
          .sort((a, b) => a.distance - b.distance);

        console.log(`✅ 找到 ${devicesWithDistance.length} 個鄰近設備, ${feedersWithDistance.length} 條鄰近饋線`);

        return {
            devices: devicesWithDistance,
            feeders: feedersWithDistance,
            searchLocation: { lat, lng },
            searchRadius: radiusKm
        };

    } catch (error) {
        console.error('❌ 搜尋鄰近設備失敗:', error);
        showToast(`❌ 搜尋失敗: ${error.message}`, 'error');
        return null;
    }
}

// 🆕 計算兩點間距離（公里）
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // 地球半徑（公里）
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}
// 🆕 全域變數：儲存搜尋相關的圖層
let searchMarkers = [];
let searchCircle = null;
let deviceMarkers = [];
// 🆕 顯示鄰近搜尋結果
// 🔧 修正版：顯示鄰近搜尋結果 - 加入圓圈控制和設備顯示
function displayNearbyResults(results) {
    if (!results) return;

    const { devices, feeders, searchLocation, searchRadius } = results;

    // 清除之前的搜尋結果
    clearSearchResults();

    // 🔧 在地圖上標記搜尋中心
    const searchMarker = L.marker([searchLocation.lat, searchLocation.lng], {
        icon: L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        })
    }).addTo(map);

    searchMarker.bindPopup(`
        <div style="text-align: center;">
            <h4>📍 搜尋中心</h4>
            <p>半徑: ${searchRadius < 1 ? (searchRadius * 1000) + 'm' : searchRadius + 'km'}</p>
            <p>找到 ${devices.length} 個設備</p>
            <p>找到 ${feeders.length} 條饋線</p>
        </div>
    `).openPopup();

    searchMarkers.push(searchMarker);

    // 🔧 根據設定顯示搜尋範圍圓圈
    const showCircle = document.getElementById('showSearchCircle')?.checked !== false;
    if (showCircle) {
        searchCircle = L.circle([searchLocation.lat, searchLocation.lng], {
            color: '#007bff',
            fillColor: '#007bff',
            fillOpacity: 0.1,
            radius: searchRadius * 1000 // 轉換為公尺
        }).addTo(map);
    }

    // 🆕 在地圖上顯示附近的設備
    displayDevicesOnMap(devices);

    // 🔧 在側邊欄顯示結果
    showNearbyResultsInSidebar(results);

    // 🔧 調整地圖視野
    const bounds = L.latLngBounds();
    bounds.extend([searchLocation.lat, searchLocation.lng]);
    
    devices.forEach(device => {
        bounds.extend([device.lat, device.lng]);
    });
    
    feeders.forEach(feeder => {
        if (feeder.center_lat && feeder.center_lng) {
            bounds.extend([feeder.center_lat, feeder.center_lng]);
        }
    });

    if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [20, 20] });
    }

    // 🆕 自動載入最近的饋線（如果啟用）
    const autoLoad = document.getElementById('autoLoadFeeder')?.checked;
    if (autoLoad && feeders.length > 0) {
        const nearestFeeder = feeders[0];
        showToast(`🔄 自動載入最近的饋線: ${nearestFeeder.name}`, 'info');
        setTimeout(() => {
            loadNearbyFeeder(nearestFeeder.name, nearestFeeder.distance);
        }, 1000);
    }

    const radiusText = searchRadius < 1 ? `${searchRadius * 1000}公尺` : `${searchRadius}公里`;
    showToast(`🎯 找到 ${devices.length} 個設備和 ${feeders.length} 條饋線 (半徑${radiusText})`, 'success');
}

// 🆕 清除搜尋結果
// 🔧 修正版：清除搜尋結果 - 確保圓圈能正確移除
function clearSearchResults() {
    console.log('🧹 開始清除搜尋結果...');
    
    // 清除搜尋標記
    searchMarkers.forEach(marker => {
        if (map.hasLayer(marker)) {
            map.removeLayer(marker);
        }
    });
    searchMarkers = [];
    
    // 🔧 重要修正：確保搜尋圓圈能正確移除
    if (searchCircle && map.hasLayer(searchCircle)) {
        map.removeLayer(searchCircle);
        searchCircle = null;
        console.log('✅ 搜尋圓圈已移除');
    }
    
    // 清除設備標記
    deviceMarkers.forEach(marker => {
        if (map.hasLayer(marker)) {
            map.removeLayer(marker);
        }
    });
    deviceMarkers = [];
    
    console.log('✅ 搜尋結果清除完成');
}
// 🆕 在地圖上顯示設備
// 🔧 修正版：在地圖上顯示設備 - 避免 Leaflet 錯誤
function displayDevicesOnMap(devices) {
    // 清除之前的設備標記
    deviceMarkers.forEach(marker => {
        try {
            if (map.hasLayer(marker)) {
                map.removeLayer(marker);
            }
        } catch (error) {
            console.warn('清除設備標記時發生錯誤:', error);
        }
    });
    deviceMarkers = [];

    devices.forEach((device, index) => {
        try {
            const deviceIcon = getDeviceIcon(device.fsc);
            
            const marker = L.marker([device.lat, device.lng], {
                icon: L.icon({
                    iconUrl: deviceIcon.url,
                    iconSize: deviceIcon.size,
                    iconAnchor: deviceIcon.anchor,
                    popupAnchor: [1, -34]
                })
            });

            // 🔧 重要：先加入到陣列，再加入到地圖
            deviceMarkers.push(marker);
            marker.addTo(map);

            // 設備資訊彈窗
            marker.bindPopup(`
                <div style="min-width: 200px;">
                    <h4 style="margin: 0 0 10px 0; color: #007bff;">${getDeviceTypeName(device.fsc)}</h4>
                    <p style="margin: 5px 0;"><strong>設備ID:</strong> ${device.device_id || 'N/A'}</p>
                    <p style="margin: 5px 0;"><strong>饋線:</strong> ${device.feeder_name}</p>
                    <p style="margin: 5px 0;"><strong>位置:</strong> ${device.location_name || 'N/A'}</p>
                    <p style="margin: 5px 0;"><strong>區域:</strong> ${device.area || 'N/A'}</p>
                    <p style="margin: 5px 0;"><strong>距離:</strong> ${device.distance.toFixed(2)} km</p>
                    <p style="margin: 5px 0;"><strong>座標:</strong> ${device.lat.toFixed(6)}, ${device.lng.toFixed(6)}</p>
                    <div style="margin-top: 10px;">
                        <button onclick="loadNearbyFeeder('${device.feeder_name}', 0)" 
                                style="width: 100%; padding: 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            載入此設備的饋線
                        </button>
                    </div>
                </div>
            `);

        } catch (error) {
            console.error(`創建設備標記 ${index} 時發生錯誤:`, error, device);
        }
    });

    console.log(`✅ 成功顯示 ${deviceMarkers.length} 個設備標記`);
}

// 🔧 調試版：在側邊欄顯示搜尋結果 - 加入更多調試資訊
function showNearbyResultsInSidebar(results) {
    const sidebar = document.querySelector('.sidebar');
    if (!sidebar) {
        console.error('❌ 找不到側邊欄');
        return;
    }

    console.log('📋 準備在側邊欄顯示搜尋結果...');
    
    // 🔧 重要：暫存原始內容前先檢查
    if (!sidebar.getAttribute('data-original-content')) {
        const originalContent = sidebar.innerHTML;
        sidebar.setAttribute('data-original-content', originalContent);
        console.log('💾 已備份原始側邊欄內容');
    }

    const { devices, feeders, searchLocation, searchRadius } = results;

    const resultsHtml = `
        <div style="padding: 20px; background: white; height: 100%; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3 style="color: #2c3e50; margin: 0;">🎯 鄰近搜尋結果</h3>
                <button onclick="restoreOriginalContentSafe()" 
                        style="background: #6c757d; color: white; border: none; padding: 5px 10px; 
                               border-radius: 4px; cursor: pointer; font-size: 12px;">
                    ✕ 關閉
                </button>
            </div>

            <!-- 🆕 調試資訊 -->
            <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 11px; color: #666;">
                <strong>🔧 調試資訊:</strong><br>
                饋線輸入框: ${document.getElementById('feederInput') ? '✅ 存在' : '❌ 不存在'}<br>
                載入按鈕: ${document.querySelector('.load-feeder-btn') ? '✅ 存在' : '❌ 不存在'}
            </div>

            <!-- 搜尋資訊 -->
            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #1976d2;">📍 搜尋範圍</h4>
                <p style="margin: 5px 0; font-size: 13px;">中心: ${searchLocation.lat.toFixed(6)}, ${searchLocation.lng.toFixed(6)}</p>
                <p style="margin: 5px 0; font-size: 13px;">半徑: ${searchRadius} 公里</p>
            </div>

            <!-- 饋線清單 -->
            <div style="margin-bottom: 25px;">
                <h4 style="color: #28a745; margin-bottom: 15px;">⚡ 鄰近饋線 (${feeders.length})</h4>
                ${feeders.length === 0 ? 
                    '<p style="color: #666; text-align: center; padding: 20px;">無鄰近饋線</p>' :
                    feeders.map(feeder => `
                        <div style="margin-bottom: 12px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #28a745; font-size: 16px;">⚡ ${feeder.name}</strong>
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                        設備: ${feeder.device_count || 0} | 線段: ${feeder.line_count || 0}
                                    </div>
                                </div>
                                <span style="background: #28a745; color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px;">
                                    ${feeder.distance.toFixed(2)} km
                                </span>
                            </div>
                            <div style="margin-top: 8px;">
                                <button onclick="loadNearbyFeederSafe('${feeder.name}', ${feeder.distance})" 
                                        style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    🗺️ 載入此饋線
                                </button>
                            </div>
                        </div>
                    `).join('')
                }
            </div>

            <!-- 設備清單 -->
            <div style="margin-bottom: 25px;">
                <h4 style="color: #007bff; margin-bottom: 15px;">📍 鄰近設備 (${devices.length})</h4>
                ${devices.length === 0 ? 
                    '<p style="color: #666; text-align: center; padding: 20px;">無鄰近設備</p>' :
                    devices.slice(0, 10).map(device => `
                        <div style="margin-bottom: 10px; padding: 12px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid #007bff;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #007bff; font-size: 14px;">${getDeviceTypeName(device.fsc)}</strong>
                                    <div style="font-size: 11px; color: #666; margin-top: 2px;">
                                        饋線: ${device.feeder_name}
                                    </div>
                                </div>
                                <span style="background: #007bff; color: white; padding: 2px 6px; border-radius: 8px; font-size: 10px;">
                                    ${device.distance.toFixed(2)} km
                                </span>
                            </div>
                        </div>
                    `).join('')
                }
            </div>

            <!-- 操作按鈕 -->
            <div style="position: sticky; bottom: 0; background: white; padding: 15px 0; border-top: 1px solid #eee;">
                <button onclick="restoreOriginalContentSafe()" 
                        style="width: 100%; padding: 12px; background: #6c757d; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    ← 返回控制面板
                </button>
            </div>
        </div>
    `;

    sidebar.innerHTML = resultsHtml;
    console.log('✅ 搜尋結果已顯示在側邊欄');
}
// 🆕 安全版本的恢復函數
function restoreOriginalContentSafe() {
    console.log('🔒 安全恢復原始內容');
    
    if (restoreOriginalContent()) {
        showToast('✅ 已返回控制面板', 'success');
    } else {
        // 備用方案：重新載入頁面（最後手段）
        if (confirm('無法正常返回控制面板，是否重新載入頁面？')) {
            location.reload();
        }
    }
}
// 🆕 安全版本的載入饋線函數
function loadNearbyFeederSafe(feederName, distance) {
    console.log(`🔒 安全載入饋線: ${feederName}`);
    
    // 先嘗試恢復原始內容
    if (restoreOriginalContent()) {
        // 等待DOM更新
        setTimeout(() => {
            loadNearbyFeeder(feederName, distance);
        }, 200);
    } else {
        // 如果恢復失敗，直接嘗試載入
        loadNearbyFeeder(feederName, distance);
    }
}

// 🔧 完全修正版：載入鄰近饋線 - 多重檢查和備用方案
function loadNearbyFeeder(feederName, distance) {
    console.log(`⚡ 載入鄰近饋線: ${feederName} (距離: ${distance.toFixed(2)}km)`);
    
    // 🔧 方法1：直接查找饋線輸入框
    let feederInput = document.getElementById('feederInput');
    
    if (feederInput) {
        executeFeederLoadDirect(feederInput, feederName);
        return;
    }
    
    // 🔧 方法2：如果在搜尋結果頁面，先恢復原始內容
    console.warn('⚠️ 未找到饋線輸入框，嘗試恢復原始內容...');
    restoreOriginalContent();
    
    // 等待DOM更新後再次嘗試
    setTimeout(() => {
        feederInput = document.getElementById('feederInput');
        if (feederInput) {
            executeFeederLoadDirect(feederInput, feederName);
        } else {
            // 🔧 方法3：手動切換到控制面板（手機版）
            console.warn('⚠️ 仍未找到，嘗試切換到控制面板...');
            switchToControlsPanel();
            
            setTimeout(() => {
                feederInput = document.getElementById('feederInput');
                if (feederInput) {
                    executeFeederLoadDirect(feederInput, feederName);
                } else {
                    // 🔧 方法4：最後的備用方案
                    showFeederLoadFallback(feederName);
                }
            }, 500);
        }
    }, 300);
}

// 🆕 直接執行饋線載入
function executeFeederLoadDirect(feederInput, feederName) {
    try {
        feederInput.value = feederName;
        
        // 🔧 觸發 input 事件以同步下拉選單
        const inputEvent = new Event('input', { bubbles: true });
        feederInput.dispatchEvent(inputEvent);
        
        showToast(`🔄 正在載入饋線 ${feederName}...`, 'info');
        
        // 🔧 確保呼叫載入函數
        if (typeof loadFeederFromCloud === 'function') {
            loadFeederFromCloud();
        } else {
            // 備用：直接點擊載入按鈕
            const loadButton = document.querySelector('.load-feeder-btn');
            if (loadButton) {
                loadButton.click();
            } else {
                throw new Error('找不到載入函數和按鈕');
            }
        }
        
        console.log(`✅ 成功設定饋線: ${feederName}`);
        
    } catch (error) {
        console.error('❌ 執行饋線載入失敗:', error);
        showFeederLoadFallback(feederName);
    }
}
// 🆕 切換到控制面板（處理手機版情況）
function switchToControlsPanel() {
    // 檢查是否為手機版
    const isMobile = window.innerWidth <= 768;
    
    if (isMobile) {
        // 手機版：點擊控制標籤
        const controlsTab = document.querySelector('.nav-tab[data-tab="controls"]');
        if (controlsTab) {
            controlsTab.click();
            console.log('📱 已切換到手機版控制面板');
        }
    }
    
    // 確保側邊欄顯示
    const sidebar = document.querySelector('.sidebar');
    if (sidebar) {
        sidebar.style.display = 'block';
    }
}
// 🆕 備用方案：顯示手動載入提示
function showFeederLoadFallback(feederName) {
    console.error('❌ 所有自動載入方案都失敗，顯示手動提示');
    
    // 創建提示彈窗
    const fallbackPopup = L.popup({
        closeButton: true,
        autoClose: false,
        closeOnEscapeKey: true,
        className: 'feeder-load-fallback'
    })
    .setLatLng(map.getCenter())
    .setContent(`
        <div style="text-align: center; padding: 10px;">
            <h4 style="color: #dc3545; margin: 0 0 10px 0;">⚠️ 自動載入失敗</h4>
            <p style="margin: 5px 0; font-size: 14px;">請手動載入饋線：</p>
            <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                <strong style="font-size: 16px; color: #007bff;">${feederName}</strong>
            </div>
            <div style="font-size: 12px; color: #666; line-height: 1.4;">
                1. 關閉此彈窗<br>
                2. 在左側控制面板找到「饋線輸入框」<br>
                3. 輸入「${feederName}」<br>
                4. 點擊「載入饋線資料」按鈕
            </div>
            <div style="margin-top: 15px;">
                <button onclick="copyFeederName('${feederName}')" 
                        style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">
                    📋 複製饋線名稱
                </button>
                <button onclick="map.closePopup()" 
                        style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    關閉
                </button>
            </div>
        </div>
    `)
    .openOn(map);
    
    // 同時顯示 toast 提示
    showToast(`⚠️ 請手動載入饋線：${feederName}`, 'warning');
}

// 🆕 複製饋線名稱到剪貼簿
function copyFeederName(feederName) {
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(feederName).then(() => {
            showToast(`📋 已複製饋線名稱：${feederName}`, 'success');
            map.closePopup();
        }).catch(err => {
            console.error('複製失敗:', err);
            fallbackCopyFeederName(feederName);
        });
    } else {
        fallbackCopyFeederName(feederName);
    }
}

// 🆕 備用複製方法
function fallbackCopyFeederName(feederName) {
    const textArea = document.createElement('textarea');
    textArea.value = feederName;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        document.execCommand('copy');
        showToast(`📋 已複製饋線名稱：${feederName}`, 'success');
        map.closePopup();
    } catch (err) {
        console.error('複製失敗:', err);
        showToast('❌ 複製失敗，請手動記住饋線名稱', 'error');
    }
    
    document.body.removeChild(textArea);
}
// 🆕 執行饋線載入的輔助函數
function executeFeederLoad(feederInput, feederName) {
    feederInput.value = feederName;
    showToast(`🔄 正在載入饋線 ${feederName}...`, 'info');
    
    // 🔧 確保呼叫正確的載入函數
    if (typeof loadFeederFromCloud === 'function') {
        loadFeederFromCloud();
    } else {
        // 🔧 備用方案：直接觸發載入按鈕點擊
        const loadButton = document.querySelector('.load-feeder-btn') || 
                          document.querySelector('button[onclick*="loadFeeder"]');
        if (loadButton) {
            loadButton.click();
        } else {
            showToast('❌ 找不到載入按鈕', 'error');
            return;
        }
    }
    
    // 延遲恢復控制面板
    setTimeout(() => {
        restoreOriginalContent();
    }, 1500);
}
// 🆕 重新搜尋鄰近設備
function searchNearbyAgain() {
    restoreOriginalContent();
    
    setTimeout(() => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                position => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    performNearbySearch(lat, lng);
                },
                error => {
                    showToast('❌ 無法取得位置，請手動點選地圖', 'error');
                    enableMapClickForSearch();
                }
            );
        } else {
            showToast('❌ 瀏覽器不支援定位，請手動點選地圖', 'error');
            enableMapClickForSearch();
        }
    }, 300);
}

// 🔧 修正版：啟用地圖點選搜尋 - 使用選中的半徑
function enableMapClickForSearch() {
    showToast('📍 請點選地圖上的位置進行搜尋', 'info');
    
    map.getContainer().style.cursor = 'crosshair';
    
    const clickHandler = function(e) {
        map.off('click', clickHandler);
        map.getContainer().style.cursor = '';
        
        const lat = e.latlng.lat;
        const lng = e.latlng.lng;
        
        // 🔧 重要修正：使用選中的半徑，而不是固定的2公里
        const radiusSelect = document.getElementById('searchRadius');
        const radius = parseFloat(radiusSelect.value);
        
        performNearbySearch(lat, lng, radius);
    };
    
    map.on('click', clickHandler);
}

// 🆕 執行鄰近搜尋
// 🔧 修正版：執行鄰近搜尋 - 加入設備顯示選項
async function performNearbySearch(lat, lng, radius = 2) {
    showToast('🔍 正在搜尋鄰近設備和饋線...', 'info');
    
    const results = await searchNearbyFeatures(lat, lng, radius);
    if (results) {
        // 🆕 檢查是否只顯示設備
        const showDevicesOnly = document.getElementById('showDevicesOnly')?.checked;
        
        if (showDevicesOnly) {
            // 只顯示設備，不顯示側邊欄
            clearSearchResults();
            displayDevicesOnMap(results.devices);
            
            // 調整地圖視野
            const bounds = L.latLngBounds();
            bounds.extend([lat, lng]);
            results.devices.forEach(device => {
                bounds.extend([device.lat, device.lng]);
            });
            
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [20, 20] });
            }
            
            const radiusText = radius < 1 ? `${radius * 1000}公尺` : `${radius}公里`;
            showToast(`📍 顯示 ${results.devices.length} 個附近設備 (半徑${radiusText})`, 'success');
        } else {
            // 正常顯示（包含側邊欄）
            displayNearbyResults(results);
        }
    }
}

// 🆕 從當前位置搜尋
function searchNearbyFromLocation() {
    const radiusSelect = document.getElementById('searchRadius');
    const radius = parseFloat(radiusSelect.value);
    
    if (navigator.geolocation) {
        showToast('📍 正在取得您的位置...', 'info');
        
        navigator.geolocation.getCurrentPosition(
            position => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                performNearbySearch(lat, lng, radius);
            },
            error => {
                console.error('定位失敗:', error);
                showToast('❌ 無法取得位置，請檢查定位權限', 'error');
            },
            {
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 60000
            }
        );
    } else {
        showToast('❌ 您的瀏覽器不支援定位功能', 'error');
    }
}

// 🆕 只顯示附近設備（不顯示饋線列表）
async function showNearbyDevicesOnly() {
    const radiusSelect = document.getElementById('searchRadius');
    const radius = parseFloat(radiusSelect.value);
    
    if (navigator.geolocation) {
        showToast('📍 正在取得您的位置並顯示附近設備...', 'info');
        
        navigator.geolocation.getCurrentPosition(
            async position => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                
                const results = await searchNearbyFeatures(lat, lng, radius);
                if (results && results.devices.length > 0) {
                    // 清除之前的結果
                    clearSearchResults();
                    
                    // 只顯示設備，不顯示側邊欄結果
                    displayDevicesOnMap(results.devices);
                    
                    // 調整地圖視野到設備範圍
                    const bounds = L.latLngBounds();
                    bounds.extend([lat, lng]);
                    results.devices.forEach(device => {
                        bounds.extend([device.lat, device.lng]);
                    });
                    
                    if (bounds.isValid()) {
                        map.fitBounds(bounds, { padding: [20, 20] });
                    }
                    
                    const radiusText = radius < 1 ? `${radius * 1000}公尺` : `${radius}公里`;
                    showToast(`📍 顯示 ${results.devices.length} 個附近設備 (半徑${radiusText})`, 'success');
                } else {
                    showToast('❌ 附近沒有找到設備', 'warning');
                }
            },
            error => {
                console.error('定位失敗:', error);
                showToast('❌ 無法取得位置，請檢查定位權限', 'error');
            }
        );
    } else {
        showToast('❌ 您的瀏覽器不支援定位功能', 'error');
    }
}
		  </script>
		  <!-- 照片放大模態框 -->
		<div id="photo-modal" class="photo-modal">
			<span class="photo-modal-close" onclick="closePhotoModal()">&times;</span>
			<img class="photo-modal-content" id="modal-photo">
		</div>
	  </body>
	  </html>
	  
