	<!DOCTYPE html>
	<html lang="zh-TW">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>é¥‹ç·šåœ–åœ°åœ–ç³»çµ±</title>
		
		<!-- ğŸ”§ ä¿®æ­£ï¼šå…ˆè¼‰å…¥ Leaflet CSS -->
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
			  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
			  crossorigin=""/>
		
		<!-- ğŸ”§ ä¿®æ­£ï¼šå†è¼‰å…¥ Leaflet JavaScript -->
		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
				integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
				crossorigin=""></script>
		
		<!-- ğŸ”§ ä¿®æ­£ï¼šæœ€å¾Œè¼‰å…¥ä¾è³´ Leaflet çš„æ’ä»¶ -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-compass@1.0.0/dist/leaflet-compass.css">
		<script src="https://cdn.jsdelivr.net/npm/leaflet-compass@1.0.0/dist/leaflet-compass.js"></script>
		<script src="https://unpkg.com/leaflet-rotate@0.1.4/dist/leaflet-rotate-src.js"></script>
		
		
		<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Arial', sans-serif;
    background-color: #f5f5f5;
}

.header {
    background: linear-gradient(135deg, #2c3e50, #3498db);
    color: white;
    padding: 15px 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.header h1 {
    font-size: 24px;
    margin-bottom: 5px;
}

.header p {
    font-size: 14px;
    opacity: 0.9;
}

/* ğŸ”§ ä¿®æ­£ï¼šé›»è…¦ç‰ˆå›ºå®šå¸ƒå±€ + æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼ */
.container {
    display: flex;
    height: calc(100vh - 80px);
    position: relative;
}

.sidebar {
    width: 320px;
    background: white;
    border-right: 1px solid #ddd;
    overflow-y: auto;
    box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    z-index: 100;
    position: relative;
}

.map-container {
    flex: 1;
    position: relative;
    margin-left: 0;
}

#map {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}

/* ğŸ†• æ‰‹æ©Ÿç‰ˆå°èˆª - é è¨­éš±è— */
.mobile-nav {
    display: none;
    background: #2c3e50;
    justify-content: space-around;
    padding: 10px 0;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.nav-tab {
    flex: 1;
    padding: 12px;
    background: transparent;
    color: #bdc3c7;
    border: none;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.nav-tab.active {
    color: #3498db;
    background: rgba(52, 152, 219, 0.1);
    border-radius: 8px;
}

.file-upload-section {
    margin-bottom: 25px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 2px dashed #dee2e6;
    transition: all 0.3s ease;
}

.file-upload-section:hover {
    border-color: #3498db;
    background: #e3f2fd;
}

.file-upload-section h3 {
    margin-bottom: 15px;
    color: #2c3e50;
    font-size: 16px;
}

.file-input-wrapper {
    position: relative;
    display: inline-block;
    width: 100%;
}

#fileInput {
    display: none;
}

.file-input-button {
    display: block;
    width: 100%;
    padding: 12px 20px;
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    text-align: center;
}

.file-input-button:hover {
    background: linear-gradient(135deg, #2980b9, #1f5f8b);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
}

.file-info {
    margin-top: 10px;
    font-size: 12px;
    color: #666;
    text-align: center;
}

.layer-controls {
    margin-bottom: 25px;
}

.layer-controls h3 {
    margin-bottom: 15px;
    color: #2c3e50;
    font-size: 16px;
    border-bottom: 2px solid #3498db;
    padding-bottom: 5px;
}

.layer-item {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    padding: 8px 12px;
    background: #f8f9fa;
    border-radius: 6px;
    transition: background 0.3s ease;
}

.layer-item:hover {
    background: #e9ecef;
}

.layer-item input[type="checkbox"] {
    margin-right: 10px;
    transform: scale(1.2);
}

.layer-item label {
    flex: 1;
    cursor: pointer;
    font-size: 14px;
    color: #495057;
}

.layer-count {
    font-size: 12px;
    color: #6c757d;
    background: #e9ecef;
    padding: 2px 8px;
    border-radius: 12px;
    margin-left: 8px;
}

.status-section {
    margin-bottom: 20px;
}

.status-section h3 {
    margin-bottom: 10px;
    color: #2c3e50;
    font-size: 16px;
}

#loadStatus {
    padding: 10px;
    background: #e8f5e8;
    border: 1px solid #c3e6c3;
    border-radius: 6px;
    font-size: 13px;
    color: #155724;
}

.legend {
    margin-top: 20px;
    padding: 15px;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 6px;
}

.legend h4 {
    margin-bottom: 10px;
    color: #2c3e50;
    font-size: 14px;
}

.legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    font-size: 12px;
}

.legend-color {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    margin-right: 8px;
    border: 2px solid #fff;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.2);
}

.legend-line {
    width: 20px;
    height: 3px;
    margin-right: 8px;
    border-radius: 2px;
}

.legend-line-dashed {
    width: 20px;
    height: 3px;
    margin-right: 8px;
    border-radius: 2px;
    background-image: repeating-linear-gradient(
        to right,
        currentColor,
        currentColor 4px,
        transparent 4px,
        transparent 8px
    );
}

.loading {
    display: none;
    text-align: center;
    padding: 20px;
    color: #666;
}

.loading.show {
    display: block;
}

.feeder-info {
    margin-bottom: 20px;
    padding: 15px;
    background: #e3f2fd;
    border-radius: 6px;
    border-left: 4px solid #2196f3;
}

.feeder-info h4 {
    margin-bottom: 8px;
    color: #1976d2;
}

.feeder-info p {
    margin: 4px 0;
    font-size: 13px;
    color: #424242;
}

/* ç·šæ®µé«˜äº®æ§åˆ¶æŒ‰éˆ•æ¨£å¼ */
.highlight-controls {
    margin-top: 15px;
    padding: 10px;
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 6px;
    text-align: center;
}

.reset-highlight-btn {
    background: #28a745;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: background 0.3s ease;
}

.reset-highlight-btn:hover {
    background: #218838;
}

/* è¨­å‚™åœ–æ¨™æ¨£å¼ */
.simple-device-icon {
    background: transparent !important;
    border: none !important;
}

.simple-device-icon div {
    transition: none !important;
}

.leaflet-div-icon.arrow-icon {
    background: transparent !important;
    border: none !important;
}

.arrow-marker {
    width: 0;
    height: 0;
    border-left: 12px solid transparent;
    border-right: 12px solid transparent;
    border-bottom: 24px solid;
    transform-origin: center bottom;
}

/* æ˜Ÿæ˜Ÿæ¨™è¨˜æ¨£å¼ */
.opposite-star-icon {
    background: transparent !important;
    border: none !important;
}

.opposite-star-marker {
    display: flex;
    flex-direction: row;
    align-items: center;
    text-align: left;
    white-space: nowrap;
}

.star-icon {
    font-size: 16px;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
    margin-right: 4px;
    flex-shrink: 0;
}

.opposite-text {
    background: rgba(255, 0, 0, 0.9);
    color: white;
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: bold;
    border: 1px solid #ff0000;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    white-space: nowrap;
    flex-shrink: 0;
}

/* å…¨é¸æ§åˆ¶å€åŸŸæ¨£å¼ */
.select-all-container {
    margin-bottom: 15px;
    padding: 12px;
    background: #f8f9fa;
    border-radius: 6px;
    border: 1px solid #dee2e6;
}

.select-all-section h4 {
    margin: 0 0 10px 0;
    color: #2c3e50;
    font-size: 14px;
    font-weight: bold;
}

.select-all-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 8px;
}

.select-all-btn {
    padding: 6px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: #fff;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
    text-align: center;
    font-weight: 500;
}

.select-all-btn:hover {
    background: #e9ecef;
    border-color: #adb5bd;
    transform: translateY(-1px);
}

.select-all-btn.equipment {
    border-left: 3px solid #ff6b35;
    color: #ff6b35;
}

.select-all-btn.lines {
    border-left: 3px solid #4ecdc4;
    color: #4ecdc4;
}

.select-all-btn.deselect {
    grid-column: 1 / -1;
    border-left: 3px solid #dc3545;
    color: #dc3545;
}

.select-all-btn.active {
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    border-color: #28a745;
    box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
}

.select-all-btn.active:hover {
    background: linear-gradient(135deg, #218838, #1e7e34);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(40, 167, 69, 0.4);
}

.select-all-btn.equipment.active,
.select-all-btn.lines.active {
    border-left: 3px solid #fff;
}

.divider {
    border: none;
    border-top: 1px solid #dee2e6;
    margin: 10px 0;
}

/* è‡ªè¨‚å½ˆå‡ºè¦–çª—æ¨£å¼ */
.custom-popup .leaflet-popup-content-wrapper {
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    border: none;
}

.custom-popup .leaflet-popup-content {
    margin: 10px;
    line-height: 1.4;
}

.custom-popup .leaflet-popup-tip {
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* é¥‹ç·šé¸æ“‡å€åŸŸæ¨£å¼ */
.feeder-selection-section {
    margin-bottom: 25px;
    padding: 20px;
    background: #e8f5e8;
    border-radius: 8px;
    border: 2px solid #28a745;
    transition: all 0.3s ease;
}

.feeder-selection-section h3 {
    margin-bottom: 15px;
    color: #155724;
    font-size: 16px;
    font-weight: bold;
}

.feeder-input-row {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 12px;
}

.feeder-input {
    width: 100%;
    padding: 10px;
    border: 2px solid #28a745;
    border-radius: 6px;
    font-size: 14px;
    outline: none;
    transition: border-color 0.3s ease;
}

.feeder-input:focus {
    border-color: #20c997;
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.1);
}

.feeder-dropdown {
    width: 100%;
    padding: 10px;
    border: 2px solid #28a745;
    border-radius: 6px;
    font-size: 14px;
    outline: none;
    background: white;
    cursor: pointer;
}

.feeder-button-row {
    margin-bottom: 12px;
}

.load-feeder-btn {
    width: 100%;
    padding: 12px 20px;
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 4px 8px rgba(40, 167, 69, 0.2);
}

.load-feeder-btn:hover {
    background: linear-gradient(135deg, #218838, #1e7e34);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(40, 167, 69, 0.3);
}

.load-feeder-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
}

.load-feeder-btn:disabled {
    background: #6c757d;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.load-feeder-btn.loading {
    background: #17a2b8;
    animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.feeder-info-text {
    font-size: 12px;
    color: #155724;
    text-align: center;
    line-height: 1.4;
}

.feeder-selection-section.success {
    border-color: #28a745;
    background: linear-gradient(135deg, #d4edda, #c3e6cb);
}

.feeder-selection-section.loading {
    border-color: #17a2b8;
    background: linear-gradient(135deg, #d1ecf1, #bee5eb);
}

.feeder-selection-section.error {
    border-color: #dc3545;
    background: linear-gradient(135deg, #f8d7da, #f5c6cb);
}

/* å®šä½æŒ‰éˆ•æ¨£å¼ */
.location-controls {
    position: absolute;
    top: 60px;
    right: 10px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.location-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: background 0.3s;
}

.location-btn:hover {
    background: #45a049;
}

.location-btn.active {
    background: #2196F3;
}

/* åœ–è™Ÿåº§æ¨™è¼¸å…¥å€åŸŸ */
.coordinate-input-section {
    margin-bottom: 25px;
    padding: 20px;
    background: #fff3cd;
    border-radius: 8px;
    border: 2px solid #ffc107;
}

.coordinate-input-section h3 {
    margin-bottom: 15px;
    color: #856404;
    font-size: 16px;
}

.coordinate-input {
    width: 100%;
    padding: 10px;
    border: 2px solid #ffc107;
    border-radius: 6px;
    font-size: 14px;
    margin-bottom: 10px;
}

.coordinate-btn {
    width: 100%;
    padding: 10px;
    background: #ffc107;
    color: #212529;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
}

.coordinate-btn:hover {
    background: #e0a800;
}

/* åœ°åœ–æ—‹è½‰æ§åˆ¶æ¨£å¼ */
/* åœ°åœ–æ—‹è½‰æ§åˆ¶æ¨£å¼ - ç°¡åŒ–ç‰ˆ */
.rotation-controls {
    position: absolute;
    bottom: 120px;
    right: 10px;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 140px; /* ç¸®å°å¯¬åº¦ */
    z-index: 1000;
}

.compass-display {
    font-size: 11px;
    text-align: center;
    color: #666;
    padding: 4px 0;
    border-bottom: 1px solid #eee;
    margin-bottom: 5px;
    font-weight: bold;
}

.rotation-btn {
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
    white-space: nowrap;
}

.rotation-btn:hover {
    background: #f8f9fa;
    border-color: #007bff;
    transform: translateY(-1px);
}

.rotation-btn.active {
    background: #007bff;
    color: white;
    border-color: #007bff;
}

/* åœ–å±¤åˆ‡æ›å¢å¼·æ¨£å¼ */
.layer-switcher-compact {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 1001;
}

.layer-toggle-btn {
    background: rgba(255, 255, 255, 0.9);
    border: 2px solid #ddd;
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
}

.layer-toggle-btn:hover {
    background: white;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.layer-menu {
    position: absolute;
    top: 45px;
    right: 0;
    background: white;
    border: 2px solid #ddd;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    max-width: 280px;
    max-height: 400px;
    overflow-y: auto;
    animation: slideDown 0.3s ease;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.layer-group {
    margin-bottom: 15px;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
}

.layer-group:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.layer-group h5 {
    margin: 0 0 8px 0;
    font-size: 13px;
    font-weight: bold;
    color: #333;
}

.layer-option {
    display: flex;
    align-items: center;
    margin: 5px 0;
    font-size: 12px;
}

.layer-option input {
    margin-right: 8px;
}

.layer-option label {
    cursor: pointer;
    flex: 1;
}

.layer-opacity-control {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 11px;
}

.opacity-slider {
    flex: 1;
    height: 4px;
}

/* å…¨è¢å¹•æ§åˆ¶ */
.fullscreen-btn {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10000;
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    white-space: nowrap;
}

.fullscreen-btn:hover {
    background: #45a049;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

.fullscreen-mode .fullscreen-btn {
    background: #ff5722;
    animation: pulse 2s infinite;
}

.fullscreen-mode .fullscreen-btn:hover {
    background: #e64a19;
}

.fullscreen-mode .header {
    display: none;
}

.fullscreen-mode .container {
    height: 100vh;
}

.fullscreen-mode .sidebar {
    position: absolute;
    left: -320px;
    transition: left 0.3s ease;
}

.fullscreen-mode .map-container {
    width: 100%;
    height: 100vh;
}

/* ğŸ”§ æ–°å¢ï¼šæ‰‹æ©Ÿç‰ˆéš±è—å…¨è¢å¹•æŒ‰éˆ• */
@media (max-width: 768px) {
    .fullscreen-btn {
        display: none !important;
    }
}

/* æ¸¬é‡å·¥å…·æ¨£å¼ */
.measure-controls {
    position: absolute;
    top: 60px;
    left: 10px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.measure-btn {
    background: #FF9800;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.measure-btn:hover {
    background: #F57C00;
}

.measure-btn.active {
    background: #E65100;
}

/* ğŸ”§ ä¿®æ­£ï¼šæ‰‹æ©Ÿç‰ˆå°ˆç”¨æ¨£å¼ */
@media (max-width: 768px) {
	/* å®šä½æ§åˆ¶æŒ‰éˆ• - ç¸®å°ç‰ˆ */
		.location-controls {
			position: fixed;
			bottom: 20px;
			right: 15px;
			z-index: 1000;
			display: flex;
			flex-direction: column;
			gap: 8px;
		}
		
		.location-btn {
			background: #4CAF50;
			color: white;
			border: none;
			padding: 8px 12px;  /* ğŸ”§ å¾ 10px æ”¹ç‚º 8px 12px */
			border-radius: 6px;
			cursor: pointer;
			font-size: 12px;    /* ğŸ”§ å¾ 14px æ”¹ç‚º 12px */
			box-shadow: 0 2px 5px rgba(0,0,0,0.2);
			transition: background 0.3s;
			min-width: 80px;    /* ğŸ”§ é™åˆ¶æœ€å°å¯¬åº¦ */
			max-width: 100px;   /* ğŸ”§ é™åˆ¶æœ€å¤§å¯¬åº¦ */
		}
		
		.rotation-btn {
			background: #6c757d;
			color: white;
			border: none;
			padding: 8px 12px;  /* ğŸ”§ å¾ 10px æ”¹ç‚º 8px 12px */
			border-radius: 6px;
			cursor: pointer;
			font-size: 12px;    /* ğŸ”§ å¾ 14px æ”¹ç‚º 12px */
			box-shadow: 0 2px 5px rgba(0,0,0,0.2);
			transition: background 0.3s;
			min-width: 80px;    /* ğŸ”§ é™åˆ¶æœ€å°å¯¬åº¦ */
			max-width: 100px;   /* ğŸ”§ é™åˆ¶æœ€å¤§å¯¬åº¦ */
			text-align: center;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}
		
		/* ğŸ”§ æ‰‹æ©Ÿç‰ˆæŒ‡åŒ—é‡èª¿æ•´ - ç¸®å°ä¸¦ç§»å‹•ä½ç½® */
		#compass {
			bottom: 140px !important;  /* ğŸ”§ èª¿æ•´ä½ç½®é¿å…é®æ“‹æŒ‰éˆ• */
			right: 10px !important;
			transform: scale(0.8);     /* ğŸ”§ ç¸®å°æŒ‡åŒ—é‡ */
			transform-origin: bottom right;
		}
		
    .mobile-nav {
        display: flex !important;
    }
    
    .nav-tab {
        flex: 1;
        padding: 12px;
        background: transparent;
        color: #bdc3c7;
        border: none;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    
    .nav-tab.active {
        color: #3498db;
        background: rgba(52, 152, 219, 0.1);
        border-radius: 8px;
    }
    
    .header {
        display: none;
    }
    
    .container {
        height: 100vh;
        margin-top: 60px;
        flex-direction: column;
    }
    
    .sidebar {
        width: 100%;
        height: calc(100vh - 60px);
        position: fixed;
        top: 60px;
        left: 0;
        z-index: 999;
        display: none;
        border-right: none;
        border-bottom: 1px solid #ddd;
    }
    
    .map-container {
        width: 100%;
        height: calc(100vh - 60px);
        position: fixed;
        top: 60px;
        left: 0;
        margin-left: 0;
    }
    
    #map {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    
    /* è§¸æ§å„ªåŒ– */
    .control-btn,
    .measure-btn,
    .load-feeder-btn {
        min-height: 44px;
        min-width: 44px;
        font-size: 16px;
        padding: 12px 16px;
    }
    
    .measure-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        top: auto;
        left: auto;
        flex-direction: row;
        background: rgba(255, 255, 255, 0.95);
        padding: 10px;
        border-radius: 25px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .control-btn:active,
    .measure-btn:active {
        transform: scale(0.95);
        transition: transform 0.1s;
    }
    
    .feeder-input,
    .feeder-dropdown {
        width: 100%;
    }
    
    .load-feeder-btn {
        font-size: 14px;
        padding: 10px 16px;
    }
}

/* ğŸ”§ ä¿®æ­£ï¼šæ¡Œé¢ç‰ˆç¢ºä¿æ­£å¸¸é¡¯ç¤º */
@media (min-width: 769px) {
    .mobile-nav {
        display: none !important;
    }
    
    .header {
        display: block;
    }
    
    .container {
        margin-top: 0;
        height: calc(100vh - 80px);
    }
    
    .sidebar {
        position: relative;
        display: block;
    }
    
    .map-container {
        position: relative;
    }
}

/* Google Maps é¢¨æ ¼çš„å®šä½åœ–æ¨™ */
.location-marker {
    position: relative;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* å¤–åœˆå…‰æšˆæ•ˆæœ */
.location-marker::before {
    content: '';
    position: absolute;
    width: 40px;
    height: 40px;
    background: rgba(66, 133, 244, 0.2);
    border-radius: 50%;
    animation: pulse-glow 2s infinite;
    z-index: 1;
}

/* ä¸­é–“ç™½è‰²åœ“åœˆ */
.location-marker::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 50%;
    border: 2px solid #4285f4;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    z-index: 2;
}

/* ä¸­å¿ƒè—è‰²åœ“é» - åŠ å¤§å°ºå¯¸ */
.location-marker .center-dot {
    width: 12px;
    height: 12px;
    background: #4285f4;
    border-radius: 50%;
    z-index: 3;
    position: relative;
}

/* å…‰æšˆå‹•ç•« */
@keyframes pulse-glow {
    0% {
        transform: scale(0.8);
        opacity: 0.8;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.3;
    }
    100% {
        transform: scale(0.8);
        opacity: 0.8;
    }
}

/* ğŸ”§ æ–°å¢ï¼šæŒ‡åŒ—é‡æ¨£å¼ */
#compass {
    position: fixed !important;
    bottom: 180px !important;
    right: 20px !important;
    z-index: 1000 !important;
    pointer-events: none;
    user-select: none;
}

#compass > div {
    animation: compassFadeIn 0.3s ease-out;
}

@keyframes compassFadeIn {
    from {
        opacity: 0;
        transform: scale(0.8);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

/* æ‰‹æ©Ÿç‰ˆæŒ‡åŒ—é‡èª¿æ•´ */
@media (max-width: 768px) {
    #compass {
        bottom: 100px !important;
        right: 15px !important;
        transform: scale(0.9);
    }
}
/* ğŸ”§ æ–°å¢ï¼šæ‰‹æ©Ÿç‰ˆéš±è—æ¸¬é‡å·¥å…· */
@media (max-width: 768px) {
    .measure-controls {
        display: none !important;
    }
}
		</style>
	</head>
	<body>
	    <!-- ğŸ†• åœ¨é€™è£¡åŠ å…¥æ‰‹æ©Ÿç‰ˆå°èˆª - æ”¾åœ¨æœ€é ‚éƒ¨ -->
    <div class="mobile-nav" style="display: none;">
        <button class="nav-tab active" data-tab="map">ğŸ—ºï¸ åœ°åœ–</button>
        <button class="nav-tab" data-tab="controls">âš™ï¸ æ§åˆ¶</button>
        <button class="nav-tab" data-tab="info">â„¹ï¸ è³‡è¨Š</button>
    </div>
		<div class="header">
			<h1>ğŸ—ºï¸ é¥‹ç·šåœ–åœ°åœ–ç³»çµ±</h1>
			<p>è¼‰å…¥é…é›»ç³»çµ± JSON æª”æ¡ˆä¸¦è‡ªè¨‚åœ–å±¤é¡¯ç¤ºï¼ˆæ”¯æ´é»èˆ‡ç·šæ®µé«˜äº®ï¼‰</p>
		</div>
		
		<div class="container">
			<div class="sidebar">
			<!-- ğŸ†• é¥‹ç·šé¸æ“‡å€åŸŸ -->
			<div class="feeder-selection-section">
				<h3>ğŸŒ å¾é›²ç«¯è¼‰å…¥é¥‹ç·šè³‡æ–™</h3>
				
				<!-- ğŸ†• åˆ†æˆå…©è¡Œé¡¯ç¤º -->
				<div class="feeder-input-row">
					<input type="text" 
						   id="feederInput" 
						   class="feeder-input" 
						   placeholder="è¼¸å…¥é¥‹ç·šåç¨±(å¦‚: 6A22)"
						   maxlength="4">
					<select id="feederDropdown" class="feeder-dropdown">
						<option value="">é¸æ“‡é¥‹ç·š</option>
					</select>
				</div>
				
				<!-- ğŸ†• æŒ‰éˆ•ç¨ç«‹ä¸€è¡Œ -->
				<div class="feeder-button-row">
					<button class="load-feeder-btn" onclick="loadFeederFromCloud()">
						ğŸŒ å¾é›²ç«¯è¼‰å…¥é¥‹ç·šè³‡æ–™
					</button>
				</div>
				
				<div class="feeder-info-text">
					<!-- ğŸ†• å¿«å–æ§åˆ¶å€åŸŸ -->
						<div class="cache-controls" style="margin-top: 10px; display: flex; gap: 8px;">
							<button onclick="preloadPopularFeeders()" 
									style="flex: 1; padding: 6px; font-size: 11px; background: #17a2b8; 
										   color: white; border: none; border-radius: 4px; cursor: pointer;">
								ğŸ”¥ é è¼‰ç†±é–€
							</button>
							<button onclick="showCacheStats()" 
									style="flex: 1; padding: 6px; font-size: 11px; background: #6c757d; 
										   color: white; border: none; border-radius: 4px; cursor: pointer;">
								ğŸ“Š å¿«å–ç‹€æ…‹
							</button>
							<button onclick="feederCache.clear(); showToast('å¿«å–å·²æ¸…é™¤', 'info')" 
									style="flex: 1; padding: 6px; font-size: 11px; background: #dc3545; 
										   color: white; border: none; border-radius: 4px; cursor: pointer;">
								ğŸ—‘ï¸ æ¸…é™¤å¿«å–
							</button>
						</div>
				</div>
			</div>
			<!-- æ–°å¢ï¼šåœ–è™Ÿåº§æ¨™è¼¸å…¥å€åŸŸ -->
			<div class="coordinate-input-section">
				<h3>ğŸ—ºï¸ åœ–è™Ÿåº§æ¨™æŸ¥è©¢</h3>
				<input type="text" 
					   id="coordinateInput" 
					   class="coordinate-input" 
					   placeholder="è¼¸å…¥åœ–è™Ÿåº§æ¨™ (å¦‚: Q1520CB20)"
					   maxlength="15">
				<button class="coordinate-btn" onclick="searchByCoordinate()">
					ğŸ” åº§æ¨™å®šä½
				</button>
				<div style="font-size: 12px; color: #856404; margin-top: 8px; text-align: center;">
					æ”¯æ´å°é›»åœ–è™Ÿåº§æ¨™æ ¼å¼
				</div>
			</div>
				<!-- æª”æ¡ˆä¸Šå‚³å€åŸŸ -->
				<div class="file-upload-section">
					<h3>ğŸ“ è¼‰å…¥é…é›»ç³»çµ±æª”æ¡ˆ</h3>
					<div class="file-input-wrapper">
						<input type="file" id="fileInput" accept=".json" />
						<button class="file-input-button" onclick="document.getElementById('fileInput').click()">
							ğŸ“‚ é¸æ“‡ JSON æª”æ¡ˆ
						</button>
					</div>
					<div class="file-info">
						æ”¯æ´å°é›»é…é›»ç³»çµ± GeoNode æ ¼å¼ï¼ˆé»èˆ‡ç·šæ®µï¼‰
					</div>
				</div>
				
				<!-- é¥‹ç·šè³‡è¨Š -->
				<div id="feederInfo" class="feeder-info" style="display: none;">
					<h4>ğŸ“Š é¥‹ç·šè³‡è¨Š</h4>
					<p id="feederDetails">ç­‰å¾…è¼‰å…¥...</p>
				</div>
				
				<!-- è¼‰å…¥ç‹€æ…‹ -->
				<div class="status-section">
					<h3>ğŸ“Š è¼‰å…¥ç‹€æ…‹</h3>
					<div id="loadStatus">è«‹é¸æ“‡ JSON æª”æ¡ˆé–‹å§‹è¼‰å…¥...</div>
				</div>
				
				<!-- ç·šæ®µé«˜äº®æ§åˆ¶ -->
				<div class="highlight-controls" style="display: none;" id="highlightControls">
					<h4 style="margin: 0 0 8px 0; font-size: 14px; color: #856404;">ğŸ¯ ç·šæ®µé«˜äº®</h4>
					<p style="margin: 0 0 8px 0; font-size: 12px; color: #856404;">é»é¸åœ°åœ–ä¸Šçš„ç·šæ®µé€²è¡Œé«˜äº®é¡¯ç¤º</p>
					<button class="reset-highlight-btn" onclick="resetLineHighlight()">
						ğŸ”„ é‡ç½®é«˜äº®
					</button>
				</div>
				
				<!-- åœ–å±¤æ§åˆ¶ -->
				<div class="layer-controls">
					<h3>ğŸ›ï¸ åœ–å±¤æ§åˆ¶</h3>
					<div id="layerControlsContainer">
						<p style="color: #666; font-size: 14px; text-align: center; padding: 20px;">
							è¼‰å…¥æª”æ¡ˆå¾Œå°‡é¡¯ç¤ºåœ–å±¤æ§åˆ¶é¸é …
						</p>
					</div>
				</div>
				<!-- æ–°å¢ï¼šå¿«æ·éµèªªæ˜ - åŠ åœ¨é€™è£¡ -->

				<!-- è¼‰å…¥ä¸­æŒ‡ç¤ºå™¨ -->
				<div class="loading" id="loadingIndicator">
					<div>â³ æ­£åœ¨è™•ç†æª”æ¡ˆ...</div>
				</div>
				
				<!-- åœ–ä¾‹ -->
				<div class="legend">
					<h4 style="margin: 10px 0 5px 0;">ğŸ”Œ ç·šè·¯åœ–ä¾‹</h4>
					<div class="legend-item">
						<div class="legend-line" style="background: #dc3545; color: #dc3545;"></div>
						<span>22.8kV ä¸»å¹¹ç·š (æ¶ç©º)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #dc3545;"></div>
						<span>22.8kV ä¸»å¹¹ç·š (åœ°ä¸‹)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line" style="background: #007bff; color: #007bff;"></div>
						<span>22.8kV åˆ†æ­§ç·š (æ¶ç©º)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #007bff;"></div>
						<span>22.8kV åˆ†æ­§ç·š (åœ°ä¸‹)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line" style="background: #fd7e14; color: #fd7e14;"></div>
						<span>11.4kV ä¸»å¹¹ç·š (æ¶ç©º)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #fd7e14;"></div>
						<span>11.4kV ä¸»å¹¹ç·š (åœ°ä¸‹)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line" style="background: #28a745; color: #28a745;"></div>
						<span>11.4kV åˆ†æ­§ç·š (æ¶ç©º)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #28a745;"></div>
						<span>11.4kV åˆ†æ­§ç·š (åœ°ä¸‹)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line" style="background: #6c757d; color: #6c757d;"></div>
						<span>å…¶ä»–ç·šè·¯ (æ¶ç©º)</span>
					</div>
					<div class="legend-item">
						<div class="legend-line-dashed" style="color: #6c757d;"></div>
						<span>å…¶ä»–ç·šè·¯ (åœ°ä¸‹)</span>
					</div>
					<hr style="margin: 8px 0;">
					<div style="font-size: 11px; color: #666; text-align: center;">
						ğŸ’¡ é»é¸ç·šæ®µé€²è¡Œé«˜äº®é¡¯ç¤º
					</div>
				</div>
				
				<div style="margin: 15px 0; padding: 10px; background: #fff3cd; border-radius: 6px;">
					<h4 style="margin: 0 0 10px 0; color: #856404;">ğŸ§ª æ–¹å‘åŠŸèƒ½æ¸¬è©¦</h4>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
						<button onclick="testDeviceOrientation()" 
								style="padding: 6px; font-size: 11px; background: #17a2b8; color: white; border: none; border-radius: 4px;">
							ğŸ§ª æ”¯æ´æ¸¬è©¦
						</button>
						<button onclick="startOrientationTest()" 
								style="padding: 6px; font-size: 11px; background: #6c757d; color: white; border: none; border-radius: 4px;">
							ğŸ“Š æ•¸æ“šæ¸¬è©¦
						</button>
					</div>
				</div>
			</div>
			
			<div class="map-container">
				<div id="map"></div>
				<!-- ğŸ†• åœ¨é€™è£¡åŠ å…¥ï¼šå¯æ”¶åˆåœ–å±¤åˆ‡æ›å™¨ -->
				<div class="layer-switcher-compact" id="layerSwitcherCompact">
					<button class="layer-toggle-btn" onclick="toggleLayerMenu()">
						ğŸ—ºï¸ åœ–å±¤
					</button>
					
					<div class="layer-menu" id="layerMenu" style="display: none;">
						<div class="layer-group">
							<h5>ğŸ—ºï¸ åŸºç¤åœ–å±¤</h5>
							<div class="layer-option">
								<input type="radio" id="googleStreets" name="baseLayer" value="googleStreets" checked>
								<label for="googleStreets">Google è¡—æ™¯åœ–</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="googleSatellite" name="baseLayer" value="googleSatellite">
								<label for="googleSatellite">Google è¡›æ˜Ÿå½±åƒ</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="googleHybrid" name="baseLayer" value="googleHybrid">
								<label for="googleHybrid">Google æ··åˆåœ–</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="openStreetMap" name="baseLayer" value="openStreetMap">
								<label for="openStreetMap">OpenStreetMap</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="esriWorldImagery" name="baseLayer" value="esriWorldImagery">
								<label for="esriWorldImagery">Esri è¡›æ˜Ÿåœ–</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="nlscMap" name="baseLayer" value="nlscMap">
								<label for="nlscMap">åœ‹åœŸæ¸¬ç¹ªé›»å­åœ°åœ–</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="nlscContour" name="baseLayer" value="nlscContour">
								<label for="nlscContour">åœ‹åœŸæ¸¬ç¹ªåœ°åœ–(å«ç­‰é«˜ç·š)</label>
							</div>
							<div class="layer-option">
								<input type="radio" id="nlscPhoto" name="baseLayer" value="nlscPhoto">
								<label for="nlscPhoto">åœ‹åœŸæ¸¬ç¹ªæ­£å°„å½±åƒ</label>
							</div>
						</div>
						
						<div class="layer-group">
							<h5>ğŸ›ï¸ æ”¿åºœåœ–å±¤</h5>
							<div class="layer-option">
								<input type="checkbox" id="roadNetworkLayer" onchange="toggleOverlayLayer('roadNetwork')">
								<label for="roadNetworkLayer">è·¯ç¶²åœ–å±¤</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="railwayLayer" onchange="toggleOverlayLayer('railway')">
								<label for="railwayLayer">éµè·¯åœ–å±¤</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="publicLandLayer" onchange="toggleOverlayLayer('landmark')">
								<label for="publicLandLayer">å…¬æœ‰åœŸåœ°åœ–</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="adminBoundaryLayer" onchange="toggleOverlayLayer('cadastre')">
								<label for="adminBoundaryLayer">è¡Œæ”¿å€ç•Œåœ–</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="landParcelLayer" onchange="toggleOverlayLayer('section')">
								<label for="landParcelLayer">æ®µç±åœ–</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="villageLayer" onchange="toggleOverlayLayer('village')">
								<label for="villageLayer">æ‘é‡Œç•Œåœ–</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="roadMilestoneLayer" onchange="toggleOverlayLayer('wayMeter')">
								<label for="roadMilestoneLayer">å…¬è·¯é‡Œç¨‹æ¨™èªŒ</label>
							</div>
						</div>
						
						<div class="layer-group">
							<h5>ğŸ”ï¸ é«˜é›„å¸‚å°ˆç”¨åœ–å±¤</h5>
							<div class="layer-option">
								<input type="checkbox" id="kaohsiungSlopeLayer" onchange="toggleOverlayLayer('kaohsiungSlope')">
								<label for="kaohsiungSlopeLayer">é«˜é›„å±±å¡åœ°ç¯„åœ</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="industrialZoneLayer" onchange="toggleOverlayLayer('industrialZone')">
								<label for="industrialZoneLayer">å·¥æ¥­å€ç¯„åœ</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="industrialLandLayer" onchange="toggleOverlayLayer('industrialLand')">
								<label for="industrialLandLayer">å·¥æ¥­å€åœ°ç±åœ–</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="industrialUserLayer" onchange="toggleOverlayLayer('industrialUser')">
								<label for="industrialUserLayer">å·¥æ¥­å€ç”¨æˆ¶å</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="urbanPlanLayer" onchange="toggleOverlayLayer('urbanPlan')">
								<label for="urbanPlanLayer">é«˜é›„å¸‚éƒ½å¸‚è¨ˆç•«åœ–</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="urbanPlanBoundaryLayer" onchange="toggleOverlayLayer('urbanPlanBoundary')">
								<label for="urbanPlanBoundaryLayer">é«˜é›„å¸‚éƒ½å¸‚è¨ˆç•«ç¯„åœåœ–</label>
							</div>
							<div class="layer-option">
								<input type="checkbox" id="nationalLandPlanLayer" onchange="toggleOverlayLayer('trafficNetwork')">
								<label for="nationalLandPlanLayer">åœ‹åœŸè¨ˆç•«åœ–</label>
							</div>
						</div>
						
						<div class="layer-group">
							<h5>ğŸ›ï¸ åœ–å±¤æ§åˆ¶</h5>
							<div class="layer-opacity-control">
								<span>é€æ˜åº¦:</span>
								<input type="range" class="opacity-slider" id="layerOpacity" 
									   min="0" max="100" value="100" onchange="adjustLayerOpacity(this.value)">
								<span id="opacityValue">100%</span>
							</div>
						</div>
					</div>
				</div>
				
				<!-- åŸæœ‰çš„æ§åˆ¶æŒ‰éˆ•ç¹¼çºŒä¿ç•™åœ¨ä¸‹é¢ -->
				<button class="fullscreen-btn" onclick="toggleFullscreen()">
					ğŸ”² å…¨è¢å¹•
				</button>
				


				
				
				<!-- ä¿®æ”¹ï¼šå®šä½æ§åˆ¶æŒ‰éˆ• -->
				<div class="location-controls">
					<button id="locateBtn" class="location-btn" onclick="toggleContinuousLocation()">
						ğŸ“ å®šä½
					</button>
					<button class="rotation-btn" id="followHeadingBtn" onclick="toggleFollowHeading()">
						ğŸ“± è·Ÿéš¨è£ç½®æ–¹å‘
					</button>
					<div id="compass" style="display: none; position: fixed; bottom: 180px; right: 20px; z-index: 1000;">
						<!-- æŒ‡åŒ—é‡å…§å®¹å°‡ç”± JavaScript å‹•æ…‹ç”Ÿæˆ -->
					</div>
				</div>

				<!-- ç°¡åŒ–ï¼šæ—‹è½‰æ§åˆ¶ - åªä¿ç•™è·Ÿéš¨æ–¹å‘ -->

								
				<!-- æ–°å¢ï¼šæ¸¬é‡å·¥å…· -->
				<div class="measure-controls">
					<button class="measure-btn" id="measureDistanceBtn" onclick="toggleMeasureDistance()">
						ğŸ“ æ¸¬è·
					</button>
					<button class="measure-btn" onclick="clearMeasurements()">
						ğŸ—‘ï¸ æ¸…é™¤
					</button>
				</div>
				

				
				
			</div>
		</div>
		

		
		<script>
			// å…¨åŸŸè®Šæ•¸
			let map;
			let allDevicesData = [];
			let allLinesData = [];
			let layerGroups = {};
			let layerCounts = {};
			let currentFeederInfo = null;
			let selectedLine = null; // å„²å­˜ç•¶å‰é¸ä¸­çš„ç·šæ®µ
			// ğŸ”§ æ–°å¢ï¼šç®­é ­ç®¡ç†
			let allArrowMarkers = []; // å„²å­˜æ‰€æœ‰ç®­é ­æ¨™è¨˜
			let arrowLayerGroup = null; // ç®­é ­åœ–å±¤ç¾¤çµ„
			// åœ°åœ–åˆå§‹åŒ–
			// åœ°åœ–åˆå§‹åŒ– - ä¿®æ”¹ç‰ˆ
			// ğŸŒŸ æ–°å¢ï¼šæ˜Ÿæ˜Ÿç®¡ç†
			let oppositeStarMarkers = []; // å„²å­˜æ‰€æœ‰æ˜Ÿæ˜Ÿæ¨™è¨˜
			let oppositeLayerGroup = null; // æ˜Ÿæ˜Ÿåœ–å±¤ç¾¤çµ„
			
			// ğŸ†• å…¨åŸŸè®Šæ•¸å„²å­˜é¥‹ç·šè³‡æ–™
			let feederDataMap = {};
			let feederList = [];
			// ğŸ†• é¥‹ç·šæ¸…å–® - æ ¹æ“šæ‚¨æä¾›çš„æª”æ¡ˆåç¨±
			// ğŸ†• è¶…é«˜é€Ÿè¼‰å…¥ç›¸é—œå…¨åŸŸè®Šæ•¸
			let feederCache = null;
			let fastJsonLoader = null;
			let localStorageManager = null;
			// æ–°å¢ï¼šå®šä½åŠŸèƒ½ç›¸é—œè®Šæ•¸
			let isContinuousLocationEnabled = false;
			let userLocationMarker;
			let watchId;

			// ğŸ†• ä¿®æ”¹åœ°åœ–åˆå§‹åŒ–å‡½æ•¸
			// ğŸ”§ ä¿®æ”¹ï¼šæ•´åˆè±å¯Œåœ–å±¤çš„åœ°åœ–åˆå§‹åŒ–å‡½æ•¸
			async function initMap() {
				console.log('ğŸ—ºï¸ åˆå§‹åŒ–åœ°åœ–...');
				
				// åˆå§‹åŒ–è¶…é«˜é€Ÿè¼‰å…¥çµ„ä»¶
				feederCache = new FeederCache();
				fastJsonLoader = new FastJsonLoader();
				localStorageManager = new LocalStorageManager();
				
				// å»ºç«‹åœ°åœ–å¯¦ä¾‹ï¼Œé è¨­ä¸­å¿ƒé»è¨­åœ¨é«˜é›„
				// å»ºç«‹åœ°åœ–å¯¦ä¾‹ï¼Œé è¨­ä¸­å¿ƒé»è¨­åœ¨é«˜é›„
				map = L.map('map', {
					center: [22.67, 120.34],
					zoom: 12,
					maxZoom: 22,
					rotate: true,
					rotateControl: {
						closeOnZeroBearing: false
					},
					bearing: 0,
					zoomControl: false  // ğŸ”§ æ–°å¢ï¼šç§»é™¤é è¨­çš„ç¸®æ”¾æ§åˆ¶æŒ‰éˆ•
				});
								
				// å®šç¾©åº§æ¨™ç³»çµ±
				proj4.defs([
					['EPSG:3826', '+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'],
					['EPSG:3828', '+proj=tmerc +lat_0=0 +lon_0=121 +k=0.9999 +x_0=250000 +y_0=0 +ellps=aust_SA +towgs84=-752,-358,-179,-.0000011698,.0000018398,.0000009822,.00002329 +units=m +no_defs'],
					['EPSG:4326', '+proj=longlat +datum=WGS84 +no_defs']
				]);
				
				// ğŸ†• æ•´åˆï¼šå»ºç«‹å¤šç¨®åœ°åœ–åœ–å±¤ï¼ˆå¾ç¬¬ä¸€æ”¯ç¨‹å¼ï¼‰
				window.mapLayers = {
					// Google ç³»åˆ—
					googleStreets: L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
						maxZoom: 22,
						subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
						attribution: 'Â© Google Maps'
					}),
					
					googleSatellite: L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
						maxZoom: 22,
						subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
						attribution: 'Â© Google Satellite'
					}),
					
					googleHybrid: L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
						maxZoom: 22,
						subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
						attribution: 'Â© Google Hybrid'
					}),
					
					// OpenStreetMap
					openStreetMap: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
						attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
						maxZoom: 22
					}),
					
					// Esri è¡›æ˜Ÿåœ–
					esriWorldImagery: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
						attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
						maxZoom: 22
					}),

					// ğŸ†• åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒåœ–å±¤
					nlscMap: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/EMAP/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					}),

					nlscContour: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/EMAP2/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					}),

					nlscPhoto: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/PHOTO2/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					})
				};
				
				// ğŸ†• æ•´åˆï¼šç–ŠåŠ åœ–å±¤ï¼ˆå¾ç¬¬ä¸€æ”¯ç¨‹å¼ï¼‰
	// ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨èˆ‡ç¬¬ä¸€ç‰ˆç›¸åŒçš„æ­£ç¢º WMTS æ ¼å¼
				window.overlayLayers = {
					// âœ… è·¯ç¶²åœ–å±¤ (å·²æ­£å¸¸é‹ä½œ)
					roadNetwork: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/ROAD/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 19,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					}),
					
					// âœ… éµè·¯åœ–å±¤ (å·²æ­£å¸¸é‹ä½œ)
					railway: L.tileLayer('https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png', {
						maxZoom: 30,
						subdomains: ['a', 'b', 'c'],
						attribution: 'Map data: &copy; OpenStreetMap contributors | Style: &copy; OpenRailwayMap'
					}),
					
					// ğŸ”§ ä¿®æ­£ï¼šå…¬æœ‰åœŸåœ°åœ– - ä½¿ç”¨æ­£ç¢ºçš„ WMTS URL
					landmark: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/LAND_OPENDATA/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					}),
					
					// ğŸ”§ ä¿®æ­£ï¼šè¡Œæ”¿å€ç•Œåœ– - ä½¿ç”¨æ­£ç¢ºçš„ WMTS URL
					cadastre: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/TOWN/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					}),
					
					// ğŸ”§ ä¿®æ­£ï¼šæ®µç±åœ– - ä½¿ç”¨æ­£ç¢ºçš„ WMTS URL
					section: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/LANDSECT/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					}),
					
					// âœ… æ‘é‡Œç•Œåœ– (å·²æ­£å¸¸é‹ä½œ)
					village: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/Village/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 30,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					}),
					
					// ğŸ”§ ä¿®æ­£ï¼šå…¬è·¯é‡Œç¨‹æ¨™èªŒ - ä½¿ç”¨æ­£ç¢ºçš„ WMTS URL
					wayMeter:L.tileLayer('https://wmts.nlsc.gov.tw/wmts/WAYMETER/default/GoogleMapsCompatible/{z}/{y}/{x}', {
					  maxZoom: 30,
					  attribution: 'Map data: &copy; OpenStreetMap contributors | Style: &copy; OpenRailwayMap'
				    }),
					
					// âœ… å…¶ä»–åœ–å±¤ä¿æŒä¸è®Š
					kaohsiungSlope: L.tileLayer.wms('https://swc.kcg.gov.tw/geoserver/KaoHill/ows', {
						layers: 'HillRange',
						format: 'image/png',
						transparent: true,
						version: '1.3.0',
						attribution: 'Â© é«˜é›„å¸‚æ°´åœŸä¿æŒå±€'
					}),
					
					industrialZone: L.tileLayer.wms('https://idbgis.ntpu.edu.tw/IDBMapService/GetMap.ashx', {
						layers: 'A03',
						format: 'image/png',
						transparent: true,
						version: '1.1.1',
						attribution: 'Â© NTPU IDB GIS'
					}),
					
					industrialLand: L.tileLayer.wms('https://idbgis.ntpu.edu.tw/IDBMapService/GetMap.ashx', {
						layers: 'C01',
						format: 'image/png',
						transparent: true,
						version: '1.1.1',
						attribution: 'Â© NTPU IDB GIS'
					}),
					
					industrialUser: L.tileLayer.wms('https://idbgis.ntpu.edu.tw/IDBMapService/GetMap.ashx', {
						layers: 'B01',
						format: 'image/png',
						transparent: true,
						version: '1.1.1',
						attribution: 'Â© NTPU IDB GIS'
					}),
					
					urbanPlan: L.tileLayer.wms('https://urbanproxy.kcg.gov.tw/arcgis/services/UrbanAPI/KcgUrbanDataForUrbanAPI/MapServer/WmsServer', {
						layers: 'é«˜é›„å¸‚éƒ½å¸‚è¨ˆç•«åœ–',
						format: 'image/png',
						transparent: true,
						version: '1.3.0',
						attribution: 'Â© é«˜é›„å¸‚æ”¿åºœ',
						crs: L.CRS.EPSG4326,
						bounds: L.latLngBounds([22.474447, 120.174156], [23.086414, 120.653181])
					}),
					
					urbanPlanBoundary: L.tileLayer.wms('https://urbanproxy.kcg.gov.tw/arcgis/services/UrbanAPI/KcgUrbanDataForPlanAPI/MapServer/WmsServer', {
						layers: 'é«˜é›„å¸‚éƒ½å¸‚è¨ˆç•«ç¯„åœåœ–',
						format: 'image/png',
						transparent: true,
						version: '1.3.0',
						attribution: 'Â© é«˜é›„å¸‚æ”¿åºœ'
					}),
					
					trafficNetwork: L.tileLayer('https://wmts.nlsc.gov.tw/wmts/LUIMAP/default/GoogleMapsCompatible/{z}/{y}/{x}', {
						maxZoom: 19,
						attribution: 'Â© å…§æ”¿éƒ¨åœ‹åœŸæ¸¬ç¹ªä¸­å¿ƒ'
					})
				};
				
				// é è¨­è¼‰å…¥ Google è¡—æ™¯åœ–
				window.currentBaseLayer = window.mapLayers.googleStreets.addTo(map);
				
				// åˆå§‹åŒ–ç®­é ­å’Œæ˜Ÿæ˜Ÿåœ–å±¤ç¾¤çµ„
				arrowLayerGroup = L.layerGroup().addTo(map);
				oppositeLayerGroup = L.layerGroup().addTo(map);
				
				// åˆå§‹åŒ–æ¸¬é‡å·¥å…·
				initializeMeasureTools();
				
				// åˆå§‹åŒ–åœ–å±¤åˆ‡æ›äº‹ä»¶
				initializeLayerSwitcher();
				
				// ğŸ”§ ä¿®æ­£ï¼šåœ°åœ–æ—‹è½‰æ™‚è‡ªå‹•æ›´æ–°æŒ‡åŒ—é‡
				map.on('rotate', function(e) {
					const bearing = map.getBearing ? map.getBearing() : 0;
					updateCompassDisplay(bearing);
				});
				// åœ°åœ–é»é¸äº‹ä»¶ - é‡ç½®ç·šæ®µé«˜äº®
				map.on('click', function(e) {
					resetLineHighlight();
				});
				
				// è¼‰å…¥é¥‹ç·šè³‡æ–™
				await loadFeederDataFromSheet();
				
				// å»ºç«‹é€²åº¦æ¢
				createProgressBar();
				
				updateLoadStatus('åœ°åœ–åˆå§‹åŒ–å®Œæˆï¼Œè«‹é¸æ“‡ JSON æª”æ¡ˆæˆ–å¾é›²ç«¯è¼‰å…¥...');
				
				    // ğŸ†• åœ¨æœ€å¾ŒåŠ å…¥é€™è¡Œ
				initMobileNavigation();
				console.log('âœ… åœ°åœ–åˆå§‹åŒ–å®Œæˆ');
			}

// ğŸ”§ æ–°å¢ï¼šæª¢æ¸¬ä¸¦éš±è—æ‰‹æ©Ÿç‰ˆå…¨è¢å¹•æŒ‰éˆ•
function handleFullscreenButtonVisibility() {
    const fullscreenBtn = document.querySelector('.fullscreen-btn');
    
    if (fullscreenBtn) {
        // æª¢æ¸¬æ˜¯å¦ç‚ºæ‰‹æ©Ÿè£ç½®
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isSmallScreen = window.innerWidth <= 768;
        
        if (isMobile || isSmallScreen) {
            fullscreenBtn.style.display = 'none';
            console.log('ğŸ“± æ‰‹æ©Ÿæ¨¡å¼ï¼šå·²éš±è—å…¨è¢å¹•æŒ‰éˆ•');
        } else {
            fullscreenBtn.style.display = 'block';
            console.log('ğŸ–¥ï¸ æ¡Œé¢æ¨¡å¼ï¼šé¡¯ç¤ºå…¨è¢å¹•æŒ‰éˆ•');
        }
    }
}

// åœ¨åœ°åœ–åˆå§‹åŒ–å®Œæˆå¾ŒåŸ·è¡Œ
handleFullscreenButtonVisibility();

// ç›£è½è¦–çª—å¤§å°è®ŠåŒ–
window.addEventListener('resize', handleFullscreenButtonVisibility);

			
			// æ–°å¢ï¼šå°ç£åœ°å€é›»åŠ›åº§æ¨™åŸé»
const taiGridArr = [
    {taiCode: 'A', taiGrid: [170000, 2750000]},
    {taiCode: 'B', taiGrid: [250000, 2750000]},
    {taiCode: 'C', taiGrid: [330000, 2750000]},
    {taiCode: 'D', taiGrid: [170000, 2700000]},
    {taiCode: 'E', taiGrid: [250000, 2700000]},
    {taiCode: 'F', taiGrid: [330000, 2700000]},
    {taiCode: 'G', taiGrid: [170000, 2650000]},
    {taiCode: 'H', taiGrid: [250000, 2650000]},
    {taiCode: 'J', taiGrid: [90000, 2600000]},
    {taiCode: 'K', taiGrid: [170000, 2600000]},
    {taiCode: 'L', taiGrid: [250000, 2600000]},
    {taiCode: 'M', taiGrid: [90000, 2550000]},
    {taiCode: 'N', taiGrid: [170000, 2550000]},
    {taiCode: 'O', taiGrid: [250000, 2550000]},
    {taiCode: 'P', taiGrid: [90000, 2500000]},
    {taiCode: 'Q', taiGrid: [170000, 2500000]},
    {taiCode: 'R', taiGrid: [250000, 2500000]},
    {taiCode: 'T', taiGrid: [170000, 2450000]},
    {taiCode: 'U', taiGrid: [250000, 2450000]},
    {taiCode: 'V', taiGrid: [170000, 2400000]},
    {taiCode: 'W', taiGrid: [250000, 2400000]},
    {taiCode: 'X', taiGrid: [275000, 2614000]},
    {taiCode: 'Y', taiGrid: [275000, 2564000]}
];

// æ–°å¢ï¼šå®šä½åŠŸèƒ½
function toggleContinuousLocation() {
    if (isContinuousLocationEnabled) {
        disableContinuousLocation();
    } else {
        enableContinuousLocation();
    }
}

// ğŸ”§ ä¿®æ­£ï¼šåŠ å…¥è·é›¢é–¾å€¼é˜²æ­¢æŠ–å‹•
let lastPosition = null;
const POSITION_THRESHOLD = 5; // 5å…¬å°ºé–¾å€¼

function enableContinuousLocation() {
    if (navigator.geolocation) {
        isContinuousLocationEnabled = true;
        const btn = document.getElementById('locateBtn');
        btn.classList.add('active');
        btn.textContent = 'â¹ï¸ åœæ­¢å®šä½';

        watchId = navigator.geolocation.watchPosition(function (position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const currentPosition = L.latLng(lat, lng);

            // ğŸ”§ æ–°å¢ï¼šæª¢æŸ¥è·é›¢è®ŠåŒ–æ˜¯å¦è¶…éé–¾å€¼
            if (lastPosition && lastPosition.distanceTo(currentPosition) < POSITION_THRESHOLD) {
                console.log('ğŸ”‡ ä½ç½®è®ŠåŒ–å¤ªå°ï¼Œè·³éæ›´æ–°');
                return; // è·³éæ›´æ–°
            }

            lastPosition = currentPosition;

            if (!userLocationMarker) {
                // å‰µå»ºè‡ªå®šç¾©å®šä½åœ–æ¨™
                const locationIcon = L.divIcon({
                    html: '<div class="location-marker"><div class="center-dot"></div></div>',
                    className: 'custom-location-icon',
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                userLocationMarker = L.marker([lat, lng], {
                    icon: locationIcon
                }).addTo(map);
            } else {
                // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨å¹³æ»‘ç§»å‹•è€Œéç¬é–“è·³èº
                userLocationMarker.setLatLng([lat, lng]);
            }

            // ğŸ”§ ä¿®æ­£ï¼šåªåœ¨å¤§å¹…åº¦ä½ç½®è®ŠåŒ–æ™‚æ‰ç§»å‹•åœ°åœ–è¦–é‡
            if (!lastPosition || lastPosition.distanceTo(currentPosition) > 50) {
                map.flyTo([lat, lng], 16, {
                    duration: 1.0, // å¢åŠ å‹•ç•«æ™‚é–“è®“ç§»å‹•æ›´å¹³æ»‘
                    noMoveStart: true
                });
            }

        }, function () {
            alert('ç„¡æ³•ç²å–æ‚¨çš„ä½ç½®');
            disableContinuousLocation();
        }, {
            enableHighAccuracy: true,
            maximumAge: 10000, // ğŸ”§ ä¿®æ­£ï¼šå¢åŠ å¿«å–æ™‚é–“æ¸›å°‘é »ç¹æ›´æ–°
            timeout: 15000
        });
    } else {
        alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æŒåœ°ç†å®šä½');
    }
}

// ğŸ”§ ä¿®æ­£ï¼šåœ¨åœæ­¢å®šä½æ™‚é‡ç½® lastPosition
function disableContinuousLocation() {
    if (isContinuousLocationEnabled) {
        isContinuousLocationEnabled = false;
        lastPosition = null; // é‡ç½®ä½ç½®è¨˜éŒ„
        const btn = document.getElementById('locateBtn');
        btn.classList.remove('active');
        btn.textContent = 'ğŸ“ å®šä½';

        if (watchId) {
            navigator.geolocation.clearWatch(watchId);
            watchId = null;
        }

        if (userLocationMarker) {
            map.removeLayer(userLocationMarker);
            userLocationMarker = null;
        }
    }
}

// æ–°å¢ï¼šåœ–è™Ÿåº§æ¨™è½‰æ›åŠŸèƒ½
function searchByCoordinate() {
    const input = document.getElementById('coordinateInput');
    const coordinate = input.value.trim().toUpperCase();
    
    if (!coordinate) {
        showToast('è«‹è¼¸å…¥åœ–è™Ÿåº§æ¨™ï¼', 'error');
        return;
    }
    
    try {
        const result = convertPowerCoordinate(coordinate);
        const [lng, lat] = result.split(',').map(Number);
        
        // åœ¨åœ°åœ–ä¸Šæ¨™è¨˜ä½ç½®
        const marker = L.marker([lat, lng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        const popupContent = `
            <div style="text-align: center;">
                <h4>ğŸ“ åœ–è™Ÿåº§æ¨™å®šä½</h4>
                <p><strong>åº§æ¨™:</strong> ${coordinate}</p>
                <p><strong>ç¶“ç·¯åº¦:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                <button onclick="openStreetView(${lat}, ${lng})" 
                        style="margin: 5px; padding: 5px 10px; background: #4285f4; color: white; border: none; border-radius: 3px; cursor: pointer;">
                    ğŸ—ºï¸ è¡—æ™¯åœ–
                </button>
                <button onclick="copyCoordinates(${lat}, ${lng})" 
                        style="margin: 5px; padding: 5px 10px; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer;">
                    ğŸ“‹ è¤‡è£½åº§æ¨™
                </button>
            </div>
        `;
        
        marker.bindPopup(popupContent).openPopup();
        
        // ç§»å‹•åœ°åœ–åˆ°è©²ä½ç½®
        map.flyTo([lat, lng], 18, {
            duration: 1.0
        });
        
        showToast(`âœ… åº§æ¨™å®šä½æˆåŠŸ: ${coordinate}`, 'success');
        
    } catch (error) {
        console.error('åº§æ¨™è½‰æ›éŒ¯èª¤:', error);
        showToast(`âŒ åº§æ¨™è½‰æ›å¤±æ•—: ${error.message}`, 'error');
    }
}

// æ–°å¢ï¼šé›»åŠ›åº§æ¨™è½‰æ›å‡½æ•¸
function convertPowerCoordinate(powerCoord, lonOffset = -0.00002, latOffset = -0.00001) {
    powerCoord = powerCoord.toUpperCase();
    
    // é©—è­‰æ ¼å¼
    if (!/^[A-HJ-Z]\d{4}[A-H][A-E]\d{2,4}$/.test(powerCoord)) {
        throw new Error('ç„¡æ•ˆçš„é›»åŠ›åº§æ¨™æ ¼å¼');
    }

    try {
        // è§£æé›»åŠ›åº§æ¨™
        const zone = powerCoord.charAt(0);
        const block = powerCoord.substring(1, 5);
        const subBlock = powerCoord.substring(5, 7);
        const detail = powerCoord.substring(7, 11);

        // è¨ˆç®—ç›¸å°ä½ç§»
        const offsetX = calculateOffset(block, subBlock, detail, true);
        const offsetY = calculateOffset(block, subBlock, detail, false);

        // æŸ¥æ‰¾å°æ‡‰çš„åŸé»åº§æ¨™
        const taiXY = taiGridArr.find(e => e.taiCode === zone);
        if (!taiXY) {
            throw new Error('ç„¡æ•ˆçš„åˆ†å€ä»£ç¢¼');
        }

        // è¨ˆç®—TWD67åº§æ¨™
        const twd67X = parseFloat((taiXY.taiGrid[0] + offsetX).toFixed(6));
        const twd67Y = parseFloat((taiXY.taiGrid[1] + offsetY).toFixed(6));

        // è½‰æ›ç‚ºWGS84
        let wgs84 = proj4('EPSG:3828', 'WGS84', [twd67X, twd67Y]);
        wgs84[0] = parseFloat((wgs84[0] + lonOffset).toFixed(10));
        wgs84[1] = parseFloat((wgs84[1] + latOffset).toFixed(10));
        
        return `${wgs84[0]},${wgs84[1]}`;

    } catch (error) {
        throw new Error('è½‰æ›éç¨‹ç™¼ç”ŸéŒ¯èª¤: ' + error.message);
    }
}

function calculateOffset(block, subBlock, detail, isX) {
    let offset = 0;
    if (isX) {
        offset += parseInt(block.substring(0, 2)) * 800;
        offset += (subBlock.charCodeAt(0) - 65) * 100;
        if (detail.length === 2) {
            offset += parseInt(detail.substring(0, 1)) * 10;
        } else if (detail.length === 4) {
            offset += parseInt(detail.substring(2, 3)) * 1;
        }
    } else {
        offset += parseInt(block.substring(2, 4)) * 500;
        offset += (subBlock.charCodeAt(1) - 65) * 100;
        if (detail.length === 2) {
            offset += parseInt(detail.substring(1, 2)) * 10;
        } else if (detail.length === 4) {
            offset += parseInt(detail.substring(3, 4)) * 1;
        }
    }
    return offset;
}
			
			// é‡ç½®ç·šæ®µé«˜äº® - ä¿®æ”¹ç‰ˆ
			function resetLineHighlight() {
				if (selectedLine) {
					selectedLine.setStyle(selectedLine.originalStyle);
					
					// ğŸ”§ æ•ˆèƒ½å„ªåŒ–ï¼šæ‰¹é‡é‡ç½®ç®­é ­é¡è‰²
					if (selectedLine.arrowMarkers && selectedLine.arrowMarkers.length > 0) {
						selectedLine.arrowMarkers.forEach(marker => {
							updateArrowColor(marker, selectedLine.originalStyle.color);
						});
					}
					
					selectedLine = null;
					console.log('ğŸ”„ å·²é‡ç½®ç·šæ®µé«˜äº®');
				}
			}
			
			// æ›´æ–°è¼‰å…¥ç‹€æ…‹
			function updateLoadStatus(message) {
				const statusElement = document.getElementById('loadStatus');
				statusElement.textContent = message;
				console.log('ğŸ“Š', message);
			}
			
		// ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨å‘½åå‡½æ•¸ä»¥ä¾¿é‡æ–°ç¶å®š
		document.getElementById('fileInput').addEventListener('change', handleFileInput);
			
		// è™•ç† JSON è³‡æ–™ - ä¿®æ­£ç‰ˆï¼ˆé‡å°å°é›»æ ¼å¼ï¼‰
	function processJsonData(data, fileName) {
		console.log('ğŸ“ é–‹å§‹è™•ç†æª”æ¡ˆ:', fileName);
		console.log('ğŸ“Š åŸå§‹è³‡æ–™çµæ§‹:', data);
		
		// æ¸…é™¤èˆŠè³‡æ–™
		clearAllLayers();
		allDevicesData = [];
		allLinesData = [];
		layerGroups = {};
		layerCounts = {};
		currentFeederInfo = null;
		selectedLine = null; // é‡ç½®é¸ä¸­ç·šæ®µ
		
		let processedPointCount = 0;
		let processedLineCount = 0;
		let totalNodes = 0;
		let totalLinks = 0;
		
		// ğŸ”§ ä¿®æ­£ç‰ˆï¼šè™•ç†è£ç½®æ–¹å‘äº‹ä»¶ - ä¿®æ­£è§’åº¦åè½‰å•é¡Œ
		let lastHeading = null;
		const HEADING_THRESHOLD = 1; // å¢åŠ æ–¹å‘è®ŠåŒ–é–¾å€¼
		let orientationSupported = false;
		let permissionGranted = false;
		
		// è™•ç†å°é›»é…é›»ç³»çµ±çš„ GeoNode å’Œ GeoLink æ ¼å¼
		if (data.GeoNode && Array.isArray(data.GeoNode)) {
			console.log('âœ… è­˜åˆ¥ç‚ºå°é›»é…é›»ç³»çµ±æ ¼å¼');
			
			const geoNodes = data.GeoNode;
			const geoLinks = data.GeoLink || [];
			
			totalNodes = geoNodes.length;
			totalLinks = geoLinks.length;
			
			updateLoadStatus(`æ‰¾åˆ° ${totalNodes} å€‹è¨­å‚™ç¯€é», ${totalLinks} æ¢é€£æ¥ç·šæ®µï¼Œé–‹å§‹è™•ç†...`);
			
			// æå–é¥‹ç·šè³‡è¨Š
			if (geoNodes.length > 0) {
				extractFeederInfo(geoNodes[0], fileName);
			}
			
			// ğŸ”§ é‡è¦ä¿®æ­£ï¼šå…ˆè™•ç†æ‰€æœ‰é»è¨­å‚™ (GeoNode) - ç¢ºä¿ allDevicesData å®Œæ•´
			console.log('ğŸ”„ ç¬¬ä¸€éšæ®µï¼šè™•ç†æ‰€æœ‰é»è¨­å‚™...');
			geoNodes.forEach((node, index) => {
				try {
					const processedNode = processGeoNode(node, index);
					if (processedNode) {
						allDevicesData.push(processedNode);
						processedPointCount++;
					}
				} catch (error) {
					console.warn(`âš ï¸ GeoNode ${index} è™•ç†å¤±æ•—:`, error, node);
				}
			});
			
			console.log(`âœ… ç¬¬ä¸€éšæ®µå®Œæˆï¼šè™•ç†äº† ${processedPointCount} å€‹é»è¨­å‚™`);
			console.log(`ğŸ“Š allDevicesData ç¾åœ¨åŒ…å« ${allDevicesData.length} å€‹è¨­å‚™`);
			
			// ğŸ”§ é‡è¦ä¿®æ­£ï¼šå†è™•ç†ç·šæ®µ (GeoLink) - æ­¤æ™‚å¯ä»¥æŸ¥æ‰¾ç¯€é»è³‡æ–™
			console.log('ğŸ”„ ç¬¬äºŒéšæ®µï¼šè™•ç†æ‰€æœ‰ç·šæ®µ...');
			geoLinks.forEach((link, index) => {
				try {
					const processedLine = processGeoLink(link, index);
					if (processedLine) {
						allLinesData.push(processedLine);
						processedLineCount++;
					}
				} catch (error) {
					console.warn(`âš ï¸ GeoLink ${index} è™•ç†å¤±æ•—:`, error, link);
				}
			});
			
			console.log(`âœ… ç¬¬äºŒéšæ®µå®Œæˆï¼šè™•ç†äº† ${processedLineCount} æ¢ç·šæ®µ`);
			
		} else {
			// è™•ç†å…¶ä»–æ ¼å¼ï¼ˆä¿æŒåŸæœ‰é‚è¼¯ï¼‰
			let features = [];
			
			if (Array.isArray(data)) {
				features = data;
				console.log('âœ… è­˜åˆ¥ç‚º Features é™£åˆ—æ ¼å¼');
			} else if (data.type === 'FeatureCollection' && data.features) {
				features = data.features;
				console.log('âœ… è­˜åˆ¥ç‚º GeoJSON FeatureCollection');
			} else if (data.features && Array.isArray(data.features)) {
				features = data.features;
				console.log('âœ… è­˜åˆ¥ç‚ºåŒ…å« features çš„æ ¼å¼');
			} else {
				console.error('âŒ ä¸æ”¯æ´çš„è³‡æ–™æ ¼å¼ï¼Œè³‡æ–™çµæ§‹:', Object.keys(data));
				updateLoadStatus('âŒ ä¸æ”¯æ´çš„è³‡æ–™æ ¼å¼ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆçµæ§‹');
				return;
			}
			
			totalNodes = features.length;
			updateLoadStatus(`æ‰¾åˆ° ${totalNodes} å€‹ Featureï¼Œé–‹å§‹è™•ç†...`);
			
			// æå–é¥‹ç·šè³‡è¨Š
			if (features.length > 0) {
				extractFeederInfo(features[0], fileName);
			}
			
			// è™•ç†æ¯å€‹ Feature
			features.forEach((feature, index) => {
				try {
					if (!feature.type || feature.type !== 'Feature') {
						console.warn(`Feature ${index} æ ¼å¼ç„¡æ•ˆ:`, feature);
						return;
					}
					
					if (!feature.geometry || !feature.geometry.type) {
						console.warn(`Feature ${index} ç¼ºå°‘ geometry:`, feature);
						return;
					}
					
					const geometryType = feature.geometry.type;
					
					if (geometryType === 'Point') {
						const processedNode = processPointFeature(feature, index);
						if (processedNode) {
							allDevicesData.push(processedNode);
							processedPointCount++;
						}
					} else if (geometryType === 'LineString') {
						const processedLine = processLineFeature(feature, index);
						if (processedLine) {
							allLinesData.push(processedLine);
							processedLineCount++;
						}
					}
				} catch (error) {
					console.warn(`âš ï¸ Feature ${index} è™•ç†å¤±æ•—:`, error, feature);
				}
			});
		}
		
		console.log(`âœ… æˆåŠŸè™•ç† ${processedPointCount} å€‹é»è¨­å‚™, ${processedLineCount} æ¢ç·šæ®µ`);
		updateLoadStatus(`âœ… æˆåŠŸè¼‰å…¥ ${processedPointCount} å€‹è¨­å‚™, ${processedLineCount} æ¢ç·šæ®µ`);
		
		// å»ºç«‹åœ–å±¤æ§åˆ¶
		createLayerControls();
		
		// è‡ªå‹•ç¸®æ”¾åˆ°è³‡æ–™ç¯„åœ
		if (processedPointCount > 0 || processedLineCount > 0) {
			fitMapToData();
		}
		
		// é¡¯ç¤ºé¥‹ç·šè³‡è¨Š
		displayFeederInfo();
		
		// é¡¯ç¤ºé«˜äº®æ§åˆ¶
		if (processedLineCount > 0) {
			document.getElementById('highlightControls').style.display = 'block';
		}
	}

	// è™•ç†å°é›» GeoLink - å®Œå…¨ä¿®æ­£ç‰ˆï¼ˆä¿®æ­£å±¬æ€§ä½ç½®ï¼‰
	function processGeoLink(link, index) {
		console.log(`ğŸ” è™•ç† GeoLink ${index}:`, link);
		
		if (!link.type || link.type !== 'Feature') {
			console.warn(`GeoLink ${index} ä¸æ˜¯æœ‰æ•ˆçš„ Feature:`, link);
			return null;
		}
		
		const geometry = link.geometry;
		if (!geometry || geometry.type !== 'LineString') {
			console.warn(`GeoLink ${index} ä¸æ˜¯ç·šæ®µå¹¾ä½•:`, link);
			return null;
		}
		
		// ğŸ”§ é‡è¦ä¿®æ­£ï¼šGeoLink çš„å±¬æ€§ä¹Ÿåœ¨ geometry.properties å…§éƒ¨ï¼ˆå’Œ GeoNode ä¸€æ¨£ï¼‰
		let properties = {};
		
		// å„ªå…ˆé †åºï¼šgeometry.properties > link.properties > ç©ºç‰©ä»¶
		if (geometry.properties && typeof geometry.properties === 'object') {
			properties = geometry.properties;
			console.log(`âœ… GeoLink ${index} å¾ geometry.properties å–å¾—å±¬æ€§`);
		} else if (link.properties && typeof link.properties === 'object') {
			properties = link.properties;
			console.log(`âœ… GeoLink ${index} å¾ link.properties å–å¾—å±¬æ€§`);
		} else {
			console.warn(`GeoLink ${index} ç„¡æ³•æ‰¾åˆ°æœ‰æ•ˆçš„ properties`);
			properties = {};
		}
		
		console.log(`ğŸ” GeoLink ${index} å®Œæ•´å±¬æ€§:`, properties);
		
		const coordinates = geometry.coordinates;
		
		if (!coordinates || !Array.isArray(coordinates) || coordinates.length < 2) {
			console.warn(`GeoLink ${index} åº§æ¨™æ ¼å¼ç„¡æ•ˆ:`, coordinates);
			return null;
		}
		
		// è½‰æ›åº§æ¨™æ ¼å¼ä¸¦é©—è­‰
		const latLngs = [];
		for (let i = 0; i < coordinates.length; i++) {
			const coord = coordinates[i];
			if (!Array.isArray(coord) || coord.length < 2) {
				console.warn(`GeoLink ${index} ç¬¬ ${i} å€‹åº§æ¨™ç„¡æ•ˆ:`, coord);
				continue;
			}
			
			// è™•ç†å­—ä¸²æ ¼å¼åº§æ¨™ - è½‰æ›ç‚ºæ•¸å­—
			const lng = parseFloat(coord[0]);
			const lat = parseFloat(coord[1]);
			
			if (isNaN(lng) || isNaN(lat)) {
				console.warn(`GeoLink ${index} ç¬¬ ${i} å€‹åº§æ¨™æ•¸å€¼ç„¡æ•ˆ:`, coord);
				continue;
			}
			
			// æª¢æŸ¥åº§æ¨™åˆç†æ€§ï¼ˆå°ç£ç¯„åœï¼‰
			if (lng >= 118 && lng <= 122 && lat >= 21 && lat <= 26) {
				latLngs.push([lat, lng]);
			} else {
				console.warn(`GeoLink ${index} ç¬¬ ${i} å€‹åº§æ¨™è¶…å‡ºå°ç£ç¯„åœ:`, [lng, lat]);
			}
		}
		
		if (latLngs.length < 2) {
			console.warn(`GeoLink ${index} æœ‰æ•ˆåº§æ¨™é»ä¸è¶³:`, latLngs);
			return null;
		}
		
		// åˆ†é¡ç·šæ®µ - æ ¹æ“šé›»å£“ç­‰ç´šå’Œç·šè·¯é¡å‹
		const category = categorizeGeoLinkAdvanced(properties);
		
		console.log(`âœ… GeoLink ${index} è™•ç†æˆåŠŸï¼Œåº§æ¨™é»æ•¸: ${latLngs.length}, é¡åˆ¥: ${category}`);
		
		return {
			coordinates: latLngs,
			properties: properties,
			category: category,
			featureIndex: index,
			type: 'LineString'
		};
	}

	// GeoLink é€²éšåˆ†é¡ - å®Œå…¨ä¿®æ­£ç‰ˆï¼ˆåŠ å¼·é™¤éŒ¯è¼¸å‡ºï¼‰
	function categorizeGeoLinkAdvanced(properties) {
		console.log('ğŸ” GeoLink å®Œæ•´å±¬æ€§åˆ†æ:', properties);
		
		// ğŸ”§ ä¿®æ­£ï¼šç›´æ¥å¾ GeoLink å±¬æ€§ä¸­å–å¾—é›»å£“ç­‰ç´š
		let voltageLevel = 'unknown';
		
		// æ–¹æ³•1: ç›´æ¥å¾ GeoLink å±¬æ€§åˆ¤æ–·é›»å£“ç­‰ç´š
		const vlevel = properties.VLevel || properties.vlevel || '';
		console.log(`ğŸ” GeoLink VLevel åŸå§‹å€¼:`, vlevel, `(é¡å‹: ${typeof vlevel})`);
		
		if (vlevel) {
			const vLevel = parseInt(vlevel);
			if (vLevel === 1) {
				voltageLevel = '11.4kv';
			} else if (vLevel === 2) {
				voltageLevel = '22.8kv';
			}
			console.log(`âœ… å¾ GeoLink ç›´æ¥å–å¾—é›»å£“ç­‰ç´š: VLevel=${vLevel} -> ${voltageLevel}`);
		} else {
			// æ–¹æ³•2: å¦‚æœ GeoLink æ²’æœ‰ VLevelï¼Œå˜—è©¦æŸ¥æ‰¾ç¯€é»
			const fromId = properties.FromID;
			const toId = properties.ToID;
			
			if (fromId || toId) {
				const fromNode = allDevicesData.find(device => 
					device.properties.ID == fromId || device.properties.ID === fromId
				);
				const toNode = allDevicesData.find(device => 
					device.properties.ID == toId || device.properties.ID === toId
				);
				
				console.log(`ğŸ” æŸ¥æ‰¾ç¯€é» - FromID: ${fromId}, ToID: ${toId}`);
				console.log(`ğŸ” æ‰¾åˆ°èµ·é»ç¯€é»:`, fromNode ? `ID=${fromNode.properties.ID}, VLevel=${fromNode.properties.VLevel}` : 'æœªæ‰¾åˆ°');
				console.log(`ğŸ” æ‰¾åˆ°çµ‚é»ç¯€é»:`, toNode ? `ID=${toNode.properties.ID}, VLevel=${toNode.properties.VLevel}` : 'æœªæ‰¾åˆ°');
				
				const referenceNode = fromNode || toNode;
				if (referenceNode && referenceNode.properties.VLevel) {
					const vLevel = parseInt(referenceNode.properties.VLevel);
					if (vLevel === 1) {
						voltageLevel = '11.4kv';
					} else if (vLevel === 2) {
						voltageLevel = '22.8kv';
					}
					console.log(`âœ… å¾ç¯€é»å–å¾—é›»å£“ç­‰ç´š: VLevel=${vLevel} -> ${voltageLevel}`);
				}
			}
		}
		
		// ğŸ”§ ä¿®æ­£ï¼šåˆ¤æ–·æ¶ç©º/åœ°ä¸‹ - æª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„å±¬æ€§åç¨±å’Œå€¼
		const ohug = properties.OHUG || properties.ohug || properties.Ohug || '';
		console.log(`ğŸ” OHUG åŸå§‹å€¼:`, ohug, `(é¡å‹: ${typeof ohug})`);
		
		let isUnderground = false;
		
		// è™•ç†ä¸åŒçš„è³‡æ–™é¡å‹å’Œå€¼
		if (typeof ohug === 'string') {
			isUnderground = (ohug === '1' || ohug.toLowerCase() === 'underground' || ohug.toLowerCase() === 'u');
		} else if (typeof ohug === 'number') {
			isUnderground = (ohug === 1);
		} else if (typeof ohug === 'boolean') {
			isUnderground = ohug;
		}
		
		console.log(`ğŸ” æ¶è¨­æ–¹å¼åˆ¤æ–·: OHUG=${ohug} -> ${isUnderground ? 'åœ°ä¸‹' : 'æ¶ç©º'}`);
		
		// ğŸ”§ ä¿®æ­£ï¼šåˆ¤æ–·ä¸»å¹¹ç·š/åˆ†æ­§ç·š - æª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„å±¬æ€§åç¨±å’Œå€¼
		const cabType = properties.CabType || properties.cabtype || properties.Cabtype || '';
		console.log(`ğŸ” CabType åŸå§‹å€¼:`, cabType, `(é¡å‹: ${typeof cabType})`);
		
		let isMainLine = false;
		
		// è™•ç†ä¸åŒçš„è³‡æ–™é¡å‹å’Œå€¼
		if (typeof cabType === 'string') {
			isMainLine = (cabType === '0' || cabType.toLowerCase() === 'main' || cabType.toLowerCase() === 'm');
		} else if (typeof cabType === 'number') {
			isMainLine = (cabType === 0);
		} else if (typeof cabType === 'boolean') {
			isMainLine = !cabType; // å‡è¨­ false ä»£è¡¨ä¸»å¹¹ç·š
		}
		
		console.log(`ğŸ” ç·šè·¯é¡å‹åˆ¤æ–·: CabType=${cabType} -> ${isMainLine ? 'ä¸»å¹¹ç·š' : 'åˆ†æ­§ç·š'}`);
		
		// çµ„åˆåˆ†é¡
		let category = '';
		
		if (voltageLevel === '22.8kv') {
			if (isMainLine) {
				category = isUnderground ? 'line_22_8kv_main_underground' : 'line_22_8kv_main_overhead';
			} else {
				category = isUnderground ? 'line_22_8kv_branch_underground' : 'line_22_8kv_branch_overhead';
			}
		} else if (voltageLevel === '11.4kv') {
			if (isMainLine) {
				category = isUnderground ? 'line_11_4kv_main_underground' : 'line_11_4kv_main_overhead';
			} else {
				category = isUnderground ? 'line_11_4kv_branch_underground' : 'line_11_4kv_branch_overhead';
			}
		} else {
			// æœªçŸ¥é›»å£“ç­‰ç´š
			category = isUnderground ? 'line_other_underground' : 'line_other_overhead';
		}
		
		console.log(`âœ… æœ€çµ‚åˆ†é¡çµæœ:`);
		console.log(`   - é›»å£“ç­‰ç´š: ${voltageLevel}`);
		console.log(`   - æ¶è¨­æ–¹å¼: ${isUnderground ? 'åœ°ä¸‹' : 'æ¶ç©º'}`);
		console.log(`   - ç·šè·¯é¡å‹: ${isMainLine ? 'ä¸»å¹¹ç·š' : 'åˆ†æ­§ç·š'}`);
		console.log(`   - æœ€çµ‚é¡åˆ¥: ${category}`);
		
		return category;
	}
	// è™•ç†å°é›» GeoNode - å®Œå…¨ä¿®æ­£ç‰ˆï¼ˆåƒè€ƒä½ çš„ Python ç¨‹å¼ï¼‰
	function processGeoNode(node, index) {
		console.log(`ğŸ” è™•ç† GeoNode ${index}:`, node);
		
		if (!node.type || node.type !== 'Feature') {
			console.warn(`GeoNode ${index} ä¸æ˜¯æœ‰æ•ˆçš„ Feature:`, node);
			return null;
		}
		
		const geometry = node.geometry;
		if (!geometry || geometry.type !== 'Point') {
			console.warn(`GeoNode ${index} ä¸æ˜¯é»å¹¾ä½•:`, node);
			return null;
		}
		
		// ğŸ”§ é‡è¦ä¿®æ­£ï¼šæ ¹æ“šä½ çš„ Python ç¨‹å¼ï¼Œproperties åœ¨ geometry.properties å…§éƒ¨
		const properties = geometry.properties || {};
		const coordinates = geometry.coordinates;
		
		console.log(`ğŸ” GeoNode ${index} å±¬æ€§å…§å®¹:`, properties);
		console.log(`ğŸ” GeoNode ${index} åº§æ¨™:`, coordinates);
		
		if (!coordinates || !Array.isArray(coordinates) || coordinates.length < 2) {
			console.warn(`GeoNode ${index} åº§æ¨™æ ¼å¼ç„¡æ•ˆ:`, coordinates);
			return null;
		}
		
		// ğŸ”§ é‡è¦ä¿®æ­£ï¼šä½ çš„è³‡æ–™ä¸­åº§æ¨™æ˜¯å­—ä¸²æ ¼å¼ï¼Œéœ€è¦è½‰æ›ç‚ºæ•¸å­—
		const lng = parseFloat(coordinates[0]);
		const lat = parseFloat(coordinates[1]);
		
		if (isNaN(lng) || isNaN(lat)) {
			console.warn(`GeoNode ${index} åº§æ¨™è½‰æ›å¤±æ•—:`, coordinates);
			return null;
		}
		
		// æª¢æŸ¥åº§æ¨™åˆç†æ€§ï¼ˆå°ç£ç¯„åœï¼‰
		if (lng < 118 || lng > 122 || lat < 21 || lat > 26) {
			console.warn(`GeoNode ${index} åº§æ¨™è¶…å‡ºå°ç£ç¯„åœ:`, [lng, lat]);
			// ä¸ç›´æ¥ return nullï¼Œç¹¼çºŒè™•ç†ï¼ˆå¯èƒ½æ˜¯æ¸¬è©¦è³‡æ–™ï¼‰
		}
		
		// ğŸ”§ æ¨™æº–åŒ–å±¬æ€§ - ç¢ºä¿æ‰€æœ‰å±¬æ€§éƒ½æ˜¯æ­£ç¢ºçš„è³‡æ–™é¡å‹
		const standardizedProps = {
			ID: properties.ID || properties.id || `temp_${index}`,
			Area: properties.Area || properties.area || '',
			Feeder: properties.Feeder || properties.feeder || '',
			Tpclid: properties.Tpclid || properties.tpclid || '',
			FSC: properties.FSC || properties.fsc || '',
			VLevel: properties.VLevel || properties.vlevel || '',
			CabType: properties.CabType || properties.cabtype || '',
			OHUG: properties.OHUG || properties.ohug || '',
			Tag: properties.Tag || properties.tag || '',
			Spec: properties.Spec || properties.spec || '',
			Length: properties.Length || properties.length || '',
			Location: properties.Location || properties.location || '',
			Type: properties.Type || properties.type || '',
			Name: properties.Name || properties.name || '',
			Visible: properties.Visible !== undefined ? properties.Visible : true,
			NO: properties.NO || false,
			Auto: properties.Auto || false,
			Fuse: properties.Fuse || false,
			Opposite: properties.Opposite || '',
			
			// å®¹é‡ç›¸é—œ
			Capacity: properties.Capacity || '',
			Capacities: properties.Capacities || '',
			Capacity1: properties.Capacity1 || '',
			Capacity2: properties.Capacity2 || '',
			Capacity3: properties.Capacity3 || '',
			
			// ç›¸åˆ¥ç›¸é—œ
			Group1: properties.Group1 || '',
			Phase1: properties.Phase1 || '',
			Phase2: properties.Phase2 || '',
			Phase3: properties.Phase3 || '',
			
			// ç‡ˆå…·é¡å‹
			LightType1: properties.LightType1 || '',
			LightType2: properties.LightType2 || '',
			LightType3: properties.LightType3 || '',
			SupplyType: properties.SupplyType || '',
			
			// è¿´è·¯è³‡è¨Š
			SrcLoop: properties.SrcLoop || null,
			DestLoop: properties.DestLoop || null
		};
		
		// ä¿ç•™åŸå§‹å±¬æ€§ï¼ˆä»¥é˜²æœ‰å…¶ä»–æœªçŸ¥å±¬æ€§ï¼‰
		Object.keys(properties).forEach(key => {
			if (!standardizedProps.hasOwnProperty(key)) {
				standardizedProps[key] = properties[key];
			}
		});
		
		// åˆ†é¡è¨­å‚™
		const category = categorizeNode(standardizedProps);
		
		console.log(`âœ… GeoNode ${index} è™•ç†æˆåŠŸ:`);
		console.log(`   - ID: ${standardizedProps.ID}`);
		console.log(`   - FSC: ${standardizedProps.FSC}`);
		console.log(`   - Area: ${standardizedProps.Area}`);
		console.log(`   - Feeder: ${standardizedProps.Feeder}`);
		console.log(`   - é¡åˆ¥: ${category}`);
		console.log(`   - åº§æ¨™: [${lng}, ${lat}]`);
		
		return {
			coordinates: [lng, lat],
			properties: standardizedProps,
			category: category,
			featureIndex: index,
			type: 'Point'
		};
	}

	// è™•ç†ç·šæ®µ Feature - æ–°å‡½æ•¸
	function processLineFeature(feature, index) {
		const geometry = feature.geometry;
		const properties = feature.properties || {};
		
		if (!geometry.coordinates || !Array.isArray(geometry.coordinates)) {
			console.warn(`ç·šæ®µ Feature ${index} ç¼ºå°‘æœ‰æ•ˆåº§æ¨™:`, feature);
			return null;
		}
		
		const coordinates = geometry.coordinates;
		
		// é©—è­‰ LineString åº§æ¨™æ ¼å¼
		if (coordinates.length < 2) {
			console.warn(`ç·šæ®µ Feature ${index} åº§æ¨™é»ä¸è¶³:`, coordinates);
			return null;
		}
		
		// è½‰æ›åº§æ¨™æ ¼å¼ä¸¦é©—è­‰
		const latLngs = [];
		for (let i = 0; i < coordinates.length; i++) {
			const coord = coordinates[i];
			if (!Array.isArray(coord) || coord.length < 2) {
				console.warn(`ç·šæ®µ Feature ${index} ç¬¬ ${i} å€‹åº§æ¨™ç„¡æ•ˆ:`, coord);
				continue;
			}
			
			// è™•ç†å­—ä¸²æ ¼å¼åº§æ¨™ - è½‰æ›ç‚ºæ•¸å­—
			const lng = parseFloat(coord[0]);
			const lat = parseFloat(coord[1]);
			
			if (isNaN(lng) || isNaN(lat)) {
				console.warn(`ç·šæ®µ Feature ${index} ç¬¬ ${i} å€‹åº§æ¨™æ•¸å€¼ç„¡æ•ˆ:`, coord);
				continue;
			}
			
			// æª¢æŸ¥åº§æ¨™åˆç†æ€§ï¼ˆå°ç£ç¯„åœï¼‰
			if (lng >= 118 && lng <= 122 && lat >= 21 && lat <= 26) {
				latLngs.push([lat, lng]);
			} else {
				console.warn(`ç·šæ®µ Feature ${index} ç¬¬ ${i} å€‹åº§æ¨™è¶…å‡ºå°ç£ç¯„åœ:`, [lng, lat]);
			}
		}
		
		if (latLngs.length < 2) {
			console.warn(`ç·šæ®µ Feature ${index} æœ‰æ•ˆåº§æ¨™é»ä¸è¶³:`, latLngs);
			return null;
		}
		
		// åˆ†é¡ç·šæ®µ
		const category = categorizeLineFeatureAdvanced(properties);
		
		console.log(`âœ… ç·šæ®µ Feature ${index} è™•ç†æˆåŠŸï¼Œåº§æ¨™é»æ•¸: ${latLngs.length}, é¡åˆ¥: ${category}`);
		
		return {
			coordinates: latLngs,
			properties: properties,
			category: category,
			featureIndex: index,
			type: 'LineString'
		};
	}

	// è™•ç†é» Feature - æ–°å‡½æ•¸
	function processPointFeature(feature, index) {
		const geometry = feature.geometry;
		const properties = feature.properties || {};
		
		if (!geometry.coordinates || !Array.isArray(geometry.coordinates)) {
			console.warn(`é» Feature ${index} ç¼ºå°‘æœ‰æ•ˆåº§æ¨™:`, feature);
			return null;
		}
		
		const coordinates = geometry.coordinates;
		
		if (coordinates.length < 2) {
			console.warn(`é» Feature ${index} åº§æ¨™æ ¼å¼ç„¡æ•ˆ:`, coordinates);
			return null;
		}
		
		// ç¢ºä¿åº§æ¨™æ˜¯æ•¸å­— - è™•ç†å­—ä¸²æ ¼å¼åº§æ¨™
		const lng = parseFloat(coordinates[0]);
		const lat = parseFloat(coordinates[1]);
		
		if (isNaN(lng) || isNaN(lat)) {
			console.warn(`é» Feature ${index} åº§æ¨™ç„¡æ•ˆ:`, coordinates);
			return null;
		}
		
		// æª¢æŸ¥åº§æ¨™åˆç†æ€§ï¼ˆå°ç£ç¯„åœï¼‰
		if (lng < 118 || lng > 122 || lat < 21 || lat > 26) {
			console.warn(`é» Feature ${index} åº§æ¨™è¶…å‡ºå°ç£ç¯„åœ:`, [lng, lat]);
			return null;
		}
		
		// åˆ†é¡è¨­å‚™
		const category = categorizeNode(properties);
		
		return {
			coordinates: [lng, lat],
			properties: properties,
			category: category,
			featureIndex: index,
			type: 'Point'
		};
	}

	// ç·šæ®µåˆ†é¡ - é‡å° Feature æ ¼å¼ï¼ˆé€²éšç‰ˆï¼‰
	function categorizeLineFeatureAdvanced(properties) {
		// åˆ¤æ–·é›»å£“ç­‰ç´šï¼ˆé€™è£¡éœ€è¦æ ¹æ“šå¯¦éš›è³‡æ–™èª¿æ•´ï¼‰
		const vlevel = properties.VLevel || properties.vlevel || '';
		let voltageLevel = 'unknown';
		
		if (vlevel) {
			const vLevel = parseInt(vlevel);
			if (vLevel === 1) {
				voltageLevel = '11.4kv';
			} else if (vLevel === 2) {
				voltageLevel = '22.8kv';
			}
		}
		
		// åˆ¤æ–·æ¶ç©º/åœ°ä¸‹
		const ohug = properties.OHUG || properties.ohug || '';
		const isUnderground = (ohug === '1' || ohug === 1);
		
		// åˆ¤æ–·ä¸»å¹¹ç·š/åˆ†æ­§ç·š
		const cabType = properties.CabType || properties.cabtype || '';
		const isMainLine = (cabType === '0' || cabType === 0);
		
		// çµ„åˆåˆ†é¡
		let category = '';
		
		if (voltageLevel === '22.8kv') {
			if (isMainLine) {
				category = isUnderground ? 'line_22_8kv_main_underground' : 'line_22_8kv_main_overhead';
			} else {
				category = isUnderground ? 'line_22_8kv_branch_underground' : 'line_22_8kv_branch_overhead';
			}
		} else if (voltageLevel === '11.4kv') {
			if (isMainLine) {
				category = isUnderground ? 'line_11_4kv_main_underground' : 'line_11_4kv_main_overhead';
			} else {
				category = isUnderground ? 'line_11_4kv_branch_underground' : 'line_11_4kv_branch_overhead';
			}
		} else {
			// æœªçŸ¥é›»å£“ç­‰ç´š
			category = isUnderground ? 'line_other_underground' : 'line_other_overhead';
		}
		
		return category;
	}
			
			// æå–é¥‹ç·šè³‡è¨Š - ä¿®æ­£ç‰ˆ
	function extractFeederInfo(firstNode, fileName) {
		let properties = {};
		
		// å°é›»æ ¼å¼
		if (firstNode.geometry && firstNode.geometry.properties) {
			properties = firstNode.geometry.properties;
		}
		// æ¨™æº– GeoJSON æ ¼å¼
		else if (firstNode.properties) {
			properties = firstNode.properties;
		}
		
		currentFeederInfo = {
			fileName: fileName,
			area: properties.Area || 'æœªçŸ¥',
			feeder: properties.Feeder || 'æœªçŸ¥',
			totalDevices: 0,
			totalLines: 0
		};
		
		console.log('ğŸ“Š é¥‹ç·šè³‡è¨Š:', currentFeederInfo);
	}
			
		   // é¡¯ç¤ºé¥‹ç·šè³‡è¨Š - æ”¹é€²ç‰ˆ
	function displayFeederInfo() {
		if (!currentFeederInfo) return;
		
		// æ›´æ–°çµ±è¨ˆæ•¸æ“š
		currentFeederInfo.totalDevices = allDevicesData.length;
		currentFeederInfo.totalLines = allLinesData.length;
		
		const infoContainer = document.getElementById('feederInfo');
		if (infoContainer) {
			infoContainer.innerHTML = `
				<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px; border-radius: 8px; margin-bottom: 10px;">
					<h3 style="margin: 0 0 8px 0; font-size: 16px;">ğŸ“Š ${currentFeederInfo.fileName}</h3>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
						<div>ğŸ¢ å€åŸŸ: ${currentFeederInfo.area}</div>
						<div>âš¡ é¥‹ç·š: ${currentFeederInfo.feeder}</div>
						<div>ğŸ“ è¨­å‚™: ${currentFeederInfo.totalDevices}</div>
						<div>ğŸ“ ç·šæ®µ: ${currentFeederInfo.totalLines}</div>
					</div>
				</div>
			`;
			infoContainer.style.display = 'block';
		}
	}
			
			// è¨­å‚™åˆ†é¡ - æ ¹æ“šå°é›» FSC ä»£ç¢¼ï¼ˆçºŒï¼‰
			  function categorizeNode(properties) {
				  const fsc = properties.FSC || properties.fsc || '';
				  const fscNum = parseInt(fsc);
				  
				  // æ ¹æ“šå°é›» FSC ä»£ç¢¼åˆ†é¡
				  switch (fscNum) {
					  case 106: return 'poles_106';      // é›»æ¡¿è¨­å‚™
					  case 108: return 'cable_heads';    // é›»çºœé ­
					  case 109: return 'pole_markers';   // é›»æ¡¿æ¨™ç¤º
					  case 110: return 'solar';          // å¤ªé™½èƒ½è¨­å‚™
					  case 114: return 'switches';       // é–‹é—œè¨­å‚™
					  case 115: return 'transformers';   // è®Šå£“å™¨
					  case 116: return 'poles_116';      // çµ‚ç«¯
					  case 120: return 'grounding';      // æ¥åœ°è¨­å‚™
					  case 131: return 'others_131';     // å…¶ä»–è¨­å‚™
					  default: return 'unknown';         // æœªçŸ¥è¨­å‚™
				  }
			  }
			  
			  // æ›´æ–°åœ–å±¤åˆ†é¡å®šç¾© - é‡å°ç·šè·¯å€éš”åŒ–
	function createLayerControls() {
    // å®šç¾©è¨­å‚™é¡åˆ¥ - æ ¹æ“šå°é›» FSC åˆ†é¡
    const categories = {
        // é»è¨­å‚™é¡åˆ¥
        'poles_106': { name: 'ğŸ”´ ç·šè·¯ç¯€é» (FSC:106)', color: '#e74c3c', count: 0, type: 'point' },
        'cable_heads': { name: 'ğŸŸ  è®Šé›»æ‰€ (FSC:108)', color: '#f39c12', count: 0, type: 'point' },
        'pole_markers': { name: 'ğŸŸ£ é›»æ¡¿æ¨™ç¤º (FSC:109)', color: '#9b59b6', count: 0, type: 'point' },
        'solar': { name: 'ğŸŸ¡ å¤ªé™½èƒ½è¨­å‚™ (FSC:110)', color: '#f1c40f', count: 0, type: 'point' },
        'switches': { name: 'ğŸŸ¢ é–‹é—œè¨­å‚™ (FSC:114)', color: '#27ae60', count: 0, type: 'point' },
        'transformers': { name: 'ğŸ”µ è®Šå£“å™¨ (FSC:115)', color: '#3498db', count: 0, type: 'point' },
        'poles_116': { name: 'ğŸŸ¤ çµ‚ç«¯ (FSC:116)', color: '#8b4513', count: 0, type: 'point' },
        'grounding': { name: 'âš« é›»æ¡¿è¨­å‚™ (FSC:120)', color: '#2c3e50', count: 0, type: 'point' },
        'others_131': { name: 'ğŸŸ£ å…¶ä»–è¨­å‚™ (FSC:131)', color: '#8e44ad', count: 0, type: 'point' },
        'unknown': { name: 'ğŸ”˜ æœªçŸ¥è¨­å‚™', color: '#95a5a6', count: 0, type: 'point' },
        
        // ç·šæ®µé¡åˆ¥ - æ ¹æ“šé›»å£“ç­‰ç´šã€æ¶ç©ºåœ°ä¸‹ã€ä¸»å¹¹åˆ†æ­§å€éš”
        'line_22_8kv_main_overhead': { name: 'ğŸ”´ 22.8kV ä¸»å¹¹ç·š (æ¶ç©º)', color: '#dc3545', count: 0, type: 'line', style: 'solid' },
        'line_22_8kv_main_underground': { name: 'ğŸ”´ 22.8kV ä¸»å¹¹ç·š (åœ°ä¸‹)', color: '#dc3545', count: 0, type: 'line', style: 'dashed' },
        'line_22_8kv_branch_overhead': { name: 'ğŸ”µ 22.8kV åˆ†æ­§ç·š (æ¶ç©º)', color: '#007bff', count: 0, type: 'line', style: 'solid' },
        'line_22_8kv_branch_underground': { name: 'ğŸ”µ 22.8kV åˆ†æ­§ç·š (åœ°ä¸‹)', color: '#007bff', count: 0, type: 'line', style: 'dashed' },
        'line_11_4kv_main_overhead': { name: 'ğŸŸ  11.4kV ä¸»å¹¹ç·š (æ¶ç©º)', color: '#fd7e14', count: 0, type: 'line', style: 'solid' },
        'line_11_4kv_main_underground': { name: 'ğŸŸ  11.4kV ä¸»å¹¹ç·š (åœ°ä¸‹)', color: '#fd7e14', count: 0, type: 'line', style: 'dashed' },
        'line_11_4kv_branch_overhead': { name: 'ğŸŸ¢ 11.4kV åˆ†æ­§ç·š (æ¶ç©º)', color: '#28a745', count: 0, type: 'line', style: 'solid' },
        'line_11_4kv_branch_underground': { name: 'ğŸŸ¢ 11.4kV åˆ†æ­§ç·š (åœ°ä¸‹)', color: '#28a745', count: 0, type: 'line', style: 'dashed' },
        'line_other_overhead': { name: 'âš« å…¶ä»–ç·šè·¯ (æ¶ç©º)', color: '#6c757d', count: 0, type: 'line', style: 'solid' },
        'line_other_underground': { name: 'âš« å…¶ä»–ç·šè·¯ (åœ°ä¸‹)', color: '#6c757d', count: 0, type: 'line', style: 'dashed' }
    };
    
    // å®šç¾©ä¸é è¨­é¡¯ç¤ºçš„é¡åˆ¥
    const initiallyHiddenCategories = [
        'poles_106', 
        'grounding',
        'poles_116',
        'pole_markers',
        'transformers',
        'unknown',
        'others_131',
        'line_22_8kv_branch_overhead',
        'line_22_8kv_branch_underground', 
        'line_11_4kv_branch_overhead',
        'line_11_4kv_branch_underground'
    ];
    
    // çµ±è¨ˆé»è¨­å‚™æ•¸é‡ä¸¦å»ºç«‹åœ–å±¤ç¾¤çµ„
    allDevicesData.forEach(device => {
        const category = device.category;
        if (categories[category]) {
            categories[category].count++;
        }
        
        if (!layerGroups[category]) {
            layerGroups[category] = L.layerGroup();
            
            // åªæœ‰ä¸åœ¨éš±è—æ¸…å–®çš„æ‰åŠ å…¥åœ°åœ–
            if (!initiallyHiddenCategories.includes(category)) {
                layerGroups[category].addTo(map);
            }
        }
        
        const marker = createMarker(device, categories[category].color);
        layerGroups[category].addLayer(marker);
    });

    // çµ±è¨ˆç·šæ®µæ•¸é‡ä¸¦å»ºç«‹åœ–å±¤ç¾¤çµ„
    allLinesData.forEach(line => {
        const category = line.category;
        if (categories[category]) {
            categories[category].count++;
        }
        
        if (!layerGroups[category]) {
            layerGroups[category] = L.layerGroup();
            
            if (!initiallyHiddenCategories.includes(category)) {
                layerGroups[category].addTo(map);
            }
        }
        
        const polyline = createPolylineAdvanced(line, categories[category]);
        layerGroups[category].addLayer(polyline);
        
        if (!initiallyHiddenCategories.includes(category)) {
            if (polyline.arrowMarkers && Array.isArray(polyline.arrowMarkers)) {
                polyline.arrowMarkers.forEach(marker => {
                    arrowLayerGroup.addLayer(marker);
                });
            }
        }
    });
    
    // æ›´æ–°åœ–å±¤è¨ˆæ•¸
    layerCounts = Object.keys(categories).reduce((acc, key) => {
        acc[key] = categories[key].count;
        return acc;
    }, {});
    
    // å»ºç«‹æ§åˆ¶ä»‹é¢
    const container = document.getElementById('layerControlsContainer');
    container.innerHTML = '';
    
    // ğŸ†• æ–°å¢å…¨é¸æ§åˆ¶å€åŸŸ
    const selectAllContainer = document.createElement('div');
    selectAllContainer.className = 'select-all-container';
	selectAllContainer.innerHTML = `
		<div class="select-all-section">
			<h4>ğŸ”§ æ‰¹æ¬¡æ§åˆ¶</h4>
			<div class="select-all-buttons">
				<button class="select-all-btn equipment" id="equipmentToggleBtn" onclick="toggleAllEquipment()">
					ğŸ“ å…¨é¸è¨­å‚™
				</button>
				<button class="select-all-btn lines" id="linesToggleBtn" onclick="toggleAllLines()">
					âš¡ å…¨é¸ç·šè·¯
				</button>
				<button class="select-all-btn deselect" onclick="deselectAll()">
					âŒ å…¨éƒ¨å–æ¶ˆ
				</button>
			</div>
		</div>
		<hr class="divider">
	`;
    container.appendChild(selectAllContainer);
    
    // å…ˆé¡¯ç¤ºé»è¨­å‚™
    const pointCategories = Object.keys(categories).filter(key => 
        categories[key].type === 'point' && categories[key].count > 0
    );
    if (pointCategories.length > 0) {
        const pointHeader = document.createElement('h4');
        pointHeader.textContent = 'ğŸ“ é»è¨­å‚™';
        pointHeader.style.cssText = 'margin: 10px 0 5px 0; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #ecf0f1; padding-bottom: 3px;';
        container.appendChild(pointHeader);
        
        pointCategories.forEach(categoryKey => {
            const category = categories[categoryKey];
            const layerItem = createLayerControlItem(categoryKey, category);
            container.appendChild(layerItem);
        });
    }
    
    // å†é¡¯ç¤ºç·šæ®µ
    const lineCategories = Object.keys(categories).filter(key => 
        categories[key].type === 'line' && categories[key].count > 0
    );
    if (lineCategories.length > 0) {
        const lineHeader = document.createElement('h4');
        lineHeader.textContent = 'ğŸ“ ç·šæ®µ';
        lineHeader.style.cssText = 'margin: 15px 0 5px 0; font-size: 14px; color: #2c3e50; border-bottom: 1px solid #ecf0f1; padding-bottom: 3px;';
        container.appendChild(lineHeader);
        
        lineCategories.forEach(categoryKey => {
            const category = categories[categoryKey];
            const layerItem = createLayerControlItem(categoryKey, category);
            container.appendChild(layerItem);
        });
    }
    
    // é¡¯ç¤ºçµ±è¨ˆæ‘˜è¦
    const totalPoints = pointCategories.reduce((sum, key) => sum + categories[key].count, 0);
    const totalLines = lineCategories.reduce((sum, key) => sum + categories[key].count, 0);
    
    const summaryDiv = document.createElement('div');
    summaryDiv.style.cssText = 'margin-top: 15px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 12px; color: #6c757d;';
    summaryDiv.innerHTML = `
        <strong>ğŸ“Š è³‡æ–™çµ±è¨ˆ</strong><br>
        é»è¨­å‚™: ${totalPoints} å€‹<br>
        ç·šæ®µ: ${totalLines} æ¢
    `;
    container.appendChild(summaryDiv);
}
			  
		// å»ºç«‹åœ–å±¤æ§åˆ¶é …ç›® - ä¿®æ”¹ç‰ˆ
		function createLayerControlItem(categoryKey, category) {
			// ğŸ”§ ä¿®æ”¹ï¼šæ“´å±•é è¨­éš±è—æ¸…å–®ï¼ŒåŒ…å«æ‰€æœ‰åˆ†æ­§ç·šæ®µ
			const initiallyHiddenCategories = [
				'poles_106', 
				'grounding',
				'poles_116',
				'pole_markers',
				'transformers',
				'unknown',
				'others_131',
				'line_22_8kv_branch_overhead',
				'line_22_8kv_branch_underground', 
				'line_11_4kv_branch_overhead',
				'line_11_4kv_branch_underground'
			];
			
			const isChecked = !initiallyHiddenCategories.includes(categoryKey);
			
			const layerItem = document.createElement('div');
			layerItem.className = 'layer-item';
			
			layerItem.innerHTML = `
				<input type="checkbox" id="layer_${categoryKey}" ${isChecked ? 'checked' : ''} onchange="toggleLayer('${categoryKey}')">
				<label for="layer_${categoryKey}">${category.name}</label>
				<span class="layer-count">${category.count}</span>
			`;
			
			return layerItem;
		}
		// ğŸ†• åˆ‡æ›è¨­å‚™é¡¯ç¤ºåŠŸèƒ½
function toggleAllEquipment() {
    const equipmentCategories = [
        'poles_106', 'cable_heads', 'pole_markers', 'solar', 
        'switches', 'transformers', 'poles_116', 'grounding', 
        'others_131', 'unknown'
    ];
    
    const btn = document.getElementById('equipmentToggleBtn');
    const isActive = btn.classList.contains('active');
    
    if (isActive) {
        // ç›®å‰æ˜¯å•Ÿç”¨ç‹€æ…‹ï¼ŒåŸ·è¡Œé—œé–‰
        equipmentCategories.forEach(category => {
            const checkbox = document.getElementById(`layer_${category}`);
            const layerGroup = layerGroups[category];
            
            if (checkbox && layerGroup && checkbox.checked) {
                checkbox.checked = false;
                map.removeLayer(layerGroup);
            }
        });
        
        // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
        btn.classList.remove('active');
        btn.innerHTML = 'ğŸ“ å…¨é¸è¨­å‚™';
        console.log('ğŸ“ å·²éš±è—æ‰€æœ‰è¨­å‚™åœ–å±¤');
        
    } else {
        // ç›®å‰æ˜¯é—œé–‰ç‹€æ…‹ï¼ŒåŸ·è¡Œé–‹å•Ÿ
        equipmentCategories.forEach(category => {
            const checkbox = document.getElementById(`layer_${category}`);
            const layerGroup = layerGroups[category];
            
            if (checkbox && layerGroup && !checkbox.checked) {
                checkbox.checked = true;
                map.addLayer(layerGroup);
            }
        });
        
        // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
        btn.classList.add('active');
        btn.innerHTML = 'ğŸ“ éš±è—è¨­å‚™';
        console.log('ğŸ“ å·²é¡¯ç¤ºæ‰€æœ‰è¨­å‚™åœ–å±¤');
    }
}

// ğŸ†• åˆ‡æ›ç·šè·¯é¡¯ç¤ºåŠŸèƒ½
function toggleAllLines() {
    const lineCategories = [
        'line_22_8kv_main_overhead', 'line_22_8kv_main_underground',
        'line_22_8kv_branch_overhead', 'line_22_8kv_branch_underground',
        'line_11_4kv_main_overhead', 'line_11_4kv_main_underground',
        'line_11_4kv_branch_overhead', 'line_11_4kv_branch_underground',
        'line_other_overhead', 'line_other_underground'
    ];
    
    const btn = document.getElementById('linesToggleBtn');
    const isActive = btn.classList.contains('active');
    
    if (isActive) {
        // ç›®å‰æ˜¯å•Ÿç”¨ç‹€æ…‹ï¼ŒåŸ·è¡Œé—œé–‰
        lineCategories.forEach(category => {
            const checkbox = document.getElementById(`layer_${category}`);
            const layerGroup = layerGroups[category];
            
            if (checkbox && layerGroup && checkbox.checked) {
                checkbox.checked = false;
                map.removeLayer(layerGroup);
                
                // éš±è—è©²åœ–å±¤çš„ç®­é ­
                layerGroup.eachLayer(layer => {
                    if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                        layer.arrowMarkers.forEach(marker => {
                            arrowLayerGroup.removeLayer(marker);
                        });
                    }
                });
            }
        });
        
        // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
        btn.classList.remove('active');
        btn.innerHTML = 'âš¡ å…¨é¸ç·šè·¯';
        console.log('âš¡ å·²éš±è—æ‰€æœ‰ç·šè·¯åœ–å±¤');
        
    } else {
        // ç›®å‰æ˜¯é—œé–‰ç‹€æ…‹ï¼ŒåŸ·è¡Œé–‹å•Ÿ
        lineCategories.forEach(category => {
            const checkbox = document.getElementById(`layer_${category}`);
            const layerGroup = layerGroups[category];
            
            if (checkbox && layerGroup && !checkbox.checked) {
                checkbox.checked = true;
                map.addLayer(layerGroup);
                
                // é¡¯ç¤ºè©²åœ–å±¤çš„ç®­é ­
                layerGroup.eachLayer(layer => {
                    if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                        layer.arrowMarkers.forEach(marker => {
                            arrowLayerGroup.addLayer(marker);
                        });
                    }
                });
            }
        });
        
        // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
        btn.classList.add('active');
        btn.innerHTML = 'âš¡ éš±è—ç·šè·¯';
        console.log('âš¡ å·²é¡¯ç¤ºæ‰€æœ‰ç·šè·¯åœ–å±¤');
    }
}

		// ğŸ†• å…¨é¸è¨­å‚™åŠŸèƒ½
function selectAllEquipment() {
    const equipmentCategories = [
        'poles_106', 'cable_heads', 'pole_markers', 'solar', 
        'switches', 'transformers', 'poles_116', 'grounding', 
        'others_131', 'unknown'
    ];
    
    equipmentCategories.forEach(category => {
        const checkbox = document.getElementById(`layer_${category}`);
        const layerGroup = layerGroups[category];
        
        if (checkbox && layerGroup && !checkbox.checked) {
            checkbox.checked = true;
            map.addLayer(layerGroup);
        }
    });
    
    console.log('ğŸ“ å·²å…¨é¸æ‰€æœ‰è¨­å‚™åœ–å±¤');
}

// ğŸ†• å…¨é¸ç·šè·¯åŠŸèƒ½
function selectAllLines() {
    const lineCategories = [
        'line_22_8kv_main_overhead', 'line_22_8kv_main_underground',
        'line_22_8kv_branch_overhead', 'line_22_8kv_branch_underground',
        'line_11_4kv_main_overhead', 'line_11_4kv_main_underground',
        'line_11_4kv_branch_overhead', 'line_11_4kv_branch_underground',
        'line_other_overhead', 'line_other_underground'
    ];
    
    lineCategories.forEach(category => {
        const checkbox = document.getElementById(`layer_${category}`);
        const layerGroup = layerGroups[category];
        
        if (checkbox && layerGroup && !checkbox.checked) {
            checkbox.checked = true;
            map.addLayer(layerGroup);
            
            // é¡¯ç¤ºè©²åœ–å±¤çš„ç®­é ­
            layerGroup.eachLayer(layer => {
                if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                    layer.arrowMarkers.forEach(marker => {
                        arrowLayerGroup.addLayer(marker);
                    });
                }
            });
        }
    });
    
    console.log('âš¡ å·²å…¨é¸æ‰€æœ‰ç·šè·¯åœ–å±¤');
}

// ğŸ”§ ä¿®æ”¹å…¨éƒ¨å–æ¶ˆåŠŸèƒ½ï¼ˆåŒæ™‚é‡ç½®æŒ‰éˆ•ç‹€æ…‹ï¼‰
function deselectAll() {
    Object.keys(layerGroups).forEach(category => {
        const checkbox = document.getElementById(`layer_${category}`);
        const layerGroup = layerGroups[category];
        
        if (checkbox && layerGroup && checkbox.checked) {
            checkbox.checked = false;
            map.removeLayer(layerGroup);
            
            // éš±è—è©²åœ–å±¤çš„ç®­é ­
            layerGroup.eachLayer(layer => {
                if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                    layer.arrowMarkers.forEach(marker => {
                        arrowLayerGroup.removeLayer(marker);
                    });
                }
            });
        }
    });
    
    // ğŸ†• é‡ç½®æŒ‰éˆ•ç‹€æ…‹
    const equipmentBtn = document.getElementById('equipmentToggleBtn');
    const linesBtn = document.getElementById('linesToggleBtn');
    
    if (equipmentBtn) {
        equipmentBtn.classList.remove('active');
        equipmentBtn.innerHTML = 'ğŸ“ å…¨é¸è¨­å‚™';
    }
    
    if (linesBtn) {
        linesBtn.classList.remove('active');
        linesBtn.innerHTML = 'âš¡ å…¨é¸ç·šè·¯';
    }
    
    console.log('âŒ å·²å–æ¶ˆæ‰€æœ‰åœ–å±¤ä¸¦é‡ç½®æŒ‰éˆ•ç‹€æ…‹');
}
			  
			  // å»ºç«‹é€²éšç·šæ®µ - æ”¯æ´å¯¦ç·šè™›ç·šå€éš” + é»é¸é«˜äº®
	// å»ºç«‹é€²éšç·šæ®µ - æ”¯æ´å¯¦ç·šè™›ç·šå€éš” + é»é¸é«˜äº® + ç®­é ­æ–¹å‘
	function createPolylineAdvanced(lineData, categoryInfo) {
		const coordinates = lineData.coordinates;
		const props = lineData.properties;
		
		// å»ºç«‹ç·šæ®µæ¨£å¼
		const lineStyle = {
			color: categoryInfo.color,
			weight: 4,
			opacity: 0.8,
			smoothFactor: 1
		};
		
		// æ ¹æ“šæ¨£å¼è¨­å®šå¯¦ç·šæˆ–è™›ç·š
		if (categoryInfo.style === 'dashed') {
			lineStyle.dashArray = '8,8';  // åœ°ä¸‹ç·šè·¯ç”¨è™›ç·š
		} else {
			lineStyle.dashArray = null;     // æ¶ç©ºç·šè·¯ç”¨å¯¦ç·š
		}
		
		const polyline = L.polyline(coordinates, lineStyle);
		
		// å„²å­˜åŸå§‹æ¨£å¼
		polyline.originalStyle = { ...lineStyle };
		
		// ğŸ”§ æ–°å¢ï¼šæ·»åŠ ç®­é ­æ¨™è¨˜
		const arrowMarkers = addArrowsToPolyline(polyline, categoryInfo.color);
		
		// åŠ å…¥é»é¸äº‹ä»¶ - é«˜äº®åŠŸèƒ½
		polyline.on('click', function(e) {
			// é‡ç½®ä¹‹å‰é¸ä¸­çš„ç·šæ®µ
			if (selectedLine && selectedLine !== polyline) {
				selectedLine.setStyle(selectedLine.originalStyle);
				// é‡ç½®ä¹‹å‰ç·šæ®µçš„ç®­é ­é¡è‰²
				if (selectedLine.arrowMarkers) {
					selectedLine.arrowMarkers.forEach(marker => {
						updateArrowColor(marker, selectedLine.originalStyle.color);
					});
				}
			}
			
			// è¨­å®šæ–°çš„é¸ä¸­ç·šæ®µ
			selectedLine = polyline;
			
			// æ‡‰ç”¨é«˜äº®æ¨£å¼
			const highlightStyle = {
				color: '#ffff00',  // é»ƒè‰²é«˜äº®
				weight: 6,
				opacity: 1.0,
				dashArray: lineStyle.dashArray  // ä¿æŒåŸæœ‰çš„å¯¦ç·š/è™›ç·šæ¨£å¼
			};
			
			polyline.setStyle(highlightStyle);
			
			// é«˜äº®ç®­é ­
			if (arrowMarkers) {
				arrowMarkers.forEach(marker => {
					updateArrowColor(marker, '#ffff00');
				});
			}
			
			// é˜»æ­¢äº‹ä»¶å†’æ³¡
			L.DomEvent.stopPropagation(e);
			
			console.log('ğŸ¯ ç·šæ®µå·²é«˜äº®:', props.FromID, '->', props.ToID);
		});
		
		// æ»‘é¼ ç§»å…¥æ•ˆæœ
		polyline.on('mouseover', function() {
			if (selectedLine !== polyline) {
				const hoverStyle = {
					...lineStyle,
					weight: lineStyle.weight + 1,
					opacity: 1.0
				};
				polyline.setStyle(hoverStyle);
			}
		});
		
		// æ»‘é¼ ç§»å‡ºæ•ˆæœ
		polyline.on('mouseout', function() {
			if (selectedLine !== polyline) {
				polyline.setStyle(lineStyle);
			}
		});
		
		// å„²å­˜ç®­é ­æ¨™è¨˜åƒè€ƒ
		polyline.arrowMarkers = arrowMarkers;
		
		// å»ºç«‹å½ˆå‡ºè¦–çª—å…§å®¹ï¼ˆä¿æŒåŸæœ‰åŠŸèƒ½ï¼‰
		let popupContent = '<div style="max-width: 320px; font-size: 13px;">';
		popupContent += `<h4 style="margin: 0 0 10px 0; color: ${categoryInfo.color}; font-size: 14px;">ğŸ”— ${categoryInfo.name}</h4>`;
		
		// é¡¯ç¤ºä¸»è¦å±¬æ€§
		const importantProps = [
			{ key: 'FromID', label: 'èµ·é»è¨­å‚™ID' },
			{ key: 'ToID', label: 'çµ‚é»è¨­å‚™ID' },
			{ key: 'FromLoop', label: 'èµ·é»è¿´è·¯' },
			{ key: 'ToLoop', label: 'çµ‚é»è¿´è·¯' },
			{ key: 'CabType', label: 'ç·šè·¯é¡å‹' },
			{ key: 'OHUG', label: 'æ¶è¨­æ–¹å¼' },
			{ key: 'Visible', label: 'å¯è¦‹æ€§' }
		];
		
		importantProps.forEach(prop => {
			if (props[prop.key] !== undefined && props[prop.key] !== '') {
				let value = props[prop.key];
				
				// ç‰¹æ®Šå€¼è½‰æ›
				if (prop.key === 'CabType') {
					if (value === '0' || value === 0) {
						value = 'ä¸»å¹¹ç·š';
					} else if (value === '1' || value === 1) {
						value = 'åˆ†æ­§ç·š';
					}
				} else if (prop.key === 'OHUG') {
					if (value === '0' || value === 0) {
						value = 'æ¶ç©º';
					} else if (value === '1' || value === 1) {
						value = 'åœ°ä¸‹';
					}
				} else if (prop.key === 'Visible') {
					value = value ? 'æ˜¯' : 'å¦';
				}
				
				popupContent += `<p style="margin: 3px 0;"><strong>${prop.label}:</strong> ${value}</p>`;
			}
		});
		
		// é¡¯ç¤ºç·šæ®µçµ±è¨ˆ
		const lineLength = calculateLineLength(coordinates);
		const pointCount = coordinates.length;
		
		popupContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #eee;">';
		popupContent += `<p style="margin: 3px 0;"><strong>ğŸ“ åº§æ¨™é»æ•¸:</strong> ${pointCount}</p>`;
		popupContent += `<p style="margin: 3px 0;"><strong>ğŸ“ è¨ˆç®—é•·åº¦:</strong> ${lineLength.toFixed(2)} å…¬å°º</p>`;
		popupContent += `<p style="margin: 3px 0;"><strong>â¡ï¸ é›»æµæ–¹å‘:</strong> ${props.FromID} â†’ ${props.ToID}</p>`;
		
		// é¡¯ç¤ºèµ·çµ‚é»åº§æ¨™
		if (coordinates.length > 0) {
			const startPoint = coordinates[0];
			const endPoint = coordinates[coordinates.length - 1];
			popupContent += `<p style="margin: 3px 0; font-size: 11px; color: #666;"><strong>èµ·é»:</strong> ${startPoint[0].toFixed(6)}, ${startPoint[1].toFixed(6)}</p>`;
			popupContent += `<p style="margin: 3px 0; font-size: 11px; color: #666;"><strong>çµ‚é»:</strong> ${endPoint[0].toFixed(6)}, ${endPoint[1].toFixed(6)}</p>`;
		}
		
		popupContent += '<hr style="margin: 5px 0; border: none; border-top: 1px solid #eee;">';
		popupContent += '</div>';
		
		polyline.bindPopup(popupContent);
		
		return polyline;
	}
	// ç‚ºç·šæ®µæ·»åŠ ç®­é ­æ¨™è¨˜ - æ•ˆèƒ½å„ªåŒ–ç‰ˆ
	// ç‚ºç·šæ®µæ·»åŠ ç®­é ­æ¨™è¨˜ - ä¿®æ­£ç‰ˆï¼ˆä¸ç›´æ¥é¡¯ç¤ºï¼‰
	function addArrowsToPolyline(polyline, color) {
		const coordinates = polyline.getLatLngs();
		const arrowMarkers = [];
		
		// ğŸ”§ æ•ˆèƒ½å„ªåŒ–ï¼šæ ¹æ“šåœ°åœ–ç¸®æ”¾ç­‰ç´šèª¿æ•´å¯†åº¦
		const currentZoom = map.getZoom();
		let arrowInterval;
		
		if (currentZoom >= 16) {
			arrowInterval = 25;
		} else if (currentZoom >= 14) {
			arrowInterval = 50;
		} else {
			arrowInterval = 100;
		}
		
		const totalLength = calculatePolylineLength(coordinates);
		const maxArrows = 10;
		const calculatedInterval = Math.max(arrowInterval, totalLength / maxArrows);
		
		let currentDistance = 0;
		let nextArrowDistance = calculatedInterval / 2;
		let arrowCount = 0;
		
		for (let i = 1; i < coordinates.length && arrowCount < maxArrows; i++) {
			const segmentLength = coordinates[i-1].distanceTo(coordinates[i]);
			
			while (currentDistance + segmentLength >= nextArrowDistance && arrowCount < maxArrows) {
				const ratio = (nextArrowDistance - currentDistance) / segmentLength;
				const arrowPosition = interpolateLatLng(coordinates[i-1], coordinates[i], ratio);
				const bearing = calculateBearing(coordinates[i-1], coordinates[i]);
				
				const arrowMarker = createArrowMarkerOptimized(arrowPosition, bearing, color);
				arrowMarkers.push(arrowMarker);
				
				// ğŸ”§ ä¿®æ­£ï¼šä¸ç›´æ¥æ·»åŠ åˆ°åœ°åœ–ï¼Œåªå‰µå»ºç®­é ­ç‰©ä»¶
				// è®“ toggleLayer å‡½æ•¸ä¾†æ§åˆ¶æ˜¯å¦é¡¯ç¤º
				// arrowLayerGroup.addLayer(arrowMarker); // ç§»é™¤é€™è¡Œ
				
				nextArrowDistance += calculatedInterval;
				arrowCount++;
			}
			
			currentDistance += segmentLength;
		}
		
		return arrowMarkers;
	}
		// ğŸ”§ æ•ˆèƒ½å„ªåŒ–ç‰ˆç®­é ­å‰µå»º - æ”¾å¤§1.5å€
		function createArrowMarkerOptimized(position, bearing, color) {
			// ğŸ”§ ä¿®æ”¹ï¼šç®­é ­å°ºå¯¸æ”¾å¤§1.5å€ï¼ˆå¾ 3px/6px æ”¹ç‚º 4.5px/9pxï¼‰
			const arrowIcon = L.divIcon({
				html: `<div style="width:0;height:0;border-left:4.5px solid transparent;border-right:4.5px solid transparent;border-bottom:9px solid ${color};transform:rotate(${bearing}deg);"></div>`,
				className: 'arrow-icon',
				iconSize: [18, 18],        // ğŸ”§ å¾ [6, 6] æ”¹ç‚º [9, 9]
				iconAnchor: [9, 18]     // ğŸ”§ å¾ [3, 6] æ”¹ç‚º [4.5, 9]
			});
			
			// ğŸ”§ æ•ˆèƒ½å„ªåŒ–ï¼šç¦ç”¨ä¸å¿…è¦çš„äº’å‹•
			return L.marker(position, { 
				icon: arrowIcon,
				interactive: false  // ç¦ç”¨é»é¸äº‹ä»¶æå‡æ•ˆèƒ½
			});
		}
	// ğŸ”§ æ•ˆèƒ½å„ªåŒ–ç‰ˆç®­é ­å‰µå»º
	function createArrowMarkerOptimized(position, bearing, color) {
		// ç°¡åŒ–çš„ç®­é ­ HTML - æ¸›å°‘ DOM è¤‡é›œåº¦
		const arrowIcon = L.divIcon({
			html: `<div style="width:0;height:0;border-left:3px solid transparent;border-right:3px solid transparent;border-bottom:6px solid ${color};transform:rotate(${bearing}deg);"></div>`,
			className: 'arrow-icon',
			iconSize: [6, 6],
			iconAnchor: [3, 6]
		});
		
		// ğŸ”§ æ•ˆèƒ½å„ªåŒ–ï¼šç¦ç”¨ä¸å¿…è¦çš„äº’å‹•
		return L.marker(position, { 
			icon: arrowIcon,
			interactive: false  // ç¦ç”¨é»é¸äº‹ä»¶æå‡æ•ˆèƒ½
		});
	}
		 
	// è¨ˆç®—ç·šæ®µç¸½é•·åº¦ï¼ˆä½¿ç”¨ Leaflet çš„ distanceTo æ–¹æ³•ï¼‰
	function calculatePolylineLength(coordinates) {
		let totalLength = 0;
		for (let i = 1; i < coordinates.length; i++) {
			totalLength += coordinates[i-1].distanceTo(coordinates[i]);
		}
		return totalLength;
	}
			  
	// åœ¨å…©é»é–“æ’å€¼è¨ˆç®—ä½ç½®
	function interpolateLatLng(latlng1, latlng2, ratio) {
		const lat = latlng1.lat + (latlng2.lat - latlng1.lat) * ratio;
		const lng = latlng1.lng + (latlng2.lng - latlng1.lng) * ratio;
		return L.latLng(lat, lng);
	}

	// è¨ˆç®—å…©é»é–“çš„æ–¹ä½è§’
	function calculateBearing(latlng1, latlng2) {
		const lat1 = latlng1.lat * Math.PI / 180;
		const lat2 = latlng2.lat * Math.PI / 180;
		const deltaLng = (latlng2.lng - latlng1.lng) * Math.PI / 180;
		
		const x = Math.sin(deltaLng) * Math.cos(lat2);
		const y = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
		
		const bearing = Math.atan2(x, y) * 180 / Math.PI;
		return (bearing + 360) % 360; // ç¢ºä¿çµæœç‚ºæ­£å€¼
	}

	// å‰µå»ºç®­é ­æ¨™è¨˜
	function createArrowMarker(position, bearing, color) {
		const arrowIcon = L.divIcon({
			html: `<div class="arrow-marker" style="border-bottom-color: ${color}; transform: rotate(${bearing}deg);"></div>`,
			className: 'arrow-icon',
			iconSize: [8, 8],
			iconAnchor: [4, 8]
		});
		
		return L.marker(position, { icon: arrowIcon });
	}

	// æ›´æ–°ç®­é ­é¡è‰²
	function updateArrowColor(marker, color) {
		const iconElement = marker.getElement();
		if (iconElement) {
			const arrowDiv = iconElement.querySelector('.arrow-marker');
			if (arrowDiv) {
				arrowDiv.style.borderBottomColor = color;
			}
		}
	}
			  
			 // è¨ˆç®—ç·šæ®µé•·åº¦ - æ–°å‡½æ•¸
				function calculateLineLength(coordinates) {
					if (!coordinates || coordinates.length < 2) return 0;
					
					let totalLength = 0;
					for (let i = 1; i < coordinates.length; i++) {
						const lat1 = coordinates[i-1][0];
						const lng1 = coordinates[i-1][1];
						const lat2 = coordinates[i][0];
						const lng2 = coordinates[i][1];
						
						// ä½¿ç”¨ Haversine å…¬å¼è¨ˆç®—å…©é»é–“è·é›¢
						const distance = getDistanceFromLatLonInM(lat1, lng1, lat2, lng2);
						totalLength += distance;
					}
					
					return totalLength;
				}
	// Haversine å…¬å¼è¨ˆç®—å…©é»é–“è·é›¢ï¼ˆå…¬å°ºï¼‰
	function getDistanceFromLatLonInM(lat1, lon1, lat2, lon2) {
		const R = 6371000; // åœ°çƒåŠå¾‘ï¼ˆå…¬å°ºï¼‰
		const dLat = deg2rad(lat2 - lat1);
		const dLon = deg2rad(lon2 - lon1);
		const a = 
			Math.sin(dLat/2) * Math.sin(dLat/2) +
			Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
			Math.sin(dLon/2) * Math.sin(dLon/2);
		const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
		const d = R * c;
		return d;
	}
			  
		  function deg2rad(deg) {
		return deg * (Math.PI/180);
	}
			 // å»ºç«‹æ¨™è¨˜å½ˆå‡ºè¦–çª—å…§å®¹ - ç§»é™¤å‹•ç•«æ•ˆæœ
	// å»ºç«‹æ¨™è¨˜å½ˆå‡ºè¦–çª—å…§å®¹ - æ•ˆèƒ½å„ªåŒ–ç‰ˆï¼ˆåŠ å…¥ Opposite æ˜Ÿæ˜Ÿæª¢æŸ¥ï¼‰
	function createMarker(deviceData, color) {
    const coords = deviceData.coordinates;
    const props = deviceData.properties;
    
    // ğŸŒŸ æª¢æŸ¥æ˜¯å¦æœ‰ Opposite åƒæ•¸ä¸” FSC æ˜¯ 114
    const hasOpposite = props.FSC === '114' && props.Opposite && props.Opposite.trim() !== '';
    
    // æ ¹æ“š FSC å»ºç«‹ç°¡åŒ–åœ–æ¨™ï¼ˆä¿ç•™ä½ çš„åŸå§‹è¨­è¨ˆï¼‰
    const iconConfig = getSimpleDeviceIcon(props);
    
    // æ ¹æ“š FSC å‹•æ…‹èª¿æ•´åœ–æ¨™å¤§å°
    let iconSize = [16, 16];
    let iconAnchor = [8, 8];

    if (props.FSC === '114') {
        iconSize = [24, 24];
        iconAnchor = [12, 12];
    }

    const customIcon = L.divIcon({
        html: iconConfig.html,
        className: 'simple-device-icon',
        iconSize: iconSize,
        iconAnchor: iconAnchor
    });
    
    const marker = L.marker([coords[1], coords[0]], { icon: customIcon });
    
    // ğŸŒŸ å¦‚æœæ˜¯ FSC 114 ä¸”æœ‰ Opposite åƒæ•¸ï¼Œå‰µå»ºç´…è‰²æ˜Ÿæ˜Ÿæ¨™è¨˜
    if (hasOpposite) {
        console.log(`â­ ç™¼ç¾ FSC 114 è¨­å‚™æœ‰ Opposite åƒæ•¸: ID=${props.ID}, Opposite=${props.Opposite}`);
        createOppositeStarMarker([coords[1], coords[0]], props.Opposite);
    }
    
    // ğŸ†• å»ºç«‹å¢å¼·ç‰ˆå½ˆå‡ºè¦–çª—å…§å®¹ï¼ˆçµåˆåŸå§‹å…§å®¹ + Google åŠŸèƒ½ï¼‰
    let popupContent = '<div style="max-width: 320px; font-size: 13px; font-family: Arial, sans-serif;">';
    
    // ğŸ¨ æ¨™é¡Œå€åŸŸï¼ˆä¿ç•™ä½ çš„åŸå§‹è¨­è¨ˆï¼‰
    popupContent += `<div style="background: linear-gradient(135deg, ${color}, ${adjustColor(color, -20)}); color: white; padding: 12px; margin: -10px -10px 15px -10px; border-radius: 8px 8px 0 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">`;
    popupContent += `<h3 style="margin: 0; font-size: 16px; font-weight: bold;">ğŸ—ï¸ ${getDeviceTypeName(props.FSC)}</h3>`;
    popupContent += `<div style="font-size: 12px; opacity: 0.9; margin-top: 4px;">è¨­å‚™ID: ${props.ID || 'N/A'}</div>`;
    popupContent += `</div>`;
    
    popupContent += `<div style="padding: 0 5px;">`;
    
    // ğŸŒŸ Opposite è³‡è¨Šé¡¯ç¤ºï¼ˆä¿ç•™ä½ çš„åŸå§‹è¨­è¨ˆï¼‰
    if (hasOpposite) {
        popupContent += `<div style="background: #ffebee; border: 1px solid #f44336; border-radius: 4px; padding: 8px; margin-bottom: 10px;">`;
        popupContent += `<p style="margin: 0; font-weight: bold; color: #c62828;"><span style="color: #ff0000;">â­</span> Opposite: ${props.Opposite}</p>`;
        popupContent += `</div>`;
    }
    
    // ğŸ“Š ä¸»è¦å±¬æ€§é¡¯ç¤ºï¼ˆä¿ç•™ä½ çš„åŸå§‹é‚è¼¯ï¼‰
    const importantProps = [
        { key: 'ID', label: 'è¨­å‚™ID' },
        { key: 'Tpclid', label: 'å°é›»ID' },
        { key: 'FSC', label: 'FSCä»£ç¢¼' },
        { key: 'Area', label: 'å€åŸŸ' },
        { key: 'Feeder', label: 'é¥‹ç·š' },
        { key: 'VLevel', label: 'é›»å£“ç­‰ç´š' },
        { key: 'Location', label: 'ä½ç½®' },
        { key: 'Spec', label: 'è¦æ ¼' },
        { key: 'Length', label: 'é•·åº¦' },
        { key: 'Type', label: 'é¡å‹' },
        { key: 'Phase1', label: 'ç›¸åˆ¥1' },
        { key: 'Phase2', label: 'ç›¸åˆ¥2' },
        { key: 'Phase3', label: 'ç›¸åˆ¥3' },
        { key: 'Capacity1', label: 'å®¹é‡1' },
        { key: 'Capacity2', label: 'å®¹é‡2' },
        { key: 'Capacity3', label: 'å®¹é‡3' },
        { key: 'SupplyType', label: 'ä¾›é›»å‹å¼' }
    ];
    
    // é¡¯ç¤ºé‡è¦å±¬æ€§ï¼ˆä¿ç•™ä½ çš„åŸå§‹è™•ç†é‚è¼¯ï¼‰
    const displayedProps = [];
    importantProps.forEach(prop => {
        if (props[prop.key] !== undefined && props[prop.key] !== '' && props[prop.key] !== '0.0') {
            let value = props[prop.key];
            
            // ç‰¹æ®Šå€¼è™•ç†ï¼ˆä¿ç•™ä½ çš„åŸå§‹é‚è¼¯ï¼‰
            if (prop.key === 'VLevel') {
                if (value === '1') value = '11.4kV';
                else if (value === '2') value = '22.8kV';
                else if (value === '3') value = 'ç‰¹é«˜å£“';
            } else if (prop.key.includes('Capacity') && value !== '0.0') {
                value += ' kVA';
            } else if (prop.key === 'Length' && value !== '0.0') {
                value += ' å…¬å°º';
            }
            
            displayedProps.push({ label: prop.label, value: value });
        }
    });
    
    // ç”¨ç¶²æ ¼é¡¯ç¤ºå±¬æ€§
    if (displayedProps.length > 0) {
        popupContent += `<div style="display: grid; grid-template-columns: auto 1fr; gap: 6px 12px; margin-bottom: 12px; font-size: 12px;">`;
        displayedProps.forEach(prop => {
            popupContent += `<strong>${prop.label}:</strong><span>${prop.value}</span>`;
        });
        popupContent += `</div>`;
    }
    
    // ğŸ“ åº§æ¨™é¡¯ç¤ºï¼ˆä¿ç•™ä½ çš„åŸå§‹æ ¼å¼ï¼‰
    popupContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #eee;">';
    popupContent += `<p style="margin: 3px 0; font-size: 11px; color: #666;"><strong>ğŸ“ åº§æ¨™:</strong> ${coords[1].toFixed(6)}, ${coords[0].toFixed(6)}</p>`;
    
    // ğŸ”„ è¿´è·¯è³‡è¨Šé¡¯ç¤ºï¼ˆä¿ç•™ä½ çš„åŸå§‹é‚è¼¯ï¼‰
    if (props.SrcLoop || props.DestLoop) {
        popupContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #eee;">';
        popupContent += '<p style="margin: 5px 0 3px 0; font-weight: bold; color: #2c3e50;">ğŸ”„ è¿´è·¯è³‡è¨Š:</p>';
        
        if (props.SrcLoop && props.SrcLoop.Loop) {
            popupContent += `<p style="margin: 2px 0; font-size: 12px;">ä¾†æº: ${props.SrcLoop.Loop} (${props.SrcLoop.Name || ''})</p>`;
        }
        
        if (props.DestLoop && Array.isArray(props.DestLoop)) {
            props.DestLoop.forEach((dest, index) => {
                if (dest.Loop) {
                    popupContent += `<p style="margin: 2px 0; font-size: 12px;">ç›®æ¨™${index + 1}: ${dest.Loop} (${dest.Name || ''})</p>`;
                }
            });
        }
    }
    
    // ğŸ†• Google æœå‹™æŒ‰éˆ•å€åŸŸ
    const lat = coords[1];
    const lng = coords[0];
    const deviceName = props.Name || props.ID || 'è¨­å‚™ä½ç½®';
    
    popupContent += '<hr style="margin: 8px 0; border: none; border-top: 1px solid #eee;">';
    popupContent += `<div style="margin-top: 12px;">`;
    popupContent += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">`;
    
    // è¡—æ™¯åœ–æŒ‰éˆ•
    popupContent += `<button onclick="openStreetView(${lat}, ${lng})" 
                            style="background: linear-gradient(135deg, #4285f4, #34a853); 
                                   color: white; border: none; padding: 8px 6px; 
                                   border-radius: 6px; cursor: pointer; font-size: 11px; 
                                   font-weight: bold; transition: all 0.2s;
                                   box-shadow: 0 2px 4px rgba(66, 133, 244, 0.3);"
                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(66, 133, 244, 0.4)';"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(66, 133, 244, 0.3)';">
                        ğŸ—ºï¸ è¡—æ™¯åœ–
                    </button>`;
    
    // å°èˆªæŒ‰éˆ•
    popupContent += `<button onclick="openNavigation(${lat}, ${lng}, '${encodeURIComponent(deviceName)}')" 
                            style="background: linear-gradient(135deg, #ea4335, #fbbc04); 
                                   color: white; border: none; padding: 8px 6px; 
                                   border-radius: 6px; cursor: pointer; font-size: 11px; 
                                   font-weight: bold; transition: all 0.2s;
                                   box-shadow: 0 2px 4px rgba(234, 67, 53, 0.3);"
                            onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 8px rgba(234, 67, 53, 0.4)';"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(234, 67, 53, 0.3)';">
                        ğŸ§­ å°èˆª
                    </button>`;
    
    popupContent += `</div>`;
    
    // è¤‡è£½åº§æ¨™æŒ‰éˆ•
    popupContent += `<button onclick="copyCoordinates(${lat}, ${lng})" 
                            style="width: 100%; background: #6c757d; 
                                   color: white; border: none; padding: 6px; 
                                   border-radius: 4px; cursor: pointer; font-size: 10px;
                                   transition: all 0.2s;"
                            onmouseover="this.style.background='#5a6268';"
                            onmouseout="this.style.background='#6c757d';">
                        ğŸ“‹ è¤‡è£½åº§æ¨™
                    </button>`;
    
    popupContent += `</div>`;
    popupContent += `</div>`;
    popupContent += '</div>';
    
    marker.bindPopup(popupContent, {
        maxWidth: 350,
        className: 'custom-popup'
    });
    
    return marker;
}
// ğŸ†• é–‹å•Ÿ Google è¡—æ™¯åœ–
function openStreetView(lat, lng) {
    const streetViewUrl = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lat},${lng}`;
    window.open(streetViewUrl, '_blank');
    console.log(`ğŸ—ºï¸ é–‹å•Ÿè¡—æ™¯åœ–: ${lat}, ${lng}`);
}

// ğŸ†• é–‹å•Ÿ Google å°èˆª
function openNavigation(lat, lng, name) {
    // å˜—è©¦å¤šç¨®å°èˆªæ–¹å¼ï¼Œå„ªå…ˆä½¿ç”¨ Google Maps
    const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_place_id=${encodeURIComponent(name)}`;
    
    // æª¢æ¸¬æ˜¯å¦ç‚ºè¡Œå‹•è£ç½®
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (isMobile) {
        // è¡Œå‹•è£ç½®å„ªå…ˆå˜—è©¦é–‹å•Ÿ Google Maps App
        const appUrl = `google.navigation:q=${lat},${lng}`;
        const fallbackUrl = googleMapsUrl;
        
        // å˜—è©¦é–‹å•Ÿ Appï¼Œå¤±æ•—å‰‡é–‹å•Ÿç¶²é ç‰ˆ
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.src = appUrl;
        document.body.appendChild(iframe);
        
        setTimeout(() => {
            document.body.removeChild(iframe);
            window.open(fallbackUrl, '_blank');
        }, 1000);
    } else {
        // æ¡Œé¢ç‰ˆç›´æ¥é–‹å•Ÿç¶²é ç‰ˆ Google Maps
        window.open(googleMapsUrl, '_blank');
    }
    
    console.log(`ğŸ§­ é–‹å•Ÿå°èˆªè‡³: ${name} (${lat}, ${lng})`);
}

// ğŸ†• è¤‡è£½åº§æ¨™åˆ°å‰ªè²¼ç°¿
function copyCoordinates(lat, lng) {
    const coordinates = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
    
    if (navigator.clipboard && window.isSecureContext) {
        // ç¾ä»£ç€è¦½å™¨çš„å‰ªè²¼ç°¿ API
        navigator.clipboard.writeText(coordinates).then(() => {
            showToast(`ğŸ“‹ åº§æ¨™å·²è¤‡è£½: ${coordinates}`, 'success');
        }).catch(err => {
            console.error('è¤‡è£½å¤±æ•—:', err);
            fallbackCopyText(coordinates);
        });
    } else {
        // èˆŠç‰ˆç€è¦½å™¨çš„å‚™ç”¨æ–¹æ³•
        fallbackCopyText(coordinates);
    }
}

// ğŸ†• å‚™ç”¨è¤‡è£½æ–¹æ³•
function fallbackCopyText(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
        document.execCommand('copy');
        showToast(`ğŸ“‹ åº§æ¨™å·²è¤‡è£½: ${text}`, 'success');
    } catch (err) {
        console.error('è¤‡è£½å¤±æ•—:', err);
        showToast('âŒ è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½', 'error');
    }
    
    document.body.removeChild(textArea);
}

// ğŸ†• é¡¯ç¤ºæç¤ºè¨Šæ¯
function showToast(message, type = 'info') {
    // ç§»é™¤ç¾æœ‰çš„æç¤º
    const existingToast = document.getElementById('toast-message');
    if (existingToast) {
        existingToast.remove();
    }
    
    // å»ºç«‹æ–°æç¤º
    const toast = document.createElement('div');
    toast.id = 'toast-message';
    toast.textContent = message;
    
    const bgColor = type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#17a2b8';
    
    toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${bgColor};
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        z-index: 10000;
        font-size: 14px;
        font-weight: 500;
        max-width: 300px;
        word-wrap: break-word;
        animation: slideIn 0.3s ease-out;
    `;
    
    // åŠ å…¥æ»‘å…¥å‹•ç•«
    const style = document.createElement('style');
    style.textContent = `
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    `;
    document.head.appendChild(style);
    
    document.body.appendChild(toast);
    
    // 3ç§’å¾Œè‡ªå‹•ç§»é™¤
    setTimeout(() => {
        if (toast.parentNode) {
            toast.style.animation = 'slideIn 0.3s ease-out reverse';
            setTimeout(() => toast.remove(), 300);
        }
    }, 3000);
}

// ğŸ†• é¡è‰²èª¿æ•´è¼”åŠ©å‡½æ•¸
function adjustColor(color, percent) {
    const num = parseInt(color.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    
    return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
}

	// ğŸŒŸ ä¿®æ”¹ï¼šå‰µå»º Opposite ç´…è‰²æ˜Ÿæ˜Ÿæ¨™è¨˜ - èª¿æ•´å‚ç›´ä½ç½®é¿å…é®æ“‹é–‹é—œ
	function createOppositeStarMarker(position, oppositeText) {
		console.log(`â­ å‰µå»º Opposite ç´…è‰²æ˜Ÿæ˜Ÿæ¨™è¨˜: ${oppositeText} at`, position);
		
		const starIcon = L.divIcon({
			html: `
				<div class="opposite-star-marker">
					<div class="star-icon">â­</div>
					<div class="opposite-text">${oppositeText}</div>
				</div>
			`,
			className: 'opposite-star-icon',
			iconSize: [60, 25],   
			iconAnchor: [8, 35]   // ğŸ”§ ä¿®æ”¹ï¼šå¾ [8, 20] æ”¹ç‚º [8, 35]ï¼Œè®“æ˜Ÿæ˜Ÿå¾€ä¸Šåç§»æ›´å¤š
		});
		
		const starMarker = L.marker(position, { 
			icon: starIcon,
			zIndexOffset: 1000  // ç¢ºä¿æ˜Ÿæ˜Ÿé¡¯ç¤ºåœ¨æœ€ä¸Šå±¤
		});
		
		// åŠ å…¥åˆ°æ˜Ÿæ˜Ÿåœ–å±¤ç¾¤çµ„
		oppositeLayerGroup.addLayer(starMarker);
		
		// åŠ å…¥åˆ°å…¨åŸŸæ˜Ÿæ˜Ÿé™£åˆ—
		oppositeStarMarkers.push(starMarker);
		
		// åŠ å…¥é»é¸äº‹ä»¶é¡¯ç¤ºè©³ç´°è³‡è¨Š
		starMarker.on('click', function(e) {
			const popup = L.popup()
				.setLatLng(position)
				.setContent(`
					<div style="text-align: center; padding: 5px;">
						<h4 style="margin: 0 0 5px 0; color: #ff0000;">â­ Opposite æ¨™è¨˜</h4>
						<p style="margin: 0; font-weight: bold; color: #c62828;">${oppositeText}</p>
						<p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">FSC 114 é–‹é—œè¨­å‚™</p>
					</div>
				`)
				.openOn(map);
			
			// é˜»æ­¢äº‹ä»¶å†’æ³¡
			L.DomEvent.stopPropagation(e);
		});
		
		return starMarker;
	}
	// ç°¡åŒ–è¨­å‚™åœ–æ¨™ - æ•ˆèƒ½å„ªåŒ–ç‰ˆ
	function getSimpleDeviceIcon(props) {
		const fsc = props.FSC || props.fsc || '';
		const baseStyle = `
			width: 12px; 
			height: 12px; 
			display: flex; 
			align-items: center; 
			justify-content: center; 
			font-size: 8px; 
			font-weight: bold;
			border: 1px solid white;
			box-shadow: 0 1px 2px rgba(0,0,0,0.3);
		`;
		
		switch (fsc) {
			case '120': // æ¥åœ°è¨­å‚™ - åœ“åœˆ + 45åº¦æ–œç·š
				return {
					html: `<div style="${baseStyle} 
						background-color: #2c3e50; 
						border-radius: 50%;
						position: relative;
					">
						<div style="
							position: absolute;
							width: 10px;
							height: 1px;
							background-color: white;
							transform: rotate(45deg);
							top: 50%;
							left: 50%;
							margin-left: -5px;
							margin-top: -0.5px;
						"></div>
					</div>`
				};
				
			case '114': // é–‹é—œè¨­å‚™ - ğŸ”§ èª¿æ•´åœˆåœˆå¤§å°
				const switchType = getSwitchType(props);
				return {
					html: `<div style="
						width: 20px; 
						height: 20px; 
						display: flex; 
						align-items: center; 
						justify-content: center; 
						font-size: 12px; 
						font-weight: bold;
						border: 2px solid white;
						box-shadow: 0 2px 4px rgba(0,0,0,0.4);
						background-color: #27ae60; 
						border-radius: 50%;
						color: white;
					">${switchType}</div>`
				};

				
			case '115': // è®Šå£“å™¨ - ä¸‰è§’å½¢ (æ”¾å¤§1.5å€)
				return {
					html: `<div style="
						width: 0;
						height: 0;
						border-left: 9px solid transparent;
						border-right: 9px solid transparent;
						border-bottom: 15px solid #3498db;
						filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
					"></div>`
				};

				
			case '106': // é›»æ¡¿è¨­å‚™ - æ·±ç°è‰²å°åœ“é»
				return {
					html: `<div style="
						width: 6px; 
						height: 6px; 
						background-color: #34495e; 
						border-radius: 50%;
						border: 1px solid white;
						box-shadow: 0 1px 2px rgba(0,0,0,0.3);
					"></div>`
				};

			case '108': // é›»çºœé ­ - å¤§æ–¹å½¢ + "è®Š"å­—
				return {
					html: `<div style="
						width: 20px; 
						height: 20px; 
						background-color: #f39c12; 
						border-radius: 3px;
						border: 2px solid white;
						box-shadow: 0 2px 4px rgba(0,0,0,0.4);
						display: flex;
						align-items: center;
						justify-content: center;
						font-size: 12px;
						font-weight: bold;
						color: white;
						text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
					">è®Š</div>`
				};

				
			case '109': // é›»æ¡¿æ¨™ç¤º - è±å½¢
				return {
					html: `<div style="
						width: 8px;
						height: 8px;
						background-color: #9b59b6;
						transform: rotate(45deg);
						border: 1px solid white;
						box-shadow: 0 1px 2px rgba(0,0,0,0.3);
					"></div>`
				};
				
			case '110': // å¤ªé™½èƒ½è¨­å‚™ - æ–œæ”¾å¤ªé™½èƒ½æ¿
				return {
					html: `<div style="
						width: 12px;
						height: 8px;
						background: linear-gradient(135deg, #3498db 0%, #2980b9 50%, #1f4e79 100%);
						transform: rotate(-15deg) skewX(-10deg);
						border: 1px solid white;
						box-shadow: 0 1px 2px rgba(0,0,0,0.3);
						position: relative;
					">
						<div style="
							position: absolute;
							top: 1px;
							left: 1px;
							right: 1px;
							height: 1px;
							background-color: rgba(255,255,255,0.4);
						"></div>
						<div style="
							position: absolute;
							top: 4px;
							left: 1px;
							right: 1px;
							height: 1px;
							background-color: rgba(255,255,255,0.2);
						"></div>
					</div>`
				};

				
			case '116': // é›»æ¡¿è¨­å‚™ - åœ“é»ï¼ˆä¸åŒé¡è‰²ï¼‰
				return {
					html: `<div style="${baseStyle} 
						background-color: #8b4513; 
						border-radius: 50%;
					"></div>`
				};
				
			case '131': // å…¶ä»–è¨­å‚™ - å…«è§’å½¢
				return {
					html: `<div style="
						width: 10px;
						height: 10px;
						background-color: #8e44ad;
						clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
						border: 1px solid white;
						box-shadow: 0 1px 2px rgba(0,0,0,0.3);
					"></div>`
				};
				
			default: // æœªçŸ¥è¨­å‚™ - ç°¡å–®åœ“é»
				return {
					html: `<div style="${baseStyle} 
						background-color: #95a5a6; 
						border-radius: 50%;
					"></div>`
				};
		}
	}

	// ğŸ”§ ä¿®æ­£ï¼šåˆ¤æ–·é–‹é—œé¡å‹ - æ ¹æ“šè¨­å‚™å±¬æ€§è¿”å›æ­£ç¢ºè‹±æ–‡å­—æ¯
	function getSwitchType(props) {
		console.log('ğŸ” åˆ¤æ–·é–‹é—œé¡å‹ï¼Œè¨­å‚™å±¬æ€§:', props);
		
		// æ ¹æ“šè¨­å‚™å±¬æ€§åˆ¤æ–·é–‹é—œé¡å‹
		const auto = props.Auto;
		const fuse = props.Fuse;
		const no = props.NO;
		const type = props.Type || '';
		const spec = props.Spec || '';
		const swtype = props.SrcLoop ? props.SrcLoop.Type : undefined;
		
		console.log(`ğŸ” é–‹é—œå±¬æ€§åˆ†æ: Auto=${auto}, Fuse=${fuse}, NO=${no}, Type="${type}", Spec="${spec}"`);
		console.log(swtype);
		
		// ğŸ”§ ä¿®æ­£ï¼šåˆ¤æ–·é‚è¼¯ä¸¦è¿”å›å°æ‡‰è‹±æ–‡å­—æ¯
		if (fuse === true || fuse === '1' || fuse === 1 || type.includes('ç†”çµ²') || spec.includes('FUSE')) {
			console.log('âœ… åˆ¤æ–·ç‚ºç†”çµ² (F)');
			return 'F'; // ç†”çµ² (Fuse)
		} else if (auto === true || auto === '1' || auto === 1 || type.includes('è‡ªå‹•') || spec.includes('AUTO')) {
			console.log('âœ… åˆ¤æ–·ç‚ºè‡ªå‹•åŒ–é–‹é—œ (A)');
			return 'A'; // è‡ªå‹•åŒ–é–‹é—œ (Automatic)
		} else if (no === true || no === '1' || no === 1 || type.includes('åˆ†æ®µ') || spec.includes('SECT') || spec.includes('DISCONNECT') || swtype === 2 ||swtype ==='2') {
			console.log('âœ… åˆ¤æ–·ç‚ºåˆ†æ®µé–‹é—œ (D)');
			return 'D'; // åˆ†æ®µé–‹é—œ (Disconnector)
		} else if (type.includes('æ°£å°') || spec.includes('SECTIONALIZER') || spec.includes('æ°£å°')) {
			console.log('âœ… åˆ¤æ–·ç‚ºæ°£å°é–‹é—œ (S)');
			return 'S'; // æ°£å°é–‹é—œ (Sectionalizer)
		} else {
			console.log('âš ï¸ æœªçŸ¥é–‹é—œé¡å‹ï¼Œä½¿ç”¨é è¨­ (S)');
			return 'S'; // é è¨­ç‚ºæ°£å°é–‹é—œ (Switch/Sectionalizer)
		}
	}


	// å–å¾—è¨­å‚™åœ–æ¨™
	function getDeviceIcon(fsc) {
		const icons = {
			'106': 'ğŸ”Œ',  // ç·šè·¯ç¯€é»
			'108': 'ğŸ”—',  // è®Šé›»æ‰€
			'109': 'ğŸ·ï¸',  // é›»æ¡¿æ¨™ç¤º
			'110': 'â˜€ï¸',  // å¤ªé™½èƒ½è¨­å‚™
			'114': 'ğŸ”„',  // é–‹é—œè¨­å‚™
			'115': 'âš¡',  // è®Šå£“å™¨
			'116': 'ğŸ”Œ',  // çµ‚ç«¯
			'120': 'ğŸŒ',  // æ¥åœ°è¨­å‚™
			'131': 'â“'   // å…¶ä»–è¨­å‚™
		};
		return icons[fsc] || 'â—';
	}

	// å–å¾—è¨­å‚™é¡å‹åç¨±
	function getDeviceTypeName(fsc) {
		const names = {
			'106': 'ç·šè·¯ç¯€é»',
			'108': 'è®Šé›»æ‰€',
			'109': 'é›»æ¡¿æ¨™ç¤º',
			'110': 'å¤ªé™½èƒ½è¨­å‚™',
			'114': 'é–‹é—œè¨­å‚™',
			'115': 'è®Šå£“å™¨',
			'116': 'çµ‚ç«¯',
			'120': 'é›»æ¡¿è¨­å‚™',
			'131': 'å…¶ä»–è¨­å‚™'
		};
		return names[fsc] || 'æœªçŸ¥è¨­å‚™';
	}
			  
	function toggleLayer(categoryKey) {
    const checkbox = document.getElementById(`layer_${categoryKey}`);
    const layerGroup = layerGroups[categoryKey];
    
    if (!layerGroup) return;
    
    if (checkbox.checked) {
        map.addLayer(layerGroup);
        
        // ğŸ”§ ä¿®æ­£ï¼šé¡¯ç¤ºè©²åœ–å±¤ä¸­æ‰€æœ‰ç·šæ®µçš„ç®­é ­
        layerGroup.eachLayer(layer => {
            if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                layer.arrowMarkers.forEach(marker => {
                    arrowLayerGroup.addLayer(marker); // æ·»åŠ åˆ°ç®­é ­åœ–å±¤ç¾¤çµ„
                });
            }
        });
    } else {
        map.removeLayer(layerGroup);
        
        // ğŸ”§ ä¿®æ­£ï¼šéš±è—è©²åœ–å±¤ä¸­æ‰€æœ‰ç·šæ®µçš„ç®­é ­
        layerGroup.eachLayer(layer => {
            if (layer.arrowMarkers && Array.isArray(layer.arrowMarkers)) {
                layer.arrowMarkers.forEach(marker => {
                    arrowLayerGroup.removeLayer(marker); // å¾ç®­é ­åœ–å±¤ç¾¤çµ„ç§»é™¤
                });
            }
        });
    }
}
			  
			// æ¸…é™¤æ‰€æœ‰åœ–å±¤ - å®Œå…¨ä¿®æ”¹ç‰ˆï¼ˆåŠ å…¥æ˜Ÿæ˜Ÿæ¸…é™¤ï¼‰
			function clearAllLayers() {
				console.log('ğŸ§¹ é–‹å§‹æ¸…é™¤æ‰€æœ‰åœ–å±¤ã€ç®­é ­å’Œæ˜Ÿæ˜Ÿ...');
				
				// æ¸…é™¤ç¾æœ‰åœ–å±¤
				Object.values(layerGroups).forEach(layerGroup => {
					if (map.hasLayer(layerGroup)) {
						map.removeLayer(layerGroup);
					}
				});
				
				// ğŸ”§ é‡è¦ï¼šæ¸…é™¤æ‰€æœ‰ç®­é ­æ¨™è¨˜
				clearAllArrows();
				
				// ğŸŒŸ æ–°å¢ï¼šæ¸…é™¤æ‰€æœ‰æ˜Ÿæ˜Ÿæ¨™è¨˜
				clearAllOppositeStars();
				
				// é‡ç½®è®Šæ•¸
				layerGroups = {};
				selectedLine = null;
				
				console.log('âœ… æ‰€æœ‰åœ–å±¤ã€ç®­é ­å’Œæ˜Ÿæ˜Ÿå·²æ¸…é™¤');
			}
			
			// ğŸŒŸ æ–°å¢ï¼šå°ˆé–€æ¸…é™¤æ˜Ÿæ˜Ÿçš„å‡½æ•¸
	function clearAllOppositeStars() {
		console.log(`ğŸ§¹ æ¸…é™¤ ${oppositeStarMarkers.length} å€‹æ˜Ÿæ˜Ÿæ¨™è¨˜...`);
		
		// æ–¹æ³•1ï¼šå¾åœ–å±¤ç¾¤çµ„æ¸…é™¤ï¼ˆæ•ˆèƒ½è¼ƒå¥½ï¼‰
		if (oppositeLayerGroup) {
			oppositeLayerGroup.clearLayers();
		}
		
		// æ–¹æ³•2ï¼šé€ä¸€æ¸…é™¤ï¼ˆå‚™ç”¨æ–¹æ¡ˆï¼‰
		oppositeStarMarkers.forEach(marker => {
			if (map.hasLayer(marker)) {
				map.removeLayer(marker);
			}
		});
		
		// é‡ç½®æ˜Ÿæ˜Ÿé™£åˆ—
		oppositeStarMarkers = [];
		
		console.log('âœ… æ‰€æœ‰æ˜Ÿæ˜Ÿå·²æ¸…é™¤');
	}
			
			// ğŸ”§ æ–°å¢ï¼šå°ˆé–€æ¸…é™¤ç®­é ­çš„å‡½æ•¸
	function clearAllArrows() {
		console.log(`ğŸ§¹ æ¸…é™¤ ${allArrowMarkers.length} å€‹ç®­é ­æ¨™è¨˜...`);
		
		// æ–¹æ³•1ï¼šå¾åœ–å±¤ç¾¤çµ„æ¸…é™¤ï¼ˆæ•ˆèƒ½è¼ƒå¥½ï¼‰
		if (arrowLayerGroup) {
			arrowLayerGroup.clearLayers();
		}
		
		// æ–¹æ³•2ï¼šé€ä¸€æ¸…é™¤ï¼ˆå‚™ç”¨æ–¹æ¡ˆï¼‰
		allArrowMarkers.forEach(marker => {
			if (map.hasLayer(marker)) {
				map.removeLayer(marker);
			}
		});
		
		// é‡ç½®ç®­é ­é™£åˆ—
		allArrowMarkers = [];
		
		console.log('âœ… æ‰€æœ‰ç®­é ­å·²æ¸…é™¤');
	}
			  
			  // è‡ªå‹•ç¸®æ”¾åˆ°è³‡æ–™ç¯„åœ
			  function fitMapToData() {
				  const bounds = L.latLngBounds();
				  let hasData = false;
				  
				  // åŠ å…¥é»è¨­å‚™ç¯„åœ
				  allDevicesData.forEach(device => {
					  const [lng, lat] = device.coordinates;
					  bounds.extend([lat, lng]);
					  hasData = true;
				  });
				  
				  // åŠ å…¥ç·šæ®µç¯„åœ
				  allLinesData.forEach(line => {
					  line.coordinates.forEach(coord => {
						  bounds.extend(coord);
						  hasData = true;
					  });
				  });
				  
				  if (hasData) {
					  // åŠ å…¥ä¸€äº›é‚Šç•Œå¡«å……
					  map.fitBounds(bounds, { padding: [20, 20] });
				  }
			  }
			  
			  // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–åœ°åœ–
			  document.addEventListener('DOMContentLoaded', function() {
				  initMap();
			  });
			  
			  
// ğŸ†• ä¿®æ”¹å¾Œçš„åˆå§‹åŒ–ä¸‹æ‹‰é¸å–®å‡½æ•¸
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šåˆå§‹åŒ–ä¸‹æ‹‰é¸å–®å‡½æ•¸ - æ”¯æ´æ‰‹æ©Ÿç‰ˆé‡æ–°åˆå§‹åŒ–
function initializeFeederDropdown() {
    const dropdown = document.getElementById('feederDropdown');
    const inputField = document.getElementById('feederInput');
    
    if (!dropdown || !inputField) {
        console.warn('âš ï¸ æ‰¾ä¸åˆ°é¥‹ç·šä¸‹æ‹‰é¸å–®æˆ–è¼¸å…¥æ¡†');
        return;
    }
    
    // æ¸…ç©ºç¾æœ‰é¸é …
    dropdown.innerHTML = '<option value="">é¸æ“‡é¥‹ç·š</option>';
    
    // åŠ å…¥é¥‹ç·šé¸é …
    feederList.forEach(feeder => {
        const option = document.createElement('option');
        option.value = feeder;
        option.textContent = feeder;
        dropdown.appendChild(option);
    });
    
    // ğŸ”§ é‡è¦ï¼šç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆé¿å…é‡è¤‡ç¶å®šï¼‰
    dropdown.removeEventListener('change', handleDropdownChange);
    inputField.removeEventListener('input', handleInputChange);
    
    // ğŸ”§ é‡è¦ï¼šé‡æ–°ç¶å®šäº‹ä»¶ç›£è½å™¨
    dropdown.addEventListener('change', handleDropdownChange);
    inputField.addEventListener('input', handleInputChange);
    
    console.log(`âœ… ä¸‹æ‹‰é¸å–®å·²åˆå§‹åŒ–ï¼ŒåŒ…å« ${feederList.length} å€‹é¥‹ç·š`);
}

// ğŸ†• æ–°å¢ï¼šä¸‹æ‹‰é¸å–®è®ŠåŒ–è™•ç†å‡½æ•¸
function handleDropdownChange(event) {
    const selectedFeeder = event.target.value;
    const inputField = document.getElementById('feederInput');
    
    console.log('ğŸ“‹ ä¸‹æ‹‰é¸å–®é¸æ“‡:', selectedFeeder);
    
    if (selectedFeeder && inputField) {
        inputField.value = selectedFeeder;
        console.log('âœ… å·²åŒæ­¥åˆ°è¼¸å…¥æ¡†:', selectedFeeder);
        
        // ğŸ†• é¡¯ç¤ºæç¤º
        showToast(`å·²é¸æ“‡é¥‹ç·š: ${selectedFeeder}`, 'info');
    }
}

// ğŸ†• æ–°å¢ï¼šè¼¸å…¥æ¡†è®ŠåŒ–è™•ç†å‡½æ•¸
function handleInputChange(event) {
    const inputValue = event.target.value.toUpperCase();
    const dropdown = document.getElementById('feederDropdown');
    
    console.log('âŒ¨ï¸ è¼¸å…¥æ¡†è®ŠåŒ–:', inputValue);
    
    if (dropdown) {
        // åŒæ­¥ä¸‹æ‹‰é¸å–®é¸æ“‡
        dropdown.value = feederList.includes(inputValue) ? inputValue : '';
        console.log('âœ… å·²åŒæ­¥åˆ°ä¸‹æ‹‰é¸å–®');
    }
}
// ğŸ†• å¾é›²ç«¯è¼‰å…¥é¥‹ç·šè³‡æ–™
// ğŸ”§ ä¿®æ­£ï¼šå¾é›²ç«¯è¼‰å…¥é¥‹ç·šè³‡æ–™ - æ”¹å–„ UI åé¥‹
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šè¼‰å…¥å‡½æ•¸ä¸­åŠ å…¥æ›´å¥½çš„éŒ¯èª¤è™•ç†
async function loadFeederFromCloud() {
    const feederInput = document.getElementById('feederInput');
    const feederName = feederInput.value.trim().toUpperCase();
    const loadBtn = document.querySelector('.load-feeder-btn');
    const section = document.querySelector('.feeder-selection-section');
    
    if (!feederName) {
        showToast('è«‹è¼¸å…¥é¥‹ç·šåç¨±æˆ–å¾ä¸‹æ‹‰é¸å–®é¸æ“‡ï¼', 'error');
        feederInput.focus();
        return;
    }
    
    if (!feederList.includes(feederName)) {
        showToast(`æ‰¾ä¸åˆ°é¥‹ç·š "${feederName}"ï¼Œè«‹æª¢æŸ¥åç¨±æ˜¯å¦æ­£ç¢ºï¼`, 'error');
        feederInput.focus();
        return;
    }
    
    const fileName = `119_${feederName}.json`;
    
    try {
        // 1. æª¢æŸ¥æœ¬åœ°å„²å­˜
        let jsonData = localStorageManager.loadFromLocal(fileName);
        if (jsonData) {
            await processJsonDataAsync(jsonData, fileName);
            showToast('âš¡ ç¬é–“è¼‰å…¥ï¼(æœ¬åœ°)', 'success');
            return;
        }
        
        // 2. æª¢æŸ¥è¨˜æ†¶é«”å¿«å–
        jsonData = feederCache.get(fileName);
        if (jsonData) {
            await processJsonDataAsync(jsonData, fileName);
            showToast('âš¡ å¿«é€Ÿè¼‰å…¥ï¼(å¿«å–)', 'success');
            return;
        }
        
        // 3. å¾é›²ç«¯è¼‰å…¥
        loadBtn.disabled = true;
        loadBtn.textContent = 'âš¡ é¥‹ç·šè¼‰å…¥ä¸­...';
        section.classList.add('loading');
        
        const startTime = Date.now();
        updateProgress(0, 'æº–å‚™è¼‰å…¥...');
        
        // ğŸ”§ ä¿®æ­£ï¼šæª¢æŸ¥æª”æ¡ˆ ID æ˜¯å¦å­˜åœ¨
        let fileId;
        try {
            fileId = getFileIdByName(fileName);
        } catch (error) {
            throw new Error(`æ‰¾ä¸åˆ°æª”æ¡ˆ ${fileName}ï¼š${error.message}`);
        }
        
        const bestUrl = await getBestDownloadUrl(fileId);
        
        updateProgress(10, 'å»ºç«‹é€£ç·š...');
        
        // ğŸ”§ ä¿®æ­£ï¼šåŠ å…¥æ›´è©³ç´°çš„éŒ¯èª¤è™•ç†
        try {
            jsonData = await fastJsonLoader.loadJsonWithStream(bestUrl, (percent, text) => {
                updateProgress(10 + (percent * 0.7), text);
            });
        } catch (loadError) {
            console.error('è¼‰å…¥éŒ¯èª¤è©³æƒ…:', loadError);
            
            if (loadError.message.includes('HTML')) {
                throw new Error('Google Drive æª”æ¡ˆç„¡æ³•ç›´æ¥å­˜å–ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ¬Šé™è¨­å®š');
            } else if (loadError.message.includes('HTTP 404')) {
                throw new Error(`æª”æ¡ˆä¸å­˜åœ¨æˆ–å·²è¢«åˆªé™¤ï¼š${fileName}`);
            } else if (loadError.message.includes('HTTP 403')) {
                throw new Error(`æª”æ¡ˆå­˜å–æ¬Šé™ä¸è¶³ï¼š${fileName}`);
            } else {
                throw new Error(`è¼‰å…¥å¤±æ•—ï¼š${loadError.message}`);
            }
        }
        
        updateProgress(85, 'è™•ç†è³‡æ–™...');
        
        // 4. å„²å­˜åˆ°å¿«å–å’Œæœ¬åœ°
        feederCache.set(fileName, jsonData);
        await localStorageManager.saveToLocal(fileName, jsonData);
        
        updateProgress(95, 'æ¸²æŸ“åœ°åœ–...');
        
        // 5. è™•ç†è³‡æ–™
        await processJsonDataAsync(jsonData, fileName);
        
        updateProgress(100, 'è¼‰å…¥å®Œæˆï¼');
        
        const loadTime = ((Date.now() - startTime) / 1000).toFixed(2);
        console.log(`ğŸ‰ é¥‹ç·šè¼‰å…¥å®Œæˆ: ${loadTime}ç§’`);
        
        section.classList.add('success');
        showToast(`ğŸš€ è¼‰å…¥å®Œæˆï¼(${loadTime}ç§’)`, 'success');
        
        // èƒŒæ™¯é è¼‰å…¥
        setTimeout(() => preloadAdjacentFeeders(feederName), 1000);
        
    } catch (error) {
        console.error('âŒ é¥‹ç·šè¼‰å…¥å¤±æ•—:', error);
        section.classList.add('error');
        updateProgress(0, 'è¼‰å…¥å¤±æ•—');
        showToast(`è¼‰å…¥å¤±æ•—: ${error.message}`, 'error');
        
    } finally {
        loadBtn.disabled = false;
        loadBtn.textContent = 'âš¡ è¼‰å…¥é¥‹ç·š';
        section.classList.remove('loading');
        
        setTimeout(() => {
            section.classList.remove('success', 'error');
        }, 3000);
    }
}
// ğŸ†• æ™ºæ…§é è¼‰å…¥ç›¸é„°é¥‹ç·š
async function preloadAdjacentFeeders(currentFeeder) {
    console.log(`ğŸ”® é–‹å§‹é è¼‰å…¥ ${currentFeeder} çš„ç›¸é„°é¥‹ç·š...`);
    
    const adjacentFeeders = getAdjacentFeeders(currentFeeder);
    const maxPreload = 3;
    const feedersToPreload = adjacentFeeders.slice(0, maxPreload);
    
    console.log(`ğŸ“‹ é è¼‰å…¥æ¸…å–®: ${feedersToPreload.join(', ')}`);
    
    feedersToPreload.forEach(async (feeder, index) => {
        try {
            await new Promise(resolve => setTimeout(resolve, index * 1000));
            
            const fileName = `119_${feeder}.json`;
            
            if (feederCache.get(fileName)) {
                console.log(`âš¡ ${feeder} å·²åœ¨å¿«å–ä¸­ï¼Œè·³éé è¼‰å…¥`);
                return;
            }
            
            console.log(`ğŸ”® é è¼‰å…¥: ${feeder}`);
            const fileId = getFileIdByName(fileName);
            const bestUrl = await getBestDownloadUrl(fileId);
            const jsonData = await fastJsonLoader.loadJsonWithStream(bestUrl);
            feederCache.set(fileName, jsonData);
            console.log(`âœ… é è¼‰å…¥å®Œæˆ: ${feeder}`);
            
        } catch (error) {
            console.log(`âš ï¸ é è¼‰å…¥å¤±æ•—: ${feeder} -`, error.message);
        }
    });
}

// ğŸ†• å–å¾—ç›¸é„°é¥‹ç·š
function getAdjacentFeeders(currentFeeder) {
    const adjacent = [];
    
    const match = currentFeeder.match(/^(\d+[A-Z]+)(\d+)$/);
    if (!match) return adjacent;
    
    const prefix = match[1];
    const number = parseInt(match[2]);
    
    for (let offset = -2; offset <= 2; offset++) {
        if (offset === 0) continue;
        
        const adjacentNumber = number + offset;
        if (adjacentNumber < 1 || adjacentNumber > 99) continue;
        
        const adjacentFeeder = `${prefix}${adjacentNumber.toString().padStart(2, '0')}`;
        
        if (feederList.includes(adjacentFeeder)) {
            adjacent.push(adjacentFeeder);
        }
    }
    
    return adjacent;
}


// ğŸ†• æª”æ¡ˆåç¨±å°æ‡‰åˆ° Google Drive æª”æ¡ˆ ID
// ğŸ†• ä¿®æ”¹å¾Œçš„ getFileIdByName å‡½æ•¸
function getFileIdByName(fileName) {
    const fileId = feederDataMap[fileName];
    if (!fileId) {
        throw new Error(`æ‰¾ä¸åˆ°æª”æ¡ˆ ${fileName} çš„ Google Drive ID`);
    }
    return fileId;
}

// ğŸ†• å¾ Google Sheet JSON API è¼‰å…¥é¥‹ç·šè³‡æ–™
async function loadFeederDataFromSheet() {
    // ğŸ”§ æ›¿æ›ç‚ºæ‚¨çš„ GAS Web App URL
    const gasWebAppUrl = 'https://script.google.com/macros/s/AKfycby6Bx8OuXitOT-6vWxBcOUrvHgWGQIK_DO9F_Db-10uEwKPjw-Hqd8ka5MvTq3Hh68/exec';
    
    try {
        console.log('ğŸ”„ æ­£åœ¨å¾ JSON API è¼‰å…¥é¥‹ç·šè³‡æ–™...');
        
        const response = await fetch(`${gasWebAppUrl}?action=getFeederData&_t=${Date.now()}`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            feederDataMap = result.data.feederMap;
            feederList = result.data.feederList;
            
            console.log(`âœ… æˆåŠŸè¼‰å…¥ ${result.data.count} å€‹é¥‹ç·šè³‡æ–™`);
            console.log('ğŸ“‹ é¥‹ç·šæ¸…å–®:', feederList);
            console.log('ğŸ•’ æœ€å¾Œæ›´æ–°:', result.data.lastUpdate);
            
            // åˆå§‹åŒ–ä¸‹æ‹‰é¸å–®
            initializeFeederDropdown();
            
            // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
            updateLoadStatus(`âœ… å·²è¼‰å…¥ ${result.data.count} å€‹é¥‹ç·šè³‡æ–™ (${new Date(result.data.lastUpdate).toLocaleString('zh-TW')})`);
            
            return true;
        } else {
            throw new Error(result.error || 'è¼‰å…¥å¤±æ•—');
        }
        
    } catch (error) {
        console.error('âŒ è¼‰å…¥é¥‹ç·šè³‡æ–™å¤±æ•—:', error);
        
        // ğŸ”„ ä½¿ç”¨å‚™ç”¨çš„éœæ…‹æ¸…å–®
        console.log('ğŸ”„ ä½¿ç”¨å‚™ç”¨é¥‹ç·šæ¸…å–®...');
        feederList = [
            '6A22', '6A23', '6A24', '6A25', '6A31', '6A32', '6A33', '6A34', '6A35',
            '6A41', '6A42', '6A43', '6A44', '6A45', '6A51', '6A52', '6A53', '6A54'
            // ... å…¶ä»–é¥‹ç·šåç¨±
        ];
        
        // å»ºç«‹å‚™ç”¨çš„æª”æ¡ˆ ID å°æ‡‰è¡¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
        feederDataMap = {};
        feederList.forEach(feeder => {
            feederDataMap[`119_${feeder}.json`] = 'backup_file_id'; // é€™è£¡éœ€è¦å¯¦éš›çš„æª”æ¡ˆ ID
        });
        
        initializeFeederDropdown();
        updateLoadStatus(`âš ï¸ ä½¿ç”¨å‚™ç”¨æ¸…å–® (${feederList.length} å€‹é¥‹ç·š)`);
        
        return false;
    }
}
// ğŸ†• æ–°å¢ï¼šæª¢æŸ¥ API å¥åº·ç‹€æ…‹
async function checkAPIHealth() {
    const gasWebAppUrl = 'https://script.google.com/macros/s/æ‚¨çš„GAS_DEPLOYMENT_ID/exec';
    
    try {
        const response = await fetch(`${gasWebAppUrl}?action=health`);
        const result = await response.json();
        
        if (result.success) {
            console.log('âœ… API å¥åº·ç‹€æ…‹è‰¯å¥½:', result.data);
            return true;
        } else {
            console.warn('âš ï¸ API å¥åº·æª¢æŸ¥å¤±æ•—:', result.error);
            return false;
        }
    } catch (error) {
        console.error('âŒ API å¥åº·æª¢æŸ¥éŒ¯èª¤:', error);
        return false;
    }
}

// ğŸ†• å»ºç«‹é€²åº¦æ¢
function createProgressBar() {
    const progressHtml = `
        <div id="loadProgress" style="display: none; margin: 10px 0;">
            <div style="background: #e9ecef; border-radius: 10px; overflow: hidden; height: 8px;">
                <div id="progressBar" style="background: linear-gradient(90deg, #28a745, #20c997); 
                     height: 100%; width: 0%; transition: width 0.3s ease;"></div>
            </div>
            <div id="progressText" style="text-align: center; font-size: 12px; color: #666; margin-top: 4px;">
                è¼‰å…¥ä¸­...
            </div>
        </div>
    `;
    
    const section = document.querySelector('.feeder-selection-section');
    if (section && !document.getElementById('loadProgress')) {
        section.insertAdjacentHTML('beforeend', progressHtml);
    }
}

// ğŸ†• æ›´æ–°é€²åº¦
function updateProgress(percent, text) {
    const progressDiv = document.getElementById('loadProgress');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    
    if (progressDiv && progressBar && progressText) {
        progressDiv.style.display = 'block';
        progressBar.style.width = `${percent}%`;
        progressText.textContent = text;
        
        if (percent >= 100) {
            setTimeout(() => {
                progressDiv.style.display = 'none';
            }, 1000);
        }
    }
}
// ğŸ†• å–å¾—æœ€ä½³ä¸‹è¼‰ URL
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šå–å¾—æœ€ä½³ä¸‹è¼‰ URL
async function getBestDownloadUrl(fileId) {
    // ğŸ†• ä½¿ç”¨ GAS ä½œç‚ºä»£ç†ä¼ºæœå™¨
    const gasWebAppUrl = 'https://script.google.com/macros/s/AKfycby6Bx8OuXitOT-6vWxBcOUrvHgWGQIK_DO9F_Db-10uEwKPjw-Hqd8ka5MvTq3Hh68/exec';
    
    const proxyUrl = `${gasWebAppUrl}?action=getFileContent&fileId=${fileId}`;
    
    console.log(`ğŸ¯ ä½¿ç”¨ GAS ä»£ç†è¼‰å…¥: ${fileId}`);
    return proxyUrl;
}

// ğŸ†• éåŒæ­¥è™•ç† JSON è³‡æ–™
async function processJsonDataAsync(jsonData, fileName) {
    return new Promise((resolve) => {
        const processChunk = (deadline) => {
            const startTime = performance.now();
            
            try {
                processJsonData(jsonData, fileName);
                resolve();
            } catch (error) {
                if (performance.now() - startTime > 16) {
                    console.log('ğŸ”„ åˆ†å‰²è™•ç†å¤§å‹è³‡æ–™...');
                    setTimeout(() => processChunk({ timeRemaining: () => 50 }), 0);
                } else {
                    throw error;
                }
            }
        };
        
        if (window.requestIdleCallback) {
            requestIdleCallback(processChunk);
        } else {
            setTimeout(() => processChunk({ timeRemaining: () => 50 }), 0);
        }
    });
}
// ğŸ†• é è¼‰å…¥ç†±é–€é¥‹ç·š
async function preloadPopularFeeders() {
    const popularFeeders = ['6A22', '6A23', '6A24', '6A25'];
    
    console.log('ğŸ”¥ é è¼‰å…¥ç†±é–€é¥‹ç·š...');
    showToast('ğŸ”¥ é–‹å§‹é è¼‰å…¥ç†±é–€é¥‹ç·š...', 'info');
    
    let successful = 0;
    for (const feeder of popularFeeders) {
        try {
            const fileName = `119_${feeder}.json`;
            if (feederCache.get(fileName)) continue;
            
            const fileId = getFileIdByName(fileName);
            const bestUrl = await getBestDownloadUrl(fileId);
            const jsonData = await fastJsonLoader.loadJsonWithStream(bestUrl);
            feederCache.set(fileName, jsonData);
            successful++;
        } catch (error) {
            console.warn(`é è¼‰å…¥ ${feeder} å¤±æ•—:`, error);
        }
    }
    
    showToast(`ğŸ”¥ å·²é è¼‰å…¥ ${successful} å€‹ç†±é–€é¥‹ç·š`, 'success');
}

// ğŸ†• é¡¯ç¤ºå¿«å–ç‹€æ…‹
function showCacheStats() {
    const stats = feederCache.getStats();
    const localSize = localStorageManager.getStorageSize();
    
    const message = `ğŸ“Š å¿«å–ç‹€æ…‹å ±å‘Š\n\n` +
                   `è¨˜æ†¶é«”å¿«å–: ${stats.count} å€‹æª”æ¡ˆ\n` +
                   `å¿«å–å¤§å°: ${(stats.totalSize / 1024).toFixed(1)} KB\n` +
                   `æœ¬åœ°å„²å­˜: ${(localSize / 1024).toFixed(1)} KB\n\n` +
                   `å¿«å–æª”æ¡ˆ:\n${stats.items.join('\n')}`;
    
    alert(message);
}

// ğŸ†• å¿«å–ç®¡ç†ç³»çµ±
class FeederCache {
    constructor() {
        this.cache = new Map();
        this.maxCacheSize = 10;
        this.cacheExpiry = 30 * 60 * 1000; // 30åˆ†é˜éæœŸ
    }
    
    set(fileName, data) {
        const cacheData = {
            data: data,
            timestamp: Date.now(),
            size: JSON.stringify(data).length
        };
        
        if (this.cache.size >= this.maxCacheSize) {
            const oldestKey = this.cache.keys().next().value;
            this.cache.delete(oldestKey);
            console.log(`ğŸ—‘ï¸ ç§»é™¤èˆŠå¿«å–: ${oldestKey}`);
        }
        
        this.cache.set(fileName, cacheData);
        console.log(`ğŸ’¾ å¿«å–å·²å„²å­˜: ${fileName} (${(cacheData.size/1024).toFixed(1)}KB)`);
    }
    
    get(fileName) {
        const cached = this.cache.get(fileName);
        if (!cached) return null;
        
        if (Date.now() - cached.timestamp > this.cacheExpiry) {
            this.cache.delete(fileName);
            console.log(`â° å¿«å–å·²éæœŸ: ${fileName}`);
            return null;
        }
        
        console.log(`âš¡ ä½¿ç”¨å¿«å–: ${fileName}`);
        return cached.data;
    }
    
    clear() {
        this.cache.clear();
        console.log('ğŸ§¹ å·²æ¸…é™¤æ‰€æœ‰å¿«å–');
    }
    
    getStats() {
        const totalSize = Array.from(this.cache.values())
            .reduce((sum, item) => sum + item.size, 0);
        
        return {
            count: this.cache.size,
            totalSize: totalSize,
            items: Array.from(this.cache.keys())
        };
    }
}

// ğŸ†• é«˜æ•ˆ JSON è™•ç†é¡åˆ¥
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šé«˜æ•ˆ JSON è™•ç†é¡åˆ¥
class FastJsonLoader {
    constructor() {
        this.chunkSize = 1024 * 64;
        this.timeout = 10000;
    }
    
    async loadJsonWithStream(url, onProgress = null) {
        console.log('ğŸŒŠ å•Ÿå‹•è¼‰å…¥...');
        const startTime = Date.now();
        
        try {
            // ğŸ”§ æª¢æŸ¥æ˜¯å¦ç‚º GAS ä»£ç† URL
            if (url.includes('script.google.com')) {
                return await this.loadFromGASProxy(url, onProgress);
            } else {
                return await this.loadDirectly(url, onProgress);
            }
            
        } catch (error) {
            console.error('âŒ è¼‰å…¥å¤±æ•—:', error);
            throw error;
        }
    }
    
    // ğŸ†• å¾ GAS ä»£ç†è¼‰å…¥
    async loadFromGASProxy(url, onProgress = null) {
        console.log('ğŸ”„ ä½¿ç”¨ GAS ä»£ç†è¼‰å…¥...');
        
        if (onProgress) onProgress(10, 'é€£æ¥ GAS ä»£ç†...');
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        if (onProgress) onProgress(50, 'æ¥æ”¶è³‡æ–™...');
        
        const result = await response.json();
        
        if (onProgress) onProgress(80, 'è§£æè³‡æ–™...');
        
        if (!result.success) {
            throw new Error(result.error || 'è¼‰å…¥å¤±æ•—');
        }
        
        if (onProgress) onProgress(100, 'è¼‰å…¥å®Œæˆ');
        
        console.log(`âœ… GAS ä»£ç†è¼‰å…¥æˆåŠŸ: ${result.data.fileName}`);
        return result.data.data; // è¿”å›å¯¦éš›çš„ JSON è³‡æ–™
    }
    
    // ğŸ†• ç›´æ¥è¼‰å…¥ï¼ˆå‚™ç”¨æ–¹æ¡ˆï¼‰
    async loadDirectly(url, onProgress = null) {
        console.log('ğŸ”„ ç›´æ¥è¼‰å…¥...');
        
        const response = await fetch(url, {
            headers: {
                'Cache-Control': 'no-cache',
                'Accept': 'application/json'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const contentLength = response.headers.get('content-length');
        const total = contentLength ? parseInt(contentLength) : 0;
        let loaded = 0;
        
        const reader = response.body.getReader();
        const chunks = [];
        
        while (true) {
            const { done, value } = await reader.read();
            
            if (done) break;
            
            chunks.push(value);
            loaded += value.length;
            
            if (onProgress && total > 0) {
                const percent = Math.round((loaded / total) * 100);
                onProgress(percent, `è¼‰å…¥ä¸­... ${this.formatBytes(loaded)}/${this.formatBytes(total)}`);
            }
        }
        
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const combined = new Uint8Array(totalLength);
        let offset = 0;
        
        for (const chunk of chunks) {
            combined.set(chunk, offset);
            offset += chunk.length;
        }
        
        const text = new TextDecoder().decode(combined);
        
        // ğŸ”§ æª¢æŸ¥æ˜¯å¦ç‚º HTMLï¼ˆGoogle Drive ç™»å…¥é é¢ï¼‰
        if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
            throw new Error('æ”¶åˆ° HTML å›æ‡‰è€Œé JSON æª”æ¡ˆï¼Œå¯èƒ½éœ€è¦ç™»å…¥ Google Drive');
        }
        
        const jsonData = JSON.parse(text);
        
        const loadTime = ((Date.now() - Date.now()) / 1000).toFixed(2);
        console.log(`âš¡ ç›´æ¥è¼‰å…¥å®Œæˆ: ${loadTime}ç§’, å¤§å°: ${this.formatBytes(totalLength)}`);
        
        return jsonData;
    }
    
    formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }
}

// ğŸ†• æœ¬åœ°å„²å­˜ç®¡ç†
class LocalStorageManager {
    constructor() {
        this.prefix = 'feeder_';
        this.maxSize = 50 * 1024 * 1024; // 50MB é™åˆ¶
    }
    
    async saveToLocal(fileName, data) {
        try {
            const compressed = this.compressData(data);
            const key = this.prefix + fileName;
            
            if (this.getStorageSize() + compressed.length > this.maxSize) {
                this.cleanOldData();
            }
            
            localStorage.setItem(key, compressed);
            localStorage.setItem(key + '_timestamp', Date.now().toString());
            
            console.log(`ğŸ’¾ å·²å„²å­˜åˆ°æœ¬åœ°: ${fileName}`);
            
        } catch (error) {
            console.warn('âš ï¸ æœ¬åœ°å„²å­˜å¤±æ•—:', error);
        }
    }
    
    loadFromLocal(fileName) {
        try {
            const key = this.prefix + fileName;
            const compressed = localStorage.getItem(key);
            const timestamp = localStorage.getItem(key + '_timestamp');
            
            if (!compressed || !timestamp) return null;
            
            const age = Date.now() - parseInt(timestamp);
            if (age > 24 * 60 * 60 * 1000) {
                this.removeFromLocal(fileName);
                return null;
            }
            
            const data = this.decompressData(compressed);
            console.log(`ğŸ“± å¾æœ¬åœ°è¼‰å…¥: ${fileName}`);
            return data;
            
        } catch (error) {
            console.warn('âš ï¸ æœ¬åœ°è¼‰å…¥å¤±æ•—:', error);
            return null;
        }
    }
    
    compressData(data) {
        return JSON.stringify(data);
    }
    
    decompressData(compressed) {
        return JSON.parse(compressed);
    }
    
    getStorageSize() {
        let total = 0;
        for (let key in localStorage) {
            if (key.startsWith(this.prefix)) {
                total += localStorage[key].length;
            }
        }
        return total;
    }
    
    cleanOldData() {
        const items = [];
        for (let key in localStorage) {
            if (key.startsWith(this.prefix) && key.endsWith('_timestamp')) {
                const timestamp = parseInt(localStorage[key]);
                items.push({ key: key.replace('_timestamp', ''), timestamp });
            }
        }
        
        items.sort((a, b) => a.timestamp - b.timestamp);
        const toRemove = items.slice(0, Math.ceil(items.length / 3));
        
        toRemove.forEach(item => {
            localStorage.removeItem(item.key);
            localStorage.removeItem(item.key + '_timestamp');
        });
        
        console.log(`ğŸ§¹ æ¸…ç†äº† ${toRemove.length} å€‹èˆŠæª”æ¡ˆ`);
    }
    
    removeFromLocal(fileName) {
        const key = this.prefix + fileName;
        localStorage.removeItem(key);
        localStorage.removeItem(key + '_timestamp');
    }
}

// æ–°å¢ï¼šåœ°åœ–æ—‹è½‰ç›¸é—œè®Šæ•¸
let currentRotation = 0;
let orientationHandler = null;
let isFollowingHeading = false;
let headingWatchId = null;
let headingThreshold = 2; // æ–¹å‘è®ŠåŒ–é–¾å€¼ï¼ˆåº¦ï¼‰
// æ–°å¢ï¼šæ¸¬é‡å·¥å…·ç›¸é—œè®Šæ•¸
let measureDistanceMode = false;
let measureMarkers = [];
let measureLines = [];
// æ–°å¢ï¼šåœ°åœ–æ—‹è½‰åŠŸèƒ½
function rotateMap(degrees) {
    currentRotation = (currentRotation + degrees) % 360;
    if (currentRotation < 0) currentRotation += 360;
    
    if (map.setBearing) {
        map.setBearing(currentRotation);
    }
    
    updateRotationSlider();
    updateCompassDisplay(currentRotation);
}

function setMapRotation(degrees) {
    currentRotation = parseFloat(degrees);
    
    if (map.setBearing) {
        map.setBearing(currentRotation);
    }
    
    updateCompassDisplay(currentRotation);
}

function resetMapRotation() {
    if (map) {
        map.setBearing(0);
        updateCompassDisplay(0);
        showToast('ğŸ§­ åœ°åœ–æ–¹å‘å·²é‡ç½®', 'success');
    }
}

function updateRotationSlider() {
    const slider = document.getElementById('rotationSlider');
    if (slider) {
        slider.value = currentRotation;
    }
}

// ç›£è½åœ°åœ–æ–¹å‘è®ŠåŒ– (æ‰‹å‹•æ‹–æ‹½æ™‚)
map.on('rotate', function() {
    const bearing = map.getBearing();
    updateCompassDisplay(bearing);
});

// æ›´æ–°æŒ‡å—é‡é¡¯ç¤º
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šç¾…ç›¤é¡¯ç¤ºæ›´æ–°
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šæ›´æ–°æŒ‡åŒ—é‡é¡¯ç¤º
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šæ›´æ–°æŒ‡åŒ—é‡é¡¯ç¤º - ç¢ºä¿æ­£ç¢ºæ—‹è½‰
function updateCompassDisplay(heading) {
    const compassElement = document.getElementById('compass');
    if (!compassElement) return;
    
    // æ–¹å‘åç¨±å°æ‡‰
    const getDirectionName = (angle) => {
        const directions = ['åŒ—', 'åŒ—åŒ—æ±', 'æ±åŒ—', 'æ±åŒ—æ±', 'æ±', 'æ±å—æ±', 'æ±å—', 'å—å—æ±', 'å—', 'å—å—è¥¿', 'è¥¿å—', 'è¥¿å—è¥¿', 'è¥¿', 'è¥¿åŒ—è¥¿', 'è¥¿åŒ—', 'åŒ—åŒ—è¥¿'];
        const index = Math.round(angle / 22.5) % 16;
        return directions[index];
    };
    
    const directionName = getDirectionName(heading);
    const roundedHeading = Math.round(heading);
    
    // ğŸ”§ ä¿®æ­£ï¼šç¢ºä¿æŒ‡åŒ—é‡æ­£ç¢ºæ—‹è½‰
    compassElement.innerHTML = `
        <div style="background: rgba(0, 0, 0, 0.8); color: white; padding: 15px; border-radius: 12px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 120px;">
            <div style="position: relative; margin-bottom: 10px;">
                <svg width="80" height="80" viewBox="0 0 100 100" style="transform: rotate(${-heading}deg); transition: transform 0.5s ease;">
                    <circle cx="50" cy="50" r="45" fill="none" stroke="#444" stroke-width="2"/>
                    <circle cx="50" cy="50" r="35" fill="none" stroke="#666" stroke-width="1"/>
                    <!-- æŒ‡åŒ—é‡ -->
                    <polygon points="50,5 55,45 50,40 45,45" fill="#ff4444" stroke="#fff" stroke-width="1"/>
                    <polygon points="50,95 55,55 50,60 45,55" fill="#666" stroke="#fff" stroke-width="1"/>
                    <circle cx="50" cy="50" r="6" fill="#333"/>
                    <!-- æ–¹å‘æ¨™è¨˜ -->
                    <text x="50" y="12" text-anchor="middle" font-size="10" fill="#fff" font-weight="bold">N</text>
                    <text x="88" y="55" text-anchor="middle" font-size="8" fill="#ccc">E</text>
                    <text x="50" y="92" text-anchor="middle" font-size="8" fill="#ccc">S</text>
                    <text x="12" y="55" text-anchor="middle" font-size="8" fill="#ccc">W</text>
                </svg>
            </div>
            <div style="font-size: 18px; font-weight: bold; color: #ffd700; margin-bottom: 5px;">${roundedHeading}Â°</div>
            <div style="font-size: 14px; color: #ccc;">${directionName}</div>
            <div style="font-size: 10px; color: #888; margin-top: 5px;">ğŸ§­ æŒ‡åŒ—é‡</div>
        </div>
    `;
    
    // ç¢ºä¿æŒ‡åŒ—é‡å¯è¦‹
    compassElement.style.display = 'block';
}


// ğŸ†• é‡ç½®æ ¡æº–
function resetCalibration() {
    calibrationOffset = 0;
    showToast('ğŸ”„ å·²é‡ç½®æ–¹å‘æ ¡æº–', 'info');
}
function getCompassDirection(bearing) {
    const directions = ['åŒ—', 'æ±åŒ—', 'æ±', 'æ±å—', 'å—', 'è¥¿å—', 'è¥¿', 'è¥¿åŒ—'];
    const index = Math.round(bearing / 45) % 8;
    return directions[index];
}

// æ–°å¢ï¼šè·Ÿéš¨è£ç½®æ–¹å‘åŠŸèƒ½
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šçµ±ä¸€çš„æ–¹å‘è·Ÿéš¨åŠŸèƒ½
function toggleFollowHeading() {
    const btn = document.getElementById('followHeadingBtn');
    
    if (isFollowingHeading) {
        stopFollowHeading(btn);
    } else {
        startFollowHeading(btn);
    }
}
// ğŸ†• æ–¹å‘æ ¡æº–åŠŸèƒ½
let calibrationOffset = 0;

function calibrateDirection() {
    if (!isFollowingHeading) {
        showToast('âš ï¸ è«‹å…ˆé–‹å•Ÿæ–¹å‘è·Ÿéš¨åŠŸèƒ½', 'warning');
        return;
    }
    
    // å–å¾—ç•¶å‰åœ°åœ–æ–¹å‘
    const currentMapBearing = map.getBearing ? map.getBearing() : 0;
    
    // å‡è¨­ç•¶å‰æ‡‰è©²æœåŒ—ï¼ˆå¯ä»¥æ”¹ç‚ºä½¿ç”¨è€…æŒ‡å®šæ–¹å‘ï¼‰
    const targetDirection = 0; // åŒ—æ–¹
    
    // è¨ˆç®—æ ¡æº–åç§»
    calibrationOffset = targetDirection - currentMapBearing;
    
    showToast(`ğŸ¯ å·²æ ¡æº–æ–¹å‘ï¼Œåç§»: ${calibrationOffset.toFixed(1)}Â°`, 'success');
    
    console.log('ğŸ¯ æ–¹å‘æ ¡æº–:', {
        currentBearing: currentMapBearing,
        targetDirection: targetDirection,
        offset: calibrationOffset
    });
}

// ğŸ†• åœ¨æ–¹å‘è™•ç†ä¸­æ‡‰ç”¨æ ¡æº–
function applyCalibration(heading) {
    return (heading + calibrationOffset + 360) % 360;
}
// ğŸ†• æª¢æ¸¬è£ç½®æ–¹å‘æ”¯æ´æ€§
function checkOrientationSupport() {
  if (typeof DeviceOrientationEvent !== 'undefined') {
      orientationSupported = true;
      console.log('âœ… è£ç½®æ”¯æ´æ–¹å‘æ„Ÿæ¸¬');
      return true;
  } else {
      console.log('âŒ è£ç½®ä¸æ”¯æ´æ–¹å‘æ„Ÿæ¸¬');
      showToast('âŒ æ‚¨çš„è£ç½®ä¸æ”¯æ´æ–¹å‘æ„Ÿæ¸¬', 'error');
      return false;
  }
}
// ğŸ”§ å®Œå…¨é‡å¯«ï¼šé–‹å§‹è·Ÿéš¨æ–¹å‘
async function startFollowHeading(btn) {
  console.log('ğŸ§­ å•Ÿå‹•è£ç½®æ–¹å‘è·Ÿéš¨...');
  
  // 1. æª¢æŸ¥åŸºæœ¬æ”¯æ´æ€§
  if (!checkOrientationSupport()) {
      return;
  }
  
  try {
      // 2. iOS 13+ æ¬Šé™è«‹æ±‚
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          console.log('ğŸ“± iOS è£ç½®ï¼Œè«‹æ±‚æ–¹å‘æ¬Šé™...');
          showToast('ğŸ“± è«‹å…è¨±å­˜å–è£ç½®æ–¹å‘', 'info');
          
          const permission = await DeviceOrientationEvent.requestPermission();
          console.log('ğŸ” æ¬Šé™çµæœ:', permission);
          
          if (permission !== 'granted') {
              showToast('âŒ éœ€è¦æ–¹å‘æ¬Šé™æ‰èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½', 'error');
              return;
          }
          permissionGranted = true;
      } else {
          // Android æˆ–èˆŠç‰ˆ iOS
          console.log('ğŸ¤– Android æˆ–èˆŠç‰ˆ iOSï¼Œç„¡éœ€æ¬Šé™è«‹æ±‚');
          permissionGranted = true;
      }
      
      // 3. æ¸…é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨
      if (orientationHandler) {
          window.removeEventListener('deviceorientation', orientationHandler);
          window.removeEventListener('deviceorientationabsolute', orientationHandler);
          console.log('ğŸ§¹ å·²æ¸…é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨');
      }
      
      // 4. å»ºç«‹æ–°çš„äº‹ä»¶è™•ç†å™¨
      orientationHandler = function(event) {
          if (isFollowingHeading) {
              handleDeviceOrientationContinuous(event);
          }
      };
      
      // 5. ç¶å®šäº‹ä»¶ç›£è½å™¨ - ä½¿ç”¨å¤šç¨®äº‹ä»¶é¡å‹
      window.addEventListener('deviceorientation', orientationHandler, { passive: true });
      window.addEventListener('deviceorientationabsolute', orientationHandler, { passive: true });
      
      console.log('ğŸ¯ äº‹ä»¶ç›£è½å™¨å·²ç¶å®š');
      
      // 6. æ›´æ–°ç‹€æ…‹
      isFollowingHeading = true;
      lastHeading = null;
      
      // 7. æ›´æ–°æŒ‰éˆ•
      if (btn) {
          btn.textContent = 'ğŸ”„ åœæ­¢è·Ÿéš¨';
          btn.style.background = 'linear-gradient(135deg, #dc3545, #c82333)';
          btn.classList.add('active');
      }
      
      // 8. é¡¯ç¤ºæŒ‡åŒ—é‡
      showCompass();
      
      // 9. æ¸¬è©¦æ–¹å‘æ„Ÿæ¸¬
      setTimeout(() => {
          testOrientationWorking();
      }, 2000);
      
      showToast('ğŸ“± é–‹å§‹è·Ÿéš¨è£ç½®æ–¹å‘', 'success');
      console.log('âœ… æ–¹å‘è·Ÿéš¨å·²å•Ÿå‹•');
      
  } catch (error) {
      console.error('âŒ å•Ÿå‹•å¤±æ•—:', error);
      showToast('âŒ å•Ÿå‹•å¤±æ•—: ' + error.message, 'error');
  }
}

// ğŸ†• æ¸¬è©¦æ–¹å‘æ„Ÿæ¸¬æ˜¯å¦æ­£å¸¸å·¥ä½œ
function testOrientationWorking() {
  if (!isFollowingHeading) return;
  
  // æª¢æŸ¥æ˜¯å¦æœ‰æ”¶åˆ°æ–¹å‘è³‡æ–™
  if (lastHeading === null) {
      console.warn('âš ï¸ 2ç§’å…§æœªæ”¶åˆ°æ–¹å‘è³‡æ–™');
      showToast('âš ï¸ æœªæ”¶åˆ°æ–¹å‘è³‡æ–™ï¼Œè«‹å˜—è©¦ç§»å‹•è£ç½®', 'warning');
      
      // æä¾›æ‰‹å‹•æ¸¬è©¦æŒ‰éˆ•
      setTimeout(() => {
          if (lastHeading === null) {
              showToast('â“ é»æ“Šã€Œæ•¸æ“šæ¸¬è©¦ã€æŒ‰éˆ•æª¢æŸ¥æ„Ÿæ¸¬å™¨', 'info');
          }
      }, 3000);
  } else {
      console.log('âœ… æ–¹å‘æ„Ÿæ¸¬æ­£å¸¸å·¥ä½œ');
      showToast('âœ… æ–¹å‘è·Ÿéš¨æ­£å¸¸é‹ä½œ', 'success');
  }
}
// ğŸ”§ å®Œå…¨é‡å¯«ï¼šè™•ç†è£ç½®æ–¹å‘äº‹ä»¶ - æŒçºŒæ›´æ–°ç‰ˆ
function handleDeviceOrientationContinuous(event) {
  if (!isFollowingHeading) {
      console.log('ğŸš« æ–¹å‘è·Ÿéš¨å·²åœç”¨ï¼Œå¿½ç•¥äº‹ä»¶');
      return;
  }
  
  let heading = null;
  const timestamp = Date.now();
  
  // è¨˜éŒ„åŸå§‹äº‹ä»¶è³‡æ–™
  console.log('ğŸ“¡ æ”¶åˆ°æ–¹å‘äº‹ä»¶:', {
      alpha: event.alpha,
      beta: event.beta,
      gamma: event.gamma,
      webkitCompassHeading: event.webkitCompassHeading,
      absolute: event.absolute,
      timestamp: timestamp
  });
  
  // å„ªå…ˆä½¿ç”¨ webkitCompassHeadingï¼ˆiOSï¼‰
  if (event.webkitCompassHeading !== undefined && event.webkitCompassHeading !== null) {
      heading = event.webkitCompassHeading;
      console.log('ğŸ“± ä½¿ç”¨ iOS webkitCompassHeading:', heading);
  } 
  // ä½¿ç”¨ alphaï¼ˆAndroid å’Œå…¶ä»–ï¼‰
  else if (event.alpha !== null && event.alpha !== undefined) {
      heading = event.alpha;
      console.log('ğŸ¤– ä½¿ç”¨ Android alpha:', heading);
  }
  
  if (heading === null || heading === undefined) {
      console.warn('âš ï¸ ç„¡æ³•å–å¾—æœ‰æ•ˆçš„æ–¹å‘è³‡æ–™');
      return;
  }
  
  // æ¨™æº–åŒ–è§’åº¦ (0-360)
  heading = ((heading % 360) + 360) % 360;
  
  // ğŸ”§ é‡è¦ä¿®æ­£ï¼šé™ä½é–¾å€¼ä¸¦åŠ å…¥æ™‚é–“é–“éš”æª¢æŸ¥
  const timeSinceLastUpdate = lastHeading ? (timestamp - (lastHeading.timestamp || 0)) : 1000;
  const headingDiff = lastHeading ? Math.abs(heading - lastHeading.value) : 999;
  
  // æ›´æ–°æ¢ä»¶ï¼šè§’åº¦è®ŠåŒ–è¶…éé–¾å€¼ OR è¶…é500msæ²’æ›´æ–°
  const shouldUpdate = (
      lastHeading === null || 
      headingDiff > HEADING_THRESHOLD || 
      timeSinceLastUpdate > 500
  );
  
  if (shouldUpdate) {
      // ğŸ”§ ä¿®æ­£ï¼šç›´æ¥ä½¿ç”¨æ–¹å‘å€¼ï¼Œä¸è¦åè½‰
      updateMapBearing(heading);
      updateCompassDisplay(heading);
      
      // è¨˜éŒ„æ›´æ–°è³‡è¨Š
      lastHeading = {
          value: heading,
          timestamp: timestamp
      };
      
      console.log(`ğŸ§­ æ›´æ–°åœ°åœ–æ–¹å‘: ${heading.toFixed(1)}Â° (è®ŠåŒ–: ${headingDiff.toFixed(1)}Â°, é–“éš”: ${timeSinceLastUpdate}ms)`);
  } else {
      console.log(`ğŸ”‡ è·³éæ›´æ–°: è®ŠåŒ–${headingDiff.toFixed(1)}Â° < é–¾å€¼${HEADING_THRESHOLD}Â°`);
  }
}
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šé¡¯ç¤ºæŒ‡åŒ—é‡
function showCompass() {
    const compassElement = document.getElementById('compass');
    if (compassElement) {
        compassElement.style.display = 'block';
        updateCompassDisplay(0); // åˆå§‹é¡¯ç¤º
    }
}

// ğŸ”§ ä¿®æ­£ç‰ˆï¼šéš±è—æŒ‡åŒ—é‡
function hideCompass() {
    const compassElement = document.getElementById('compass');
    if (compassElement) {
        compassElement.style.display = 'none';
    }
}

// ğŸ”§ ä¿®æ­£ç‰ˆï¼šåœæ­¢è·Ÿéš¨æ–¹å‘
function stopFollowHeading(btn) {
  console.log('ğŸ›‘ åœæ­¢è£ç½®æ–¹å‘è·Ÿéš¨...');
  
  // ç§»é™¤äº‹ä»¶ç›£è½å™¨
  if (orientationHandler) {
      window.removeEventListener('deviceorientation', orientationHandler);
      window.removeEventListener('deviceorientationabsolute', orientationHandler);
      orientationHandler = null;
      console.log('ğŸ§¹ å·²ç§»é™¤äº‹ä»¶ç›£è½å™¨');
  }
  
  // é‡ç½®ç‹€æ…‹
  isFollowingHeading = false;
  lastHeading = null;
  permissionGranted = false;
  
  // é‡ç½®åœ°åœ–æ–¹å‘
  if (map && map.setBearing) {
      map.setBearing(0, { animate: true, duration: 500 });
  }
  
  // æ›´æ–°æŒ‰éˆ•
  if (btn) {
      btn.textContent = 'ğŸ“± è·Ÿéš¨è£ç½®æ–¹å‘';
      btn.style.background = 'linear-gradient(135deg, #6c757d, #495057)';
      btn.classList.remove('active');
  }
  
  // éš±è—æŒ‡åŒ—é‡
  hideCompass();
  
  showToast('ğŸ›‘ å·²åœæ­¢è·Ÿéš¨è£ç½®æ–¹å‘', 'info');
  console.log('âœ… æ–¹å‘è·Ÿéš¨å·²åœæ­¢');
}


// ğŸ”§ ä¿®æ­£ç‰ˆï¼šè™•ç†è£ç½®æ–¹å‘äº‹ä»¶
function handleDeviceOrientation(event) {
    if (!isFollowingHeading) return;
    
    let heading = null;
    
    // å„ªå…ˆä½¿ç”¨ webkitCompassHeadingï¼ˆiOSï¼‰
    if (event.webkitCompassHeading !== undefined) {
        heading = event.webkitCompassHeading;
        console.log('ğŸ“± iOS æ–¹å‘:', heading);
    } 
    // ä½¿ç”¨ alphaï¼ˆAndroidï¼‰
    else if (event.alpha !== null) {
        heading = event.alpha;
        
        // ğŸ”§ é‡è¦ä¿®æ­£ï¼šç§»é™¤ Android çš„è§’åº¦åè½‰
        // åŸæœ¬çš„ç¨‹å¼ç¢¼æœƒè®“åœ°åœ–æœåæ–¹å‘è½‰å‹•
        // heading = 360 - heading; // âŒ ç§»é™¤é€™è¡Œ
        
        console.log('ğŸ¤– Android æ–¹å‘:', heading);
    }
    
    if (heading === null) {
        console.warn('âš ï¸ ç„¡æ³•å–å¾—æ–¹å‘è³‡æ–™');
        return;
    }
    
    // æ¨™æº–åŒ–è§’åº¦ (0-360)
    heading = ((heading % 360) + 360) % 360;
    
    // ğŸ”§ ä¿®æ­£ï¼šå¢åŠ å¹³æ»‘åŒ–è™•ç†ï¼Œæ¸›å°‘æŠ–å‹•
    if (lastHeading === null || Math.abs(heading - lastHeading) > HEADING_THRESHOLD) {
        // ğŸ”§ ä¿®æ­£ï¼šç›´æ¥ä½¿ç”¨æ–¹å‘å€¼ï¼Œä¸è¦åè½‰
        updateMapBearing(heading);
        updateCompassDisplay(heading);
        lastHeading = heading;
        
        console.log(`ğŸ§­ æ›´æ–°åœ°åœ–æ–¹å‘: ${heading.toFixed(1)}Â°`);
    }
}

// ğŸ”§ ä¿®æ­£ç‰ˆï¼šæ›´æ–°åœ°åœ–æ–¹å‘ - æ›´å¹³æ»‘çš„å‹•ç•«
function updateMapBearing(bearing) {
  if (!map) return;
  
  try {
      if (map.setBearing) {
          // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨æ›´çŸ­çš„å‹•ç•«æ™‚é–“ï¼Œè®“è·Ÿéš¨æ›´å³æ™‚
          map.setBearing(bearing, {
              animate: true,
              duration: 200 // å¾ 300ms é™åˆ° 200ms
          });
      }
  } catch (error) {
      console.error('âŒ æ›´æ–°åœ°åœ–æ–¹å‘å¤±æ•—:', error);
  }
}


// æ–°å¢ï¼šåœ–å±¤åˆ‡æ›åŠŸèƒ½
function initializeLayerSwitcher() {
    const baseLayerRadios = document.querySelectorAll('input[name="baseLayer"]');
    
    baseLayerRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            if (this.checked) {
                switchBaseLayer(this.value);
            }
        });
    });
}

function switchBaseLayer(layerName) {
    // ç§»é™¤ç•¶å‰åŸºç¤åœ–å±¤
    if (window.currentBaseLayer) {
        map.removeLayer(window.currentBaseLayer);
    }
    
    // åŠ å…¥æ–°çš„åŸºç¤åœ–å±¤
    if (window.mapLayers[layerName]) {
        window.currentBaseLayer = window.mapLayers[layerName].addTo(map);
        console.log(`ğŸ—ºï¸ åˆ‡æ›åˆ°åœ–å±¤: ${layerName}`);
        showToast(`ğŸ—ºï¸ å·²åˆ‡æ›åˆ° ${getLayerDisplayName(layerName)}`, 'success');
    }
}

function getLayerDisplayName(layerName) {
    const names = {
        googleStreets: 'Google è¡—æ™¯åœ–',
        googleSatellite: 'Google è¡›æ˜Ÿå½±åƒ',
        googleHybrid: 'Google æ··åˆåœ–',
        openStreetMap: 'OpenStreetMap',
        nlscMap: 'åœ‹åœŸæ¸¬ç¹ªé›»å­åœ°åœ–',
        nlscPhoto: 'åœ‹åœŸæ¸¬ç¹ªæ­£å°„å½±åƒ',
        cartoDB: 'CartoDB æ·¡è‰²',
        stamen: 'Stamen é»‘ç™½',
        esriSatellite: 'Esri è¡›æ˜Ÿå½±åƒ'
    };
    return names[layerName] || layerName;
}

// æ–°å¢ï¼šç–ŠåŠ åœ–å±¤æ§åˆ¶
function toggleTrafficLayer() {
    const checkbox = document.getElementById('trafficLayer');
    
    if (checkbox.checked) {
        // åŠ å…¥äº¤é€šè·¯æ³åœ–å±¤ï¼ˆä½¿ç”¨ Google äº¤é€šè³‡è¨Šï¼‰
        if (!window.overlayLayers.traffic) {
            window.overlayLayers.traffic = L.tileLayer('https://{s}.google.com/vt/lyrs=h@{time}&x={x}&y={y}&z={z}', {
                maxZoom: 22,
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                time: Date.now(),
                opacity: 0.7
            });
        }
        window.overlayLayers.traffic.addTo(map);
        showToast('ğŸš¦ å·²é–‹å•Ÿäº¤é€šè·¯æ³', 'info');
    } else {
        if (window.overlayLayers.traffic) {
            map.removeLayer(window.overlayLayers.traffic);
        }
        showToast('ğŸš¦ å·²é—œé–‰äº¤é€šè·¯æ³', 'info');
    }
}

function toggleWeatherLayer() {
    const checkbox = document.getElementById('weatherLayer');
    
    if (checkbox.checked) {
        // åŠ å…¥å¤©æ°£é›·é”åœ–å±¤
        if (!window.overlayLayers.weather) {
            window.overlayLayers.weather = L.tileLayer('https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=YOUR_API_KEY', {
                maxZoom: 22,
                opacity: 0.6,
                attribution: 'Â© OpenWeatherMap'
            });
        }
        window.overlayLayers.weather.addTo(map);
        showToast('ğŸŒ§ï¸ å·²é–‹å•Ÿå¤©æ°£é›·é”', 'info');
    } else {
        if (window.overlayLayers.weather) {
            map.removeLayer(window.overlayLayers.weather);
        }
        showToast('ğŸŒ§ï¸ å·²é—œé–‰å¤©æ°£é›·é”', 'info');
    }
}

function toggleTerrainLayer() {
    const checkbox = document.getElementById('terrainLayer');
    
    if (checkbox.checked) {
        // åŠ å…¥åœ°å½¢ç­‰é«˜ç·šåœ–å±¤
        if (!window.overlayLayers.terrain) {
            window.overlayLayers.terrain = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                maxZoom: 22,
                opacity: 0.5,
                attribution: 'Â© OpenTopoMap'
            });
        }
        window.overlayLayers.terrain.addTo(map);
        showToast('ğŸ”ï¸ å·²é–‹å•Ÿåœ°å½¢ç­‰é«˜ç·š', 'info');
    } else {
        if (window.overlayLayers.terrain) {
            map.removeLayer(window.overlayLayers.terrain);
        }
        showToast('ğŸ”ï¸ å·²é—œé–‰åœ°å½¢ç­‰é«˜ç·š', 'info');
    }
}

// æ–°å¢ï¼šèª¿æ•´åœ–å±¤é€æ˜åº¦
function adjustLayerOpacity(value) {
    const opacity = value / 100;
    document.getElementById('opacityValue').textContent = value + '%';
    
    if (window.currentBaseLayer) {
        window.currentBaseLayer.setOpacity(opacity);
    }
}

// ğŸ”§ ä¿®æ­£ï¼šå…¨è¢å¹•åŠŸèƒ½ - æ”¹å–„æŒ‰éˆ•ç‹€æ…‹ç®¡ç†
function toggleFullscreen() {
    const btn = document.querySelector('.fullscreen-btn');
    
    if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
        // é€²å…¥å…¨è¢å¹•
        const element = document.documentElement;
        
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
        
    } else {
        // é€€å‡ºå…¨è¢å¹•
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
}

// ğŸ†• ç›£è½å…¨è¢å¹•ç‹€æ…‹è®ŠåŒ–
function handleFullscreenChange() {
    const btn = document.querySelector('.fullscreen-btn');
    const body = document.body;
    
    const isFullscreen = !!(document.fullscreenElement || 
                           document.webkitFullscreenElement || 
                           document.mozFullScreenElement || 
                           document.msFullscreenElement);
    
    if (isFullscreen) {
        btn.textContent = 'ğŸ”³ é€€å‡ºå…¨è¢å¹•';
        btn.title = 'é»æ“Šé€€å‡ºå…¨è¢å¹•æ¨¡å¼ (æˆ–æŒ‰ ESC)';
        body.classList.add('fullscreen-mode');
        showToast('ğŸ”² å·²é€²å…¥å…¨è¢å¹•æ¨¡å¼ï¼Œé»æ“Šå·¦ä¸Šè§’æŒ‰éˆ•æˆ–æŒ‰ ESC é€€å‡º', 'info');
        
        // ğŸ”§ å»¶é²èª¿æ•´åœ°åœ–å¤§å°
        setTimeout(() => {
            if (map) {
                map.invalidateSize();
            }
        }, 100);
        
    } else {
        btn.textContent = 'ğŸ”² å…¨è¢å¹•';
        btn.title = 'é»æ“Šé€²å…¥å…¨è¢å¹•æ¨¡å¼';
        body.classList.remove('fullscreen-mode');
        showToast('ğŸ”³ å·²é€€å‡ºå…¨è¢å¹•æ¨¡å¼', 'info');
        
        // ğŸ”§ å»¶é²èª¿æ•´åœ°åœ–å¤§å°
        setTimeout(() => {
            if (map) {
                map.invalidateSize();
            }
        }, 100);
    }
}

// ğŸ†• ç¶å®šå…¨è¢å¹•äº‹ä»¶ç›£è½å™¨
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);

// ğŸ†• ESC éµé€€å‡ºå…¨è¢å¹•æç¤º
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && (document.fullscreenElement || document.webkitFullscreenElement)) {
        showToast('ğŸ”³ æŒ‰ ESC éµé€€å‡ºå…¨è¢å¹•', 'info');
    }
});
// æ–°å¢ï¼šæ¸¬é‡å·¥å…·åˆå§‹åŒ–
function initializeMeasureTools() {
    // åˆå§‹åŒ–æ¸¬é‡ç›¸é—œçš„åœ°åœ–äº‹ä»¶ç›£è½
    map.on('click', handleMapClick);
}

function toggleMeasureDistance() {
    const btn = document.getElementById('measureDistanceBtn');
    
    if (measureDistanceMode) {
        measureDistanceMode = false;
        btn.classList.remove('active');
        btn.textContent = 'ğŸ“ æ¸¬è·';
        map.getContainer().style.cursor = '';
    } else {
        measureDistanceMode = true;
        measureAreaMode = false;
        btn.classList.add('active');
        btn.textContent = 'â¹ï¸ åœæ­¢æ¸¬è·';
        document.getElementById('measureAreaBtn').classList.remove('active');
        document.getElementById('measureAreaBtn').textContent = 'ğŸ“ æ¸¬é¢ç©';
        map.getContainer().style.cursor = 'crosshair';
        showToast('ğŸ“ é»æ“Šåœ°åœ–é–‹å§‹æ¸¬è·', 'info');
    }
}

function handleMapClick(e) {
    if (measureDistanceMode) {
        addMeasurePoint(e.latlng, 'distance');
    }
}

function addMeasurePoint(latlng, type) {
    const marker = L.circleMarker(latlng, {
        radius: 5,
        fillColor: '#ff0000',
        color: '#ffffff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.8
    }).addTo(map);
    
    measureMarkers.push(marker);
    
    if (measureMarkers.length >= 2) {
        drawDistanceLine();
    }
}


function drawDistanceLine() {
    if (measureMarkers.length < 2) return;
    
    const points = measureMarkers.map(marker => marker.getLatLng());
    const line = L.polyline(points, {color: 'red', weight: 3}).addTo(map);
    measureLines.push(line);
    
    // è¨ˆç®—ç¸½è·é›¢
    let totalDistance = 0;
    for (let i = 1; i < points.length; i++) {
        totalDistance += points[i-1].distanceTo(points[i]);
    }
    
    const distanceText = totalDistance > 1000 ? 
        `${(totalDistance/1000).toFixed(2)} å…¬é‡Œ` : 
        `${totalDistance.toFixed(0)} å…¬å°º`;
    
    // åœ¨ç·šæ®µä¸­é»é¡¯ç¤ºè·é›¢
    const midpoint = points[Math.floor(points.length/2)];
    const popup = L.popup()
        .setLatLng(midpoint)
        .setContent(`ğŸ“ è·é›¢: ${distanceText}`)
        .openOn(map);
}



function clearMeasurements() {
    // æ¸…é™¤æ‰€æœ‰æ¸¬é‡æ¨™è¨˜
    measureMarkers.forEach(marker => map.removeLayer(marker));
    measureMarkers = [];
    
    // æ¸…é™¤æ‰€æœ‰æ¸¬é‡ç·šæ®µ
    measureLines.forEach(line => map.removeLayer(line));
    measureLines = [];
    
    // é—œé–‰æ¸¬é‡æ¨¡å¼
    measureDistanceMode = false;
    
    // é‡ç½®æŒ‰éˆ•ç‹€æ…‹
    document.getElementById('measureDistanceBtn').classList.remove('active');
    document.getElementById('measureDistanceBtn').textContent = 'ğŸ“ æ¸¬è·';
    
    // é‡ç½®æ»‘é¼ æ¸¸æ¨™
    map.getContainer().style.cursor = '';
    
    // é—œé–‰æ‰€æœ‰å½ˆå‡ºè¦–çª—
    map.closePopup();
    
    showToast('ğŸ—‘ï¸ å·²æ¸…é™¤æ‰€æœ‰æ¸¬é‡', 'info');
}



// æ–°å¢ï¼šåœ°åœ–ç¸®æ”¾æ™‚è‡ªå‹•èª¿æ•´æ§åˆ¶é¢æ¿
map.on('zoomend', function() {
    const zoom = map.getZoom();
    const controls = document.querySelectorAll('.rotation-controls, .layer-switcher');
    
    controls.forEach(control => {
        if (zoom < 10) {
            control.style.opacity = '0.7';
        } else {
            control.style.opacity = '1';
        }
    });
});

// æ–°å¢ï¼šåœ°åœ–ç§»å‹•æ™‚æ›´æ–° URLï¼ˆä¾¿æ–¼åˆ†äº«ä½ç½®ï¼‰
let urlUpdateTimeout;
map.on('moveend', function() {
    clearTimeout(urlUpdateTimeout);
    urlUpdateTimeout = setTimeout(() => {
        const center = map.getCenter();
        const zoom = map.getZoom();
        const bearing = currentRotation;
        
        const newUrl = `${window.location.pathname}#${zoom}/${center.lat.toFixed(6)}/${center.lng.toFixed(6)}/${bearing}`;
        window.history.replaceState(null, null, newUrl);
    }, 1000);
});

// æ–°å¢ï¼šå¾ URL è¼‰å…¥åœ°åœ–ä½ç½®
function loadMapFromURL() {
    const hash = window.location.hash.substring(1);
    if (hash) {
        const parts = hash.split('/');
        if (parts.length >= 3) {
            const zoom = parseFloat(parts[0]);
            const lat = parseFloat(parts[1]);
            const lng = parseFloat(parts[2]);
            const bearing = parts[3] ? parseFloat(parts[3]) : 0;
            
            if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lng)) {
                map.setView([lat, lng], zoom);
                if (!isNaN(bearing)) {
                    setMapRotation(bearing);
                }
            }
        }
    }
}

// æ–°å¢ï¼šå³éµé¸å–®åŠŸèƒ½
map.on('contextmenu', function(e) {
    const lat = e.latlng.lat;
    const lng = e.latlng.lng;
    
    const contextMenu = L.popup({
        closeButton: false,
        autoClose: true,
        closeOnEscapeKey: true
    })
    .setLatLng(e.latlng)
    .setContent(`
        <div style="text-align: center; min-width: 150px;">
            <h4 style="margin: 0 0 10px 0;">ğŸ“ ä½ç½®æ“ä½œ</h4>
            <button onclick="copyCoordinates(${lat}, ${lng}); map.closePopup();" 
                    style="width: 100%; margin: 2px 0; padding: 5px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">
                ğŸ“‹ è¤‡è£½åº§æ¨™
            </button>
            <button onclick="openStreetView(${lat}, ${lng}); map.closePopup();" 
                    style="width: 100%; margin: 2px 0; padding: 5px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">
                ğŸ—ºï¸ è¡—æ™¯åœ–
            </button>
            <button onclick="openNavigation(${lat}, ${lng}, 'é¸å®šä½ç½®'); map.closePopup();" 
                    style="width: 100%; margin: 2px 0; padding: 5px; background: #ffc107; color: black; border: none; border-radius: 3px; cursor: pointer;">
                ğŸ§­ å°èˆªè‡³æ­¤
            </button>
            <button onclick="addCustomMarker(${lat}, ${lng}); map.closePopup();" 
                    style="width: 100%; margin: 2px 0; padding: 5px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">
                ğŸ“Œ æ–°å¢æ¨™è¨˜
            </button>
        </div>
    `)
    .openOn(map);
});

// æ–°å¢ï¼šè‡ªè¨‚æ¨™è¨˜åŠŸèƒ½
let customMarkers = [];

function addCustomMarker(lat, lng) {
    const markerText = prompt('è«‹è¼¸å…¥æ¨™è¨˜åç¨±:', 'è‡ªè¨‚æ¨™è¨˜');
    if (markerText) {
        const marker = L.marker([lat, lng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map);
        
        marker.bindPopup(`
            <div style="text-align: center;">
                <h4>ğŸ“Œ ${markerText}</h4>
                <p><strong>åº§æ¨™:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                <button onclick="removeCustomMarker(this)" data-marker-id="${customMarkers.length}"
                        style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">
                    ğŸ—‘ï¸ åˆªé™¤æ¨™è¨˜
                </button>
            </div>
        `).openPopup();
        
        customMarkers.push(marker);
        showToast(`ğŸ“Œ å·²æ–°å¢æ¨™è¨˜: ${markerText}`, 'success');
    }
}

function removeCustomMarker(button) {
    const markerId = parseInt(button.getAttribute('data-marker-id'));
    if (customMarkers[markerId]) {
        map.removeLayer(customMarkers[markerId]);
        customMarkers[markerId] = null;
        map.closePopup();
        showToast('ğŸ—‘ï¸ å·²åˆªé™¤æ¨™è¨˜', 'info');
    }
}

// æ–°å¢ï¼šæ‰¹æ¬¡æ¸…é™¤è‡ªè¨‚æ¨™è¨˜
function clearAllCustomMarkers() {
    customMarkers.forEach(marker => {
        if (marker) {
            map.removeLayer(marker);
        }
    });
    customMarkers = [];
    showToast('ğŸ—‘ï¸ å·²æ¸…é™¤æ‰€æœ‰è‡ªè¨‚æ¨™è¨˜', 'info');
}

// æ–°å¢ï¼šåŒ¯å‡ºåœ°åœ–ç‚ºåœ–ç‰‡åŠŸèƒ½
function exportMapAsImage() {
    // ä½¿ç”¨ html2canvas æˆ–é¡ä¼¼åº«ä¾†æˆªåœ–
    // é€™è£¡æä¾›ä¸€å€‹ç°¡åŒ–ç‰ˆæœ¬
    showToast('ğŸ“¸ åœ°åœ–æˆªåœ–åŠŸèƒ½é–‹ç™¼ä¸­...', 'info');
}

// æ–°å¢ï¼šåˆ†äº«åœ°åœ–ä½ç½®åŠŸèƒ½
function shareMapLocation() {
    const center = map.getCenter();
    const zoom = map.getZoom();
    const bearing = currentRotation;
    
    const shareUrl = `${window.location.origin}${window.location.pathname}#${zoom}/${center.lat.toFixed(6)}/${center.lng.toFixed(6)}/${bearing}`;
    
    if (navigator.share) {
        navigator.share({
            title: 'é¥‹ç·šåœ–åœ°åœ–ä½ç½®',
            text: `æŸ¥çœ‹é€™å€‹åœ°åœ–ä½ç½® (ç¸®æ”¾: ${zoom}, æ–¹ä½: ${Math.round(bearing)}Â°)`,
            url: shareUrl
        });
    } else {
        // å‚™ç”¨æ–¹æ¡ˆï¼šè¤‡è£½åˆ°å‰ªè²¼ç°¿
        navigator.clipboard.writeText(shareUrl).then(() => {
            showToast('ğŸ”— åœ°åœ–ä½ç½®é€£çµå·²è¤‡è£½åˆ°å‰ªè²¼ç°¿', 'success');
        });
    }
}

// é é¢è¼‰å…¥å®Œæˆå¾Œçš„é¡å¤–åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    // è¼‰å…¥ URL ä¸­çš„åœ°åœ–ä½ç½®
    setTimeout(loadMapFromURL, 1000);
    
    // ç›£è½å…¨è¢å¹•è®ŠåŒ–
    document.addEventListener('fullscreenchange', function() {
        setTimeout(() => {
            map.invalidateSize();
        }, 100);
    });
    
    // ç›£è½è¦–çª—å¤§å°è®ŠåŒ–
    window.addEventListener('resize', function() {
        setTimeout(() => {
            map.invalidateSize();
        }, 100);
    });
});

// åœ–å±¤é¸å–®æ§åˆ¶
function toggleLayerMenu() {
    const menu = document.getElementById('layerMenu');
    const isVisible = menu.style.display !== 'none';
    menu.style.display = isVisible ? 'none' : 'block';
}

// é»æ“Šåœ°åœ–æ™‚é—œé–‰åœ–å±¤é¸å–®
map.on('click', function() {
    document.getElementById('layerMenu').style.display = 'none';
});

// ğŸ†• æ–°å¢ï¼šç–ŠåŠ åœ–å±¤æ§åˆ¶å‡½æ•¸
// ğŸ”§ ä¿®æ”¹ï¼šç§»é™¤ checkbox ä¾è³´çš„ç‰ˆæœ¬
function toggleOverlayLayer(layerName, forceState = null) {
    const layer = window.overlayLayers[layerName];
    if (!layer) {
        console.warn(`æ‰¾ä¸åˆ°åœ–å±¤: ${layerName}`);
        showToast(`âŒ åœ–å±¤ ${layerName} æš«æ™‚ç„¡æ³•ä½¿ç”¨`, 'error');
        return;
    }
    
    // æª¢æŸ¥åœ–å±¤æ˜¯å¦å·²åœ¨åœ°åœ–ä¸Š
    const isLayerOnMap = map.hasLayer(layer);
    const shouldAdd = forceState !== null ? forceState : !isLayerOnMap;
    
    if (shouldAdd && !isLayerOnMap) {
        layer.addTo(map);
        showToast(`âœ… å·²é–‹å•Ÿ ${getOverlayDisplayName(layerName)}`, 'success');
        console.log(`ğŸ—ºï¸ é–‹å•Ÿåœ–å±¤: ${layerName}`);
    } else if (!shouldAdd && isLayerOnMap) {
        map.removeLayer(layer);
        showToast(`âŒ å·²é—œé–‰ ${getOverlayDisplayName(layerName)}`, 'info');
        console.log(`ğŸ—ºï¸ é—œé–‰åœ–å±¤: ${layerName}`);
    }
    
    return !isLayerOnMap; // å›å‚³æ–°çš„ç‹€æ…‹
}

// ğŸ†• æ–°å¢ï¼šç›´æ¥æ§åˆ¶åœ–å±¤çš„ä¾¿åˆ©å‡½å¼
function showOverlayLayer(layerName) {
    return toggleOverlayLayer(layerName, true);
}

function hideOverlayLayer(layerName) {
    return toggleOverlayLayer(layerName, false);
}

// ğŸ†• æ–°å¢ï¼šæ‰¹æ¬¡æ§åˆ¶åœ–å±¤
function toggleMultipleLayers(layerNames, state = null) {
    layerNames.forEach(layerName => {
        toggleOverlayLayer(layerName, state);
    });
}


// ğŸ†• æ–°å¢ï¼šå–å¾—ç–ŠåŠ åœ–å±¤é¡¯ç¤ºåç¨±
function getOverlayDisplayName(layerName) {
    const names = {
        roadNetwork: 'è·¯ç¶²åœ–å±¤',
        railway: 'éµè·¯åœ–å±¤',
        landmark: 'å…¬æœ‰åœŸåœ°åœ–',
        cadastre: 'è¡Œæ”¿å€ç•Œåœ–',
        section: 'æ®µç±åœ–',
        village: 'æ‘é‡Œç•Œåœ–',
        wayMeter: 'å…¬è·¯é‡Œç¨‹æ¨™èªŒ',
        kaohsiungSlope: 'é«˜é›„å±±å¡åœ°ç¯„åœ',
        industrialZone: 'å·¥æ¥­å€ç¯„åœ',
        industrialLand: 'å·¥æ¥­å€åœ°ç±åœ–',
        industrialUser: 'å·¥æ¥­å€ç”¨æˆ¶å',
        urbanPlan: 'é«˜é›„å¸‚éƒ½å¸‚è¨ˆç•«åœ–',
        urbanPlanBoundary: 'é«˜é›„å¸‚éƒ½å¸‚è¨ˆç•«ç¯„åœåœ–',
        trafficNetwork: 'åœ‹åœŸè¨ˆç•«åœ–'
    };
    return names[layerName] || layerName;
}


// ğŸ†• æ‰‹æ©Ÿç‰ˆå°èˆªåŠŸèƒ½
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šæ‰‹æ©Ÿç‰ˆå°èˆªåŠŸèƒ½
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šæ‰‹æ©Ÿç‰ˆå°èˆªåŠŸèƒ½ - ä¿æŒåœ–å±¤æ§åˆ¶é …
function initMobileNavigation() {
    const navTabs = document.querySelectorAll('.nav-tab');
    const sidebar = document.querySelector('.sidebar');
    const mapContainer = document.querySelector('.map-container');
    
    // åªåœ¨æ‰‹æ©Ÿç‰ˆåŸ·è¡Œ
    if (window.innerWidth <= 768) {
        navTabs.forEach(tab => {
            tab.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // ç§»é™¤æ‰€æœ‰ active ç‹€æ…‹
                navTabs.forEach(t => t.classList.remove('active'));
                // æ·»åŠ ç•¶å‰ active ç‹€æ…‹
                this.classList.add('active');
                
                const tabType = this.getAttribute('data-tab');
                
                switch(tabType) {
                    case 'map':
                        mapContainer.style.display = 'block';
                        sidebar.style.display = 'none';
                        setTimeout(() => {
                            if (map) map.invalidateSize();
                        }, 100);
                        break;
                        
                    case 'controls':
                        mapContainer.style.display = 'none';
                        sidebar.style.display = 'block';
                        // ğŸ”§ ä¿®æ­£ï¼šä¸è¦é‡ç½®å´é‚Šæ¬„å…§å®¹ï¼Œä¿æŒåœ–å±¤æ§åˆ¶é …
                        break;
                        
                    case 'info':
                        mapContainer.style.display = 'none';
                        sidebar.style.display = 'block';
                        showInfoPanel();
                        break;
                }
            });
        });
    }
}

// ğŸ†• æ–°å¢ï¼šé‡æ–°åˆå§‹åŒ–æ‰€æœ‰æ§åˆ¶é …
function reinitializeControls() {
    console.log('ğŸ”„ é–‹å§‹é‡æ–°åˆå§‹åŒ–æ§åˆ¶é …...');
    
    try {
        // é‡æ–°åˆå§‹åŒ–é¥‹ç·šä¸‹æ‹‰é¸å–®
        if (feederList && feederList.length > 0) {
            initializeFeederDropdown();
            console.log('âœ… é¥‹ç·šä¸‹æ‹‰é¸å–®å·²é‡æ–°åˆå§‹åŒ–');
        }
        
        // é‡æ–°ç¶å®šæª”æ¡ˆä¸Šå‚³äº‹ä»¶
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨
            fileInput.removeEventListener('change', handleFileInput);
            // é‡æ–°ç¶å®š
            fileInput.addEventListener('change', handleFileInput);
            console.log('âœ… æª”æ¡ˆä¸Šå‚³äº‹ä»¶å·²é‡æ–°ç¶å®š');
        }
        
        // é‡æ–°åˆå§‹åŒ–å…¶ä»–æ§åˆ¶é …...
        console.log('âœ… æ‰€æœ‰æ§åˆ¶é …é‡æ–°åˆå§‹åŒ–å®Œæˆ');
        
    } catch (error) {
        console.error('âŒ é‡æ–°åˆå§‹åŒ–æ§åˆ¶é …å¤±æ•—:', error);
    }
}
// ğŸ†• æª”æ¡ˆè¼¸å…¥è™•ç†å‡½æ•¸ï¼ˆå¾åŸæœ¬çš„åŒ¿åå‡½æ•¸æå–å‡ºä¾†ï¼‰
function handleFileInput(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.name.toLowerCase().endsWith('.json')) {
        alert('è«‹é¸æ“‡ JSON æ ¼å¼çš„æª”æ¡ˆï¼');
        return;
    }
    
    // é¡¯ç¤ºè¼‰å…¥æŒ‡ç¤ºå™¨
    document.getElementById('loadingIndicator').classList.add('show');
    updateLoadStatus(`æ­£åœ¨è®€å–æª”æ¡ˆ: ${file.name}...`);
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const jsonData = JSON.parse(e.target.result);
            processJsonData(jsonData, file.name);
        } catch (error) {
            console.error('âŒ JSON è§£æéŒ¯èª¤:', error);
            updateLoadStatus('âŒ æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹æª¢æŸ¥ JSON æ ¼å¼');
            alert('æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹ç¢ºèªæ˜¯æœ‰æ•ˆçš„ JSON æª”æ¡ˆï¼');
        } finally {
            // éš±è—è¼‰å…¥æŒ‡ç¤ºå™¨
            document.getElementById('loadingIndicator').classList.remove('show');
        }
    };
    
    reader.onerror = function() {
        updateLoadStatus('âŒ æª”æ¡ˆè®€å–å¤±æ•—');
        document.getElementById('loadingIndicator').classList.remove('show');
    };
    
    reader.readAsText(file);
}
// ğŸ†• è³‡è¨Šé¢æ¿åŠŸèƒ½
// ğŸ”§ ä¿®æ­£ç‰ˆï¼šè³‡è¨Šé¢æ¿
function showInfoPanel() {
    const sidebar = document.querySelector('.sidebar');
    
    const infoContent = `
        <div style="padding: 20px; background: white; height: 100%; overflow-y: auto;">
            <h3 style="color: #2c3e50; margin-bottom: 20px;">ğŸ“‹ ç³»çµ±è³‡è¨Š</h3>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #495057;">ğŸ”§ ç‰ˆæœ¬è³‡è¨Š</h4>
                <p style="margin: 5px 0;"><strong>ç‰ˆæœ¬ï¼š</strong>2.0.0</p>
                <p style="margin: 5px 0;"><strong>æ›´æ–°ï¼š</strong>${new Date().toLocaleDateString('zh-TW')}</p>
            </div>
            
            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #1976d2;">ğŸ“– åŠŸèƒ½èªªæ˜</h4>
                <ul style="margin: 0; padding-left: 20px;">
                    <li style="margin: 8px 0;">ğŸ—ºï¸ <strong>åœ°åœ–æª¢è¦–ï¼š</strong>ç€è¦½é¥‹ç·šåˆ†ä½ˆåœ–</li>
                    <li style="margin: 8px 0;">âš™ï¸ <strong>é¥‹ç·šæ§åˆ¶ï¼š</strong>è¼‰å…¥å’Œç®¡ç†é¥‹ç·šè³‡æ–™</li>
                    <li style="margin: 8px 0;">ğŸ“ <strong>æ¸¬è·å·¥å…·ï¼š</strong>æ¸¬é‡åœ°åœ–ä¸Šçš„è·é›¢</li>
                    <li style="margin: 8px 0;">ğŸ›ï¸ <strong>åœ–å±¤æ§åˆ¶ï¼š</strong>é¡¯ç¤º/éš±è—ä¸åŒåœ–å±¤</li>
                </ul>
            </div>
            
            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #856404;">ğŸ’¡ ä½¿ç”¨æç¤º</h4>
                <p style="margin: 5px 0; font-size: 14px;">â€¢ é»æ“Šç·šæ®µå¯ä»¥é«˜äº®é¡¯ç¤º</p>
                <p style="margin: 5px 0; font-size: 14px;">â€¢ é•·æŒ‰åœ°åœ–å¯ä»¥é–‹å•Ÿå³éµé¸å–®</p>
                <p style="margin: 5px 0; font-size: 14px;">â€¢ ä½¿ç”¨é›™æŒ‡ç¸®æ”¾èª¿æ•´åœ°åœ–å¤§å°</p>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
                <button onclick="switchToControlsTab()" 
                        style="padding: 12px; background: linear-gradient(135deg, #28a745, #20c997); 
                               color: white; border: none; border-radius: 8px; cursor: pointer; 
                               font-size: 14px; font-weight: bold;
                               box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);">
                    âš™ï¸ æ§åˆ¶é¢æ¿
                </button>
                
                <button onclick="switchToMapTab()" 
                        style="padding: 12px; background: linear-gradient(135deg, #3498db, #2980b9); 
                               color: white; border: none; border-radius: 8px; cursor: pointer; 
                               font-size: 14px; font-weight: bold;
                               box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);">
                    ğŸ—ºï¸ è¿”å›åœ°åœ–
                </button>
            </div>
        </div>
    `;
    
    sidebar.innerHTML = infoContent;
}
// ğŸ†• åˆ‡æ›åˆ°åœ°åœ–æ¨™ç±¤
function switchToMapTab() {
    const mapTab = document.querySelector('[data-tab="map"]');
    if (mapTab) {
        mapTab.click();
    }
}
// ğŸ†• åˆ‡æ›åˆ°æ§åˆ¶é¢æ¿æ¨™ç±¤
function switchToControlsTab() {
    const controlsTab = document.querySelector('[data-tab="controls"]');
    if (controlsTab) {
        controlsTab.click();
    }
}

// ğŸ†• åˆ‡æ›åˆ°åœ°åœ–æ¨™ç±¤
function switchToMapTab() {
    const mapTab = document.querySelector('[data-tab="map"]');
    if (mapTab) {
        mapTab.click();
    }
}

// ğŸ†• ç›£è½è¦–çª—å¤§å°è®ŠåŒ–
window.addEventListener('resize', function() {
    // ç•¶å¾æ‰‹æ©Ÿåˆ‡æ›åˆ°æ¡Œé¢æ™‚ï¼Œé‡ç½®é¡¯ç¤ºç‹€æ…‹
    if (window.innerWidth > 768) {
        const sidebar = document.querySelector('.sidebar');
        const mapContainer = document.querySelector('.map-container');
        
        sidebar.style.display = 'block';
        mapContainer.style.display = 'block';
        
        // æ¢å¾©åŸå§‹å´é‚Šæ¬„å…§å®¹ï¼ˆå¦‚æœè¢«ä¿®æ”¹éï¼‰
        location.reload(); // ç°¡å–®çš„é‡è¼‰æ–¹æ¡ˆ
    }
    
    // èª¿æ•´åœ°åœ–å¤§å°
    setTimeout(() => {
        if (map) map.invalidateSize();
    }, 100);
});

		  </script>
	  </body>
	  </html>
